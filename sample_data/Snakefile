import os,sys
import glob
import itertools
import mikado_lib.configuration.configurator
from mikado_lib.utilities import path_join
import subprocess

swissprot = "uniprot_sprot_plants.fasta"
swissprot_noat = "uniprot_sprot_plants.not_at.fasta"

DBs=[swissprot]
zipDBs=["{0}.gz".format(db) for db in DBs]

configfile: "configuration.yaml"
configname = "configuration.yaml"
config = mikado_lib.configuration.configurator.to_json(configname)

rule clean:
    run:
        for filename in itertools.chain(glob.glob("*.ok"), glob.glob("uniprot*.fasta.p*"),
                                    glob.glob("uniprot*fasta"), glob.glob("*loci*"),
                                    ["mikado.gtf", "mikado.fasta", "chr5.fas"],
                                    glob.glob("compare*"), glob.glob(config["db_settings"]["db"]),
                                    glob.glob("*.log"), glob.glob("*xml"), ["chr5.fas"]):
            if os.path.exists(filename):
                os.remove(filename)

rule clean_crumbs:
    run:
        for filename in itertools.chain(["finished.ok"], glob.glob("mikado*loci*"),
                                        glob.glob("compare*")):
            if os.path.exists(filename):
                os.remove(filename)

rule test_json:
    input: db=zipDBs, config=configname
    output: "{0}.ok".format(configname), "chr5.fas"
    run:
        __= mikado_lib.configuration.configurator.to_json(configname)
        subprocess.call("gunzip -k chr5.fas.gz", shell=True)
        shell("touch {output}")

rule prepare:
    input: "class.gtf", "cufflinks.gtf", "stringtie.gtf", "trinity.gtf", "mikado.bed", "chr5.fas"
    log: config["prepare"]["log"]
    output: "mikado_prepared.gtf", "mikado_prepared.fasta"
    shell: "mikado.py prepare --json-conf configuration.yaml"

#rule makeblast:
#    input: "{0}.gz".format(swissprot)
#    output: pog="{0}.pog".format(swissprot), fasta=swissprot
#    run:

rule blast_complete:
    params:	prefix="mikado"
    input: query="mikado_prepared.fasta", db="{0}.gz".format(swissprot), check="{0}.ok".format(configname)
    output: xml="mikado.blast.xml", db="uniprot_sprot_plants.fasta", pog="{0}.pog".format(swissprot)
    run:
        subprocess.call("gzip -dc {0} > {1}".format("{0}.gz".format(swissprot), swissprot),
                        shell=True)
        subprocess.call("makeblastdb -in {0} -dbtype prot -parse_seqids".format(swissprot),
                        shell=True)
        subprocess.call(" ".join(["blastx", "-num_threads", "5",
         "-query", "mikado_prepared.fasta", "-outfmt", "5", "-db", "uniprot_sprot_plants.fasta", "-out",
         "mikado.blast.xml", "-evalue", "0.000000001", "-max_target_seqs", "10"]),
          shell=True)
        # command = ""
        # shell(command)

rule serialise:
    input:
        [value for (key, value) in config["serialise"]["files"].items() if key != "log"]
#        junctions="junctions.bed",  # Portcullis
#        fai="genome.fai", # Samtools faidx
#        transcripts="mikado_prepared.fasta", # Prepare
#        targets="uniprot_sprot_plants.fasta", # BLAST DB
#        xml="mikado.blast.xml", # BLAST
#        orfs="mikado.bed" # TransDecoder
    log: config["serialise"]["files"]["log"]
    output: "serialised.ok"  #, config["db_settings"]["db"]
    run:
        command = "mikado.py serialise --json-conf configuration.yaml --genome_fai genome.fai"
        retcode = subprocess.call(command, shell=True)
        if retcode == 0:
             subprocess.call("touch serialised.ok", shell=True)

rule pick:
    params: prefix="all"
    input: configuration=configname, gtf="mikado_prepared.gtf", check="serialised.ok"
    log: config["pick"]["files"]["log"]
    output: "mikado.loci.gff3", "mikado.subloci.gff3"
    shell: "mikado.py pick --json-conf configuration.yaml -lv DEBUG --preload"

rule compare:
    input: reference="reference.gff3", prediction="mikado.loci.gff3"
    output: "compare.stats", "compare.tmap", "compare.refmap", "compare.log"
    shell: """mikado.py compare -r {input[reference]} -p {input[prediction]} -o compare -l compare.log"""
    
rule compare_input:
    input: reference="reference.gff3", prediction="mikado_prepared.gtf"
    output: "compare_input.stats", "compare_input.tmap", "compare_input.refmap", "compare_input.log"
    shell: """mikado.py compare -r {input[reference]} -p {input[prediction]} -o compare_input -l compare_input.log"""

rule compare_subloci:
    input: reference="reference.gff3", prediction="mikado.subloci.gff3"
    output: "compare_subloci.stats", "compare_subloci.tmap", "compare_subloci.refmap", "compare_subloci.log"
    shell: """mikado.py compare -r {input[reference]} -p {input[prediction]} -o compare_subloci -l compare_subloci.log"""


rule complete:
    input: "compare.stats", "compare_subloci.stats", "compare_input.stats"
    output: "finished.ok"
    run:
        with open(output[0],"w") as out:
            pass