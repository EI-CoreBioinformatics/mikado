import os,sys
import glob
import itertools
import mikado_lib.configuration.configurator
import subprocess

swissprot = "uniprot_sprot_plants.fasta"
swissprot_noat = "uniprot_sprot_plants.not_at.fasta"

DBs=[swissprot]
zipDBs=["{0}.gz".format(db) for db in DBs]

configfile: "configuration.yaml"
configname = "configuration.yaml"
config = mikado_lib.configuration.configurator.to_json(configname)

rule clean:
    run:
        for filename in itertools.chain(glob.glob("*.ok"), glob.glob("uniprot*.fasta.p*"),
                                    glob.glob("uniprot*fasta"), glob.glob("*loci*"),
                                    ["mikado.gtf", "mikado.fasta", "chr5.fas"],
                                    glob.glob("compare*"), glob.glob(config["db_settings"]["db"]),
                                    glob.glob("*.log"), glob.glob("*xml"), ["chr5.fas"]):
            if os.path.exists(filename):
                os.remove(filename)

rule clean_crumbs:
    run:
        for filename in itertools.chain(["finished.ok"], glob.glob("all*loci*"),
                                        glob.glob("compare*")):
            if os.path.exists(filename):
                os.remove(filename)

rule test_json:
    input: db=zipDBs, config=configname
    output: "{0}.ok".format(configname), "chr5.fas"
    run:
        __= mikado_lib.configuration.configurator.to_json(configname)
        subprocess.call("gunzip -k chr5.fas.gz", shell=True)
        shell("touch {output}")

rule prepare:
    input: "class.gtf", "cufflinks.gtf", "stringtie.gtf", "trinity.gtf", "mikado.bed", "chr5.fas"
    output: "mikado.gtf", "mikado.fasta"
    shell: " mikado.py prepare -m 200 --out mikado.gtf --out_fasta mikado.fasta --fasta chr5.fas --labels cl,cuff,st,tr class.gtf cufflinks.gtf stringtie.gtf trinity.gtf"

#rule makeblast:
#    input: "{0}.gz".format(swissprot)
#    output: pog="{0}.pog".format(swissprot), fasta=swissprot
#    run:

rule blast_complete:
    params:	prefix="mikado"
    input: query="mikado.fasta", db="{0}.gz".format(swissprot), check="{0}.ok".format(configname)
    output: xml="mikado.blast.xml", db=swissprot, pog="{0}.pog".format(swissprot)
    run:
        subprocess.call("gzip -dc {0} > {1}".format("{0}.gz".format(swissprot), swissprot),
                        shell=True)
        subprocess.call("makeblastdb -in {0} -dbtype prot -parse_seqids".format(swissprot),
                        shell=True)
        command = "blastx -num_threads {config[blast][num_threads]} -query {input[query]} -outfmt 5 -db {output[db]} -out {output[xml]} -evalue 0.000001 -max_target_seqs 10"
#        print(command)
        shell(command)

rule serialise:
    input: junctions="junctions.bed", fai="genome.fai", transcripts="mikado.fasta", targets="uniprot_sprot_plants.fasta", xml="mikado.blast.xml", orfs="mikado.bed"
    output: "serialised.ok" #, config["db_settings"]["db"]
    run:
        command = """mikado.py serialise --force --genome_fai {fai} \
        --transcript_fasta {transcripts} \
        --target_seqs {targets} \
        --xml {xml} --junctions {junctions} --json-conf {config} \
        --orfs {orfs} --log serialise.log -lv {level}""".format(fai=input["fai"],
        transcripts=input["transcripts"],
        targets=input["targets"], xml=input["xml"], junctions=input["junctions"],
         orfs=input["orfs"], config="mikado_configuration.yaml",
         level=config["log_settings"]["log_level"])
        retcode = subprocess.call(command, shell=True)
        if retcode == 0:
            subprocess.call("touch serialised.ok", shell=True)

rule pick:
    params: prefix="all"
    input: configuration=configname, gtf="mikado.gtf", check="serialised.ok"
    output: "all.loci.gff3", "all.subloci.gff3"
    shell: """mikado.py pick --json_conf mikado_configuration.yaml \
	    --subloci_out all.subloci.gff3 --monoloci_out all.monoloci.gff3 --loci_out all.loci.gff3 {input[gtf]}"""

rule compare:
    input: reference="reference.gff3", prediction="all.loci.gff3"
    output: "compare.stats", "compare.tmap", "compare.refmap", "compare.log"
    shell: """mikado.py compare -r {input[reference]} -p {input[prediction]} -o compare -l compare.log"""
    
rule compare_input:
    input: reference="reference.gff3", prediction="mikado.gtf"
    output: "compare_input.stats", "compare_input.tmap", "compare_input.refmap", "compare_input.log"
    shell: """mikado.py compare -r {input[reference]} -p {input[prediction]} -o compare_input -l compare_input.log"""

rule compare_subloci:
    input: reference="reference.gff3", prediction="all.subloci.gff3"
    output: "compare_subloci.stats", "compare_subloci.tmap", "compare_subloci.refmap", "compare_subloci.log"
    shell: """mikado.py compare -r {input[reference]} -p {input[prediction]} -o compare_subloci -l compare_subloci.log"""


rule complete:
    input: "compare.stats", "compare_subloci.stats", "compare_input.stats"
    output: "finished.ok"
    run:
        with open(output[0],"w") as out:
            pass