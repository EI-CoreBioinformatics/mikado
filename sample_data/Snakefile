import os,sys
import glob
import itertools
import mikado_lib.json_utils
import subprocess

swissprot = "uniprot_sprot_plants.fasta"
swissprot_noat = "uniprot_sprot_plants.not_at.fasta"

DBs=[swissprot]
zipDBs=["{0}.gz".format(db) for db in DBs]

configfile: "configuration.yaml"
configname = "configuration.yaml"

rule clean:
    run:
        for filename in itertools.chain(glob.glob("*.ok"), glob.glob("uniprot*.fasta.p*"),
                                    glob.glob("uniprot*fasta"), glob.glob("*loci*"),
                                    glob.glob("compare*"), glob.glob(config["db"]),
                                    glob.glob("*.log"), glob.glob("*xml")):
            if os.path.exists(filename):
                os.remove(filename)

rule decompress:
    input:  zipDBs
    output: DBs
    shell: "gzip -dc {input} > {output}"

rule test_json:
    input: DBs, configname
    output: "{0}.ok".format(configname)
    run:
        __= mikado_lib.json_utils.to_json(configname)
        shell("touch {output}")

rule blast_complete:
    params:	prefix="all"
    input: query="all.fasta", db=config["blast"]["database"], check="{0}.ok".format(configname)
    output: "all.blast.xml"
    shell: "{config[blast][program]} -num_threads {config[blast][num_threads]} -query {input[query]} -outfmt 5 -db {config[blast][database]} -out {output}"

rule serialise:
    input: junctions="junctions.bed", fai="genome.fai", transcripts="all.fasta", targets="uniprot_sprot_plants.fasta", xml="all.blast.xml", orfs="all.bed"
    output: "serialised.ok", "data.db"
    run:
        command = """mikado.py serialise --genome_fai {fai} \
        --transcript_fasta {transcripts} \
        --target_seqs {targets} \
        --xml {xml} --junctions {junctions} -f --json-conf {config} \
        --orfs {orfs} --log serialise.log -lv DEBUG""".format(fai=input["fai"],
        transcripts=input["transcripts"],
        targets=input["targets"], xml=input["xml"], junctions=input["junctions"],
         orfs=input["orfs"], config=configname)
        retcode = subprocess.call(command, shell=True)
        if retcode == 0:
            subprocess.call("touch serialised.ok", shell=True)

rule pick:
    params: prefix="all"
    input: configuration=configname, gtf="all.gtf", fasta="all.fasta", orf="all.bed", check="serialised.ok"
    output: "all.loci.gff3", "all.loci.scores.tsv"
    shell: """mikado.py pick --source {params[prefix]} --json_conf {input[configuration]} \
	    --subloci_out all.subloci.gff3 --monoloci_out all.monoloci.gff3 --loci_out all.loci.gff3 {input[gtf]}"""  

rule compare:
    input: reference="reference.gff3", prediction="all.loci.gff3"
    output: "compare.stats", "compare.tmap", "compare.refmap", "compare.log"
    shell: """mikado.py compare -r {input[reference]} -p {input[prediction]} -o compare -l compare.log"""

rule complete:
    input: "compare.stats"
    output: "finished.ok"
    run:
        with open(output[0],"w") as out:
            pass