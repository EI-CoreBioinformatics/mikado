import os,sys
import mikado_lib.json_utils
import subprocess

swissprot = "uniprot_sprot_plants.fasta"
swissprot_noat = "uniprot_sprot_plants.not_at.fasta"

DBs=[swissprot]
zipDBs=["{0}.gz".format(db) for db in DBs]

configfile: "configuration.yaml"
configname = "configuration.yaml"

# rule clean:
#      run:
#         shell("rm -f ./data.db ./all.blast.xml ./*loci* ./*.fasta.n* ./*.fasta.p* {0} {1}".format(expand(DBs), "{0}.check".format(configname) ))
# 	# for f in filter(lamdba x: os.path.exists(x), DBs):
# 	#    shell("gzip -f {f};")

# rule mock:
#     params:	prefix="mock"
#     input: DBs, gff="mock.gff3"
#     output: "mock.loci.gff3", "mock.loci.scores.tsv"
#     shell: "run_pipeline.py --source {params.prefix} --json_conf configuration_mock.json --subloci_out {params.prefix}.subloci.gff3 --monoloci_out {params.prefix}.monoloci.gff3 --loci_out {output[0]} {input.gff}"

rule decompress:
    input:  zipDBs
    output: DBs
    shell: "gzip -dc {input} > {output}"

rule test_json:
    input: DBs, configname
    output: "{0}.check".format(configname)
    run:
        __= mikado_lib.json_utils.to_json(configname)
        shell("touch {output}")

rule blast_complete:
    params:	prefix="all"
    input: query="all.fasta", db=config["blast"]["database"], check="{0}.check".format(configname) 
    output: "all.blast.xml"
    shell: "{config[blast][program]} -num_threads {config[blast][num_threads]} -query {input[query]} -outfmt 5 -db {config[blast][database]} -out {output}"

rule junction_to_db:
    params: prefix="all"
    input: junctions="junctions.bed", fai="genome.fai"
    output: "junction_serialized.ok"
    run:
        import sys
        print(sys.version_info)
        mikado_lib.serializers.junction.JunctionSerializer("junctions.bed", json_conf=config, fai="genome.fai").serialize();
        subprocess.call("touch junction_serialized.ok", shell=True)

rule orf_to_db:
    params: prefix="all"
    input: orf="all.bed", fasta="all.fasta", check="junction_serialized.ok"
    output: "orf_serialized.ok"
    run:
        mikado_lib.serializers.orf.OrfSerializer("all.bed", json_conf=config, fasta_index="all.fasta").serialize();
        subprocess.call("touch orf_serialized.ok", shell=True)

rule blast_to_db:
    params: prefix="all"
    input: blast="all.blast.xml", check="orf_serialized.ok"
    output: "blast_serialized.ok"
    run:
        mikado_lib.serializers.blast_utils.XmlSerializer("all.blast.xml", discard_definition=False,
						       target_seqs=config["blast"]["database"],
							   json_conf = config,
						       max_target_seqs=config["blast"]["max_target_seqs"] ).serialize();
        subprocess.call("touch blast_serialized.ok", shell=True);

rule select:
    params: prefix="all"
    input: configuration=configname, gtf="all.gtf", fasta="all.fasta", orf="all.bed", check="blast_serialized.ok"
    output: "all.loci.gff3", "all.loci.scores.tsv"
    shell: """mikado.py pick --source {params[prefix]} --json_conf {input[configuration]} \
	    --subloci_out all.subloci.gff3 --monoloci_out all.monoloci.gff3 --loci_out all.loci.gff3 {input[gtf]}"""  

rule compare:
    input: reference="reference.gff3", prediction="all.loci.gff3"
    output: "compare.stats", "compare.tmap", "compare.refmap", "compare.log"
    shell: """mikado.py compare -r {input[reference]} -p {input[prediction]} -o compare -l compare.log"""

rule complete:
    input: "compare.stats"
    output: "finished.ok"
    run:
        with open(output[0],"w") as out:
            pass