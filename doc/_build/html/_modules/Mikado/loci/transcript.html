<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Mikado.loci.transcript &mdash; Mikado 19 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '19',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Mikado 19 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Mikado.loci.transcript</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines the RNA objects. It also defines Metric, a property alias.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># pylint: disable=too-many-lines</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">intern</span><span class="p">,</span> <span class="n">maxsize</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">intervaltree</span>
<span class="kn">from</span> <span class="nn">..utilities.log_utils</span> <span class="kn">import</span> <span class="n">create_null_logger</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.sql.expression</span> <span class="kn">import</span> <span class="n">desc</span><span class="p">,</span> <span class="n">asc</span>  <span class="c1"># SQLAlchemy imports</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">and_</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext</span> <span class="kn">import</span> <span class="n">baked</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">bindparam</span>
<span class="kn">from</span> <span class="nn">..exceptions</span> <span class="kn">import</span> <span class="n">ModificationError</span><span class="p">,</span> <span class="n">InvalidTranscript</span>
<span class="kn">from</span> <span class="nn">..serializers.blast_serializer</span> <span class="kn">import</span> <span class="n">Query</span><span class="p">,</span> <span class="n">Hit</span>
<span class="kn">from</span> <span class="nn">..serializers.orf</span> <span class="kn">import</span> <span class="n">Orf</span>
<span class="kn">from</span> <span class="nn">.clique_methods</span> <span class="kn">import</span> <span class="n">find_communities</span><span class="p">,</span> <span class="n">define_graph</span>
<span class="kn">from</span> <span class="nn">..parsers.GTF</span> <span class="kn">import</span> <span class="n">GtfLine</span>
<span class="kn">from</span> <span class="nn">..parsers.GFF</span> <span class="kn">import</span> <span class="n">GffLine</span>
<span class="kn">from</span> <span class="nn">.transcript_methods</span> <span class="kn">import</span> <span class="n">splitting</span><span class="p">,</span> <span class="n">retrieval</span>
<span class="kn">from</span> <span class="nn">.transcript_methods.printing</span> <span class="kn">import</span> <span class="n">create_lines_cds</span>
<span class="kn">from</span> <span class="nn">.transcript_methods.printing</span> <span class="kn">import</span> <span class="n">create_lines_no_cds</span><span class="p">,</span> <span class="n">create_lines_bed</span>
<span class="kn">from</span> <span class="nn">.transcript_methods.finalizing</span> <span class="kn">import</span> <span class="n">finalize</span>
<span class="kn">import</span> <span class="nn">functools</span>


<div class="viewcode-block" id="Metric"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Metric">[docs]</a><span class="k">class</span> <span class="nc">Metric</span><span class="p">(</span><span class="nb">property</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simple aliasing of property. All transcript metrics</span>
<span class="sd">    should use this alias, not &quot;property&quot;, as a decorator.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1"># noinspection PyPropertyAccess</span>
<span class="c1"># I do not care that there are too many attributes: this IS a massive class!</span>
<span class="c1"># pylint: disable=too-many-instance-attributes,too-many-public-methods</span>
<div class="viewcode-block" id="Transcript"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript">[docs]</a><span class="k">class</span> <span class="nc">Transcript</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class defines a transcript, down to its exon/CDS/UTR components.</span>
<span class="sd">    It is instantiated by a transcript GTF/GFF3 line.</span>
<span class="sd">    Key attributes:</span>

<span class="sd">    :param chrom: The chromosome of the transcript</span>
<span class="sd">    :type chrom: str</span>
<span class="sd">    :type source: str</span>
<span class="sd">    :param feature: mRNA if at least one CDS is defined, else use the one</span>
<span class="sd">    derived from input; default is &quot;transcript&quot;</span>
<span class="sd">    :type feature: str</span>
<span class="sd">    :param start: Start of the transcript. Checked against the exons.</span>
<span class="sd">    :type start: int</span>
<span class="sd">    :param end: End of the transcript. Checked against the exons.</span>
<span class="sd">    :type end: int</span>
<span class="sd">    :param score: The score assigned to the transcript. Modified inside Mikado.py.</span>
<span class="sd">    :type score: float</span>
<span class="sd">    :param strand: one of +,-,None</span>
<span class="sd">    :type strand: str</span>
<span class="sd">    :param id            the ID of the transcripts (or tid)</span>
<span class="sd">    :type id: str</span>
<span class="sd">    :param parent: The parent leaves of the transcript</span>
<span class="sd">    :type parent: list</span>
<span class="sd">    :param attributes: a dictionary with additional informations from the GFFline</span>
<span class="sd">    :type attributes: dict</span>

<span class="sd">    After all exons have been loaded into the instance (see &quot;addExon&quot;),</span>
<span class="sd">    the class must be finalized with the appropriate method.</span>
<span class="sd">    CDS locations can be uploaded from the external, using a dictionary of indexed BED12 entries.</span>
<span class="sd">    The database queries are baked at the *class* level in order to minimize overhead.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__name__</span> <span class="o">=</span> <span class="nb">intern</span><span class="p">(</span><span class="s2">&quot;transcript&quot;</span><span class="p">)</span>
    <span class="n">__logger</span> <span class="o">=</span> <span class="n">create_null_logger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

    <span class="c1"># Query baking to minimize overhead</span>
    <span class="n">bakery</span> <span class="o">=</span> <span class="n">baked</span><span class="o">.</span><span class="n">bakery</span><span class="p">()</span>
    <span class="n">query_baked</span> <span class="o">=</span> <span class="n">bakery</span><span class="p">(</span><span class="k">lambda</span> <span class="n">session</span><span class="p">:</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Query</span><span class="p">))</span>
    <span class="n">query_baked</span> <span class="o">+=</span> <span class="k">lambda</span> <span class="n">q</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Query</span><span class="o">.</span><span class="n">query_name</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;query_name&quot;</span><span class="p">))</span>

    <span class="n">blast_baked</span> <span class="o">=</span> <span class="n">bakery</span><span class="p">(</span><span class="k">lambda</span> <span class="n">session</span><span class="p">:</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Hit</span><span class="p">))</span>
    <span class="n">blast_baked</span> <span class="o">+=</span> <span class="k">lambda</span> <span class="n">q</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">and_</span><span class="p">(</span><span class="n">Hit</span><span class="o">.</span><span class="n">query</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;query&quot;</span><span class="p">),</span>
                                           <span class="n">Hit</span><span class="o">.</span><span class="n">evalue</span> <span class="o">&lt;=</span> <span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;evalue&quot;</span><span class="p">)),)</span>

    <span class="n">blast_baked</span> <span class="o">+=</span> <span class="k">lambda</span> <span class="n">q</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">asc</span><span class="p">(</span><span class="n">Hit</span><span class="o">.</span><span class="n">evalue</span><span class="p">))</span>
    <span class="c1"># blast_baked += lambda q: q.limit(bindparam(&quot;max_target_seqs&quot;))</span>

    <span class="n">orf_baked</span> <span class="o">=</span> <span class="n">bakery</span><span class="p">(</span><span class="k">lambda</span> <span class="n">session</span><span class="p">:</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Orf</span><span class="p">))</span>
    <span class="n">orf_baked</span> <span class="o">+=</span> <span class="k">lambda</span> <span class="n">q</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">Orf</span><span class="o">.</span><span class="n">query</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;query&quot;</span><span class="p">))</span>
    <span class="n">orf_baked</span> <span class="o">+=</span> <span class="k">lambda</span> <span class="n">q</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">Orf</span><span class="o">.</span><span class="n">cds_len</span> <span class="o">&gt;=</span> <span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;cds_len&quot;</span><span class="p">))</span>
    <span class="n">orf_baked</span> <span class="o">+=</span> <span class="k">lambda</span> <span class="n">q</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">desc</span><span class="p">(</span><span class="n">Orf</span><span class="o">.</span><span class="n">cds_len</span><span class="p">))</span>

    <span class="c1"># ######## Class special methods ####################</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                 <span class="n">source</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">logger</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">intron_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">)):</span>

        <span class="sd">&quot;&quot;&quot;Initialise the transcript object, using a mRNA/transcript line.</span>
<span class="sd">        Note: I am assuming that the input line is an object from my own &quot;GFF&quot; class.</span>
<span class="sd">        The transcript instance must be initialised by a &quot;(m|r|lnc|whatever)RNA&quot; or</span>
<span class="sd">        &quot;transcript&quot; GffLine.</span>

<span class="sd">        :param intron_range: range of valid intron size. Any intron shorter</span>
<span class="sd">        or longer than this will be flagged.</span>
<span class="sd">        :type intron_range: list(int,int)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Mock setting of base hidden variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__id</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__strand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__score</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__has_start_codon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_stop_codon</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_internal_orf_index</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_internal_orf_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__intron_fraction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__exon_fraction</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Metrics might have queer names</span>
        <span class="c1"># pylint: disable=invalid-name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__proportion_verified_introns_inlocus</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__retained_fraction</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__combined_cds_intron_fraction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__selected_cds_intron_fraction</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__non_overlapping_cds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__exons</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__combined_cds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__selected_cds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cdna_length</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_combined_cds_introns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selected_cds_introns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__combined_utr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># pylint: enable=invalid-name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selected_internal_orf_cds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># This is used to set the phase if the CDS is loaded from the GFF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__phases</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># will contain (start, phase) for each CDS exon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__blast_score</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Homology score</span>

        <span class="c1"># Starting settings for everything else</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature</span> <span class="o">=</span> <span class="s2">&quot;transcript&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_utr</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">introns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">splices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># Flag. We do not want to repeat the finalising more than once.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf_index</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_overlapping_cds</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verified_introns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intron_range</span> <span class="o">=</span> <span class="n">intron_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blast_hits</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Relative properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retained_introns</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retained_fraction</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exon_fraction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intron_fraction</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cds_intron_fraction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_intron_fraction</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Json configuration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__json_conf</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># Things that will be populated by querying the database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded_bed12</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessionmaker</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="c1"># Initialisation of the CDS segments used for finding retained introns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cds_tree</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c1"># self.query_id = None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__initialize_with_line</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feature</span> <span class="o">=</span> <span class="nb">intern</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__initialize_with_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transcript_row</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method to copy the necessary attributes from</span>
<span class="sd">        an external GTF/GFF3 row.</span>
<span class="sd">        :param transcript_row:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transcript_row</span><span class="p">,</span> <span class="p">(</span><span class="n">GffLine</span><span class="p">,</span> <span class="n">GtfLine</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid data type: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">transcript_row</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">transcript_row</span><span class="o">.</span><span class="n">is_transcript</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid transcript line, the feature should be a transcript:</span><span class="se">\n</span><span class="s2">{0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">transcript_row</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="nb">intern</span><span class="p">(</span><span class="n">transcript_row</span><span class="o">.</span><span class="n">chrom</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature</span> <span class="o">=</span> <span class="nb">intern</span><span class="p">(</span><span class="n">transcript_row</span><span class="o">.</span><span class="n">feature</span><span class="p">)</span>
        <span class="c1"># pylint: disable=invalid-name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">transcript_row</span><span class="o">.</span><span class="n">id</span>
        <span class="c1"># pylint: enable=invalid-name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">transcript_row</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="nb">intern</span><span class="p">(</span><span class="n">transcript_row</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">transcript_row</span><span class="o">.</span><span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">=</span> <span class="n">transcript_row</span><span class="o">.</span><span class="n">strand</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">transcript_row</span><span class="o">.</span><span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">transcript_row</span><span class="o">.</span><span class="n">score</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scores</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">transcript_row</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">transcript_row</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="nb">intern</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blast_hits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">json_conf</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_gtf</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">print_cds</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type to_gtf: bool</span>
<span class="sd">        :type print_cds: bool</span>

<span class="sd">        Each transcript will be printed out in the GFF style.</span>
<span class="sd">        This is pretty rudimentary, as the class does not hold</span>
<span class="sd">        any information on the original source,</span>
<span class="sd">        feature, score, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>  <span class="c1"># Necessary to sort the exons</span>
        <span class="k">if</span> <span class="n">print_cds</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">create_lines_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_gtf</span><span class="o">=</span><span class="n">to_gtf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">create_lines_no_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_gtf</span><span class="o">=</span><span class="n">to_gtf</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param other: another transcript instance to compare to</span>
<span class="sd">        :type other: mikado_lib.loci_objects.transcript.Transcript</span>

<span class="sd">        Two transcripts are considered identical if they have the same</span>
<span class="sd">        start, end, chromosome, strand and internal exons.</span>
<span class="sd">        IDs are not important for this comparison; two transcripts coming from different</span>
<span class="sd">        methods and having different IDs can still be identical.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
        <span class="n">other</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">strand</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">chrom</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">start</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">exons</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the hash of the object (call to super().__hash__()).</span>
<span class="sd">        Necessary to be able to add these objects to hashes like sets.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__hash__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the length occupied by the unspliced transcript on the genome.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;A transcript is lesser than another if it is on a lexicographic inferior chromosome,</span>
<span class="sd">        or if it begins before the other, or (in the case where they begin at the same location)</span>
<span class="sd">        it ends earlier than the other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">chrom</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">chrom</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">start</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">&lt;</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span> <span class="o">&gt;</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">logger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>

        <span class="c1"># if hasattr(self, &quot;json_conf&quot;) and self.json_conf is not None:</span>
        <span class="c1">#     if &quot;requirements&quot; in self.json_conf and &quot;compiled&quot; in self.json_conf[&quot;requirements&quot;]:</span>
        <span class="c1">#         del state[&quot;json_conf&quot;][&quot;requirements&quot;][&quot;compiled&quot;]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;session&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;session&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">state</span><span class="p">[</span><span class="s2">&quot;session&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">expunge_all</span><span class="p">()</span>
                <span class="n">state</span><span class="p">[</span><span class="s2">&quot;session&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;session&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;sessionmaker&quot;</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;sessionmaker&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;engine&quot;</span><span class="p">]</span>

        <span class="c1"># if &quot;blast_baked&quot; in state:</span>
        <span class="c1">#     del state[&quot;blast_baked&quot;]</span>
        <span class="c1">#     del state[&quot;query_baked&quot;]</span>

        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="c1"># Set the logger to NullHandler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># ######## Class instance methods ####################</span>

<div class="viewcode-block" id="Transcript.add_exon"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.add_exon">[docs]</a>    <span class="k">def</span> <span class="nf">add_exon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gffline</span><span class="p">,</span> <span class="n">feature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function will append an exon/CDS feature to the object.</span>
<span class="sd">        :param gffline: an annotation line</span>
<span class="sd">        :type gffline: Mikado.py.parsers.GFF.GffLine, Mikado.py.parsers.GTF.GtfLine</span>
<span class="sd">        :type feature: flag to indicate what kind of feature we are adding</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gffline</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">gffline</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">gffline</span><span class="p">)</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">feature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">feature</span> <span class="o">=</span> <span class="s2">&quot;exon&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gffline</span><span class="p">,</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">gffline</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gffline</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">feature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">feature</span> <span class="o">=</span> <span class="s2">&quot;exon&quot;</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gffline</span><span class="p">,</span> <span class="p">(</span><span class="n">GtfLine</span><span class="p">,</span> <span class="n">GffLine</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">InvalidTranscript</span><span class="p">(</span><span class="s2">&quot;Unkwown feature type! </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                    <span class="nb">type</span><span class="p">(</span><span class="n">gffline</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">gffline</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">gffline</span><span class="o">.</span><span class="n">end</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">feature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">feature</span> <span class="o">=</span> <span class="n">gffline</span><span class="o">.</span><span class="n">feature</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gffline</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidTranscript</span><span class="p">(</span>
                    <span class="sd">&quot;&quot;&quot;Mismatch between transcript and exon:</span>
<span class="sd">                    {0}</span>
<span class="sd">                    {1}</span>
<span class="sd">                    {2}&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">gffline</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">gffline</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">gffline</span><span class="o">.</span><span class="n">is_exon</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">gffline</span><span class="p">)</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">gffline</span><span class="o">.</span><span class="n">phase</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationError</span><span class="p">(</span><span class="s2">&quot;You cannot add exons to a finalized transcript!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">feature</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;CDS&quot;</span><span class="p">):</span>
            <span class="n">store</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span>
            <span class="k">if</span> <span class="n">phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)]</span> <span class="o">=</span> <span class="n">phase</span>

        <span class="k">elif</span> <span class="s2">&quot;combined_utr&quot;</span> <span class="ow">in</span> <span class="n">feature</span> <span class="ow">or</span> <span class="s2">&quot;UTR&quot;</span> <span class="ow">in</span> <span class="n">feature</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
            <span class="n">store</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_utr</span>
        <span class="k">elif</span> <span class="n">feature</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;exon&quot;</span><span class="p">):</span>
            <span class="n">store</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span>
        <span class="k">elif</span> <span class="n">feature</span> <span class="o">==</span> <span class="s2">&quot;start_codon&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_start_codon</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">feature</span> <span class="o">==</span> <span class="s2">&quot;stop_codon&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_stop_codon</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">feature</span> <span class="o">==</span> <span class="s2">&quot;intron&quot;</span><span class="p">:</span>
            <span class="n">store</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">introns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidTranscript</span><span class="p">(</span><span class="s2">&quot;Unknown feature: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gffline</span><span class="o">.</span><span class="n">feature</span><span class="p">))</span>

        <span class="n">segment</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">])</span>
        <span class="c1"># assert isinstance(segment[0], int) and isinstance(segment[1], int)</span>
        <span class="n">store</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transcript.add_exons"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.add_exons">[docs]</a>    <span class="k">def</span> <span class="nf">add_exons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exons</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper of the add_exon method for multiple lines.</span>
<span class="sd">        :param exons: An iterable of G(tf|ff)lines to iterate, or of tuples of values.</span>
<span class="sd">        :param features: Optional array with the feature types</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">exons</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="n">features</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">exons</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exons</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">InvalidTranscript</span><span class="p">(</span><span class="s2">&quot;Mismatch between exons and features! </span><span class="si">%s</span><span class="s2">,</span><span class="se">\t</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                        <span class="n">exons</span><span class="p">,</span>
                                        <span class="n">features</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">exon</span><span class="p">,</span> <span class="n">feature</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">exons</span><span class="p">,</span> <span class="n">features</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_exon</span><span class="p">(</span><span class="n">exon</span><span class="p">,</span> <span class="n">feature</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Transcript.format"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.format">[docs]</a>    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_name</span><span class="p">,</span> <span class="n">with_introns</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">with_cds</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to format the string representation of the object. Available formats:</span>
<span class="sd">        - GFF3 (&quot;gff3&quot;, &quot;gff&quot;)</span>
<span class="sd">        - GTF (&quot;gtf&quot;)</span>
<span class="sd">        - BED12 (&quot;bed&quot;, &quot;bed12&quot;)</span>
<span class="sd">        :param format_name: the name of the format to use</span>
<span class="sd">        :param with_introns: if True, introns will be printed as well.</span>
<span class="sd">        :type with_introns: bool</span>
<span class="sd">        :param with_cds: if set to False, CDS lines will be omitted from the output</span>
<span class="sd">        :type with_cds: bool</span>
<span class="sd">        :return: the formatted string</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">format_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;gff&quot;</span><span class="p">,</span> <span class="s2">&quot;gtf&quot;</span><span class="p">,</span> <span class="s2">&quot;gff3&quot;</span><span class="p">,</span> <span class="s2">&quot;bed&quot;</span><span class="p">,</span> <span class="s2">&quot;bed12&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid format: {0}. Accepted formats: gff/gff3 (equivalent), gtf&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">format_name</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>  <span class="c1"># Necessary to sort the exons</span>
        <span class="k">if</span> <span class="n">format_name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;bed&quot;</span><span class="p">,</span> <span class="s2">&quot;bed12&quot;</span><span class="p">):</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">create_lines_bed</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_gtf</span> <span class="o">=</span> <span class="p">(</span><span class="n">format_name</span> <span class="o">==</span> <span class="s2">&quot;gtf&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">with_cds</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">create_lines_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_gtf</span><span class="o">=</span><span class="n">to_gtf</span><span class="p">,</span> <span class="n">with_introns</span><span class="o">=</span><span class="n">with_introns</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">create_lines_no_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_gtf</span><span class="o">=</span><span class="n">to_gtf</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transcript.split_by_cds"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.split_by_cds">[docs]</a>    <span class="k">def</span> <span class="nf">split_by_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method is used for transcripts that have multiple ORFs.</span>
<span class="sd">        It will split them according to the CDS information into multiple transcripts.</span>
<span class="sd">        UTR information will be retained only if no ORF is down/upstream.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">new_transcript</span> <span class="ow">in</span> <span class="n">splitting</span><span class="o">.</span><span class="n">split_by_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">new_transcript</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Transcript.remove_exon"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.remove_exon">[docs]</a>    <span class="k">def</span> <span class="nf">remove_exon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exon</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to remove an exon properly from a Transcript instance.</span>
<span class="sd">        :param exon: remove an exon from a Transcript.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot remove a segment from a finalised transcript!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">exon</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">):</span>
            <span class="n">exon</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">exon</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">exon</span><span class="o">.</span><span class="n">end</span><span class="p">])</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exon</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">exon</span> <span class="o">=</span> <span class="p">([</span><span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">exon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">exon</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="s2">&quot;exon&quot;</span><span class="p">,</span> <span class="n">exon</span><span class="p">))</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">exon</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">exon</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">_</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transcript.remove_exons"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.remove_exons">[docs]</a>    <span class="k">def</span> <span class="nf">remove_exons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exons</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper to automate the removal of exons.</span>
<span class="sd">        :param exons:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="n">exons</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_exon</span><span class="p">(</span><span class="n">exon</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transcript.remove_utrs"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.remove_utrs">[docs]</a>    <span class="k">def</span> <span class="nf">remove_utrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to strip a transcript from its UTRs.</span>
<span class="sd">        It will not execute anything if the transcript lacks a CDS or</span>
<span class="sd">        it has more than one ORF defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No CDS&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">three_utr_length</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">five_utr_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No UTR&quot;</span><span class="p">)</span>
            <span class="k">return</span>  <span class="c1"># No UTR to strip</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_internal_orfs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">r&quot;\.orf[0-9]+$&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Multiple ORFs already&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">cds_start</span><span class="p">,</span> <span class="n">cds_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cds_start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cds_end</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">exons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">cds_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">cds_end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_utr</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Need to recalculate it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cdna_length</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_utr</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">three_utr</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">five_utr</span> <span class="o">==</span> <span class="p">[],</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">combined_utr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">three_utr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">five_utr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transcript.strip_cds"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.strip_cds">[docs]</a>    <span class="k">def</span> <span class="nf">strip_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strand_specific</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to completely remove CDS information from a transcript.</span>
<span class="sd">        Necessary for those cases where the input is malformed.</span>

<span class="sd">        :param strand_specific: boolean flag. If set to False and the transcript is monoexonic,</span>
<span class="sd">        the strand will be removed from it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Stripping CDS from {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">monoexonic</span> <span class="ow">is</span> <span class="bp">True</span> <span class="ow">and</span> <span class="n">strand_specific</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_combined_cds_introns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selected_cds_introns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf_index</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">combined_utr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span></div>

<div class="viewcode-block" id="Transcript.copy"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to return a shallow copy of the current instance.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transcript.deepcopy"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to return a deep copy of the current instance.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transcript.finalize"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.finalize">[docs]</a>    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to calculate the internal introns from the exons.</span>
<span class="sd">        In the first step, it will sort the exons by their internal coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Transcript.unfinalize"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.unfinalize">[docs]</a>    <span class="k">def</span> <span class="nf">unfinalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">combined_utr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="o">=</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="Transcript.reverse_strand"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.reverse_strand">[docs]</a>    <span class="k">def</span> <span class="nf">reverse_strand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to reverse the strand&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Transcript.load_information_from_db"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.load_information_from_db">[docs]</a>    <span class="k">def</span> <span class="nf">load_information_from_db</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_conf</span><span class="p">,</span> <span class="n">introns</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">session</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                 <span class="n">data_dict</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method will invoke the check for:</span>

<span class="sd">        :param json_conf: Necessary configuration file</span>
<span class="sd">        :type json_conf: dict</span>

<span class="sd">        :param introns: the verified introns in the Locus</span>
<span class="sd">        :type introns: None,set</span>

<span class="sd">        :param session: an SQLAlchemy session</span>
<span class="sd">        :type session: sqlalchemy.orm.session</span>

<span class="sd">        :param data_dict: a dictionary containing the information directly</span>
<span class="sd">        :type data_dict: dict</span>

<span class="sd">        Verified introns can be provided from outside using the keyword.</span>
<span class="sd">        Otherwise, they will be extracted from the database directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">retrieval</span><span class="o">.</span><span class="n">load_information_from_db</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                           <span class="n">json_conf</span><span class="p">,</span>
                                           <span class="n">introns</span><span class="o">=</span><span class="n">introns</span><span class="p">,</span>
                                           <span class="n">session</span><span class="o">=</span><span class="n">session</span><span class="p">,</span>
                                           <span class="n">data_dict</span><span class="o">=</span><span class="n">data_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transcript.load_orfs"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.load_orfs">[docs]</a>    <span class="k">def</span> <span class="nf">load_orfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidate_orfs</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Thin layer over the load_orfs method from the retrieval module.</span>
<span class="sd">        :param candidate_orfs: list of candidate ORFs in BED12 format.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">retrieval</span><span class="o">.</span><span class="n">load_orfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidate_orfs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transcript.find_overlapping_cds"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.find_overlapping_cds">[docs]</a>    <span class="k">def</span> <span class="nf">find_overlapping_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidate_orfs</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Thin wrapper for the homonym function in retrieval</span>
<span class="sd">        :param candidate_orfs: List of candidate ORFs</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">retrieval</span><span class="o">.</span><span class="n">find_overlapping_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidate_orfs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transcript.as_dict"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.as_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to transform the transcript object into a JSON-friendly representation.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">state</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">,</span> <span class="s2">&quot;strand&quot;</span><span class="p">,</span> <span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="s2">&quot;attributes&quot;</span><span class="p">]:</span>
            <span class="n">state</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exons&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">:</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exons&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;orfs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;selected_orf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf_index</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">orf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">):</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;orfs&quot;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">orf</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CDS&quot;</span><span class="p">:</span>
                    <span class="n">to_store</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                             <span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
                                <span class="n">segment</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">to_store</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                             <span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]]</span>

                <span class="n">state</span><span class="p">[</span><span class="s2">&quot;orfs&quot;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_store</span><span class="p">)</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;parent&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">)</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state</span></div>

<div class="viewcode-block" id="Transcript.load_dict"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.load_dict">[docs]</a>    <span class="k">def</span> <span class="nf">load_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">,</span> <span class="s2">&quot;strand&quot;</span><span class="p">,</span> <span class="s2">&quot;score&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">state</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">intern</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">state</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="nb">intern</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">exons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exons&quot;</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">exon</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">exon</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">orf</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;orfs&quot;</span><span class="p">][</span><span class="n">_</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;orfs&quot;</span><span class="p">])):</span>
            <span class="n">neworf</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">orf</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CDS&quot;</span><span class="p">:</span>
                    <span class="n">new_segment</span> <span class="o">=</span> <span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="nb">tuple</span><span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                   <span class="nb">int</span><span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_segment</span> <span class="o">=</span> <span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="nb">tuple</span><span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">neworf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_segment</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neworf</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf_index</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;selected_orf&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;{0}</span><span class="se">\n</span><span class="s2">{1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span></div>

    <span class="c1"># ###################Class methods#####################################</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Transcript.is_overlapping_cds"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.is_overlapping_cds">[docs]</a>    <span class="k">def</span> <span class="nf">is_overlapping_cds</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param first: first ORF to check for overlap</span>
<span class="sd">        :param second: second ORF to check for overlap</span>
<span class="sd">        :rtype bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">first</span> <span class="o">==</span> <span class="n">second</span> <span class="ow">or</span> <span class="n">cls</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span>
                <span class="p">(</span><span class="n">first</span><span class="o">.</span><span class="n">thick_start</span><span class="p">,</span> <span class="n">first</span><span class="o">.</span><span class="n">thick_end</span><span class="p">),</span>
                <span class="p">(</span><span class="n">second</span><span class="o">.</span><span class="n">thick_start</span><span class="p">,</span> <span class="n">second</span><span class="o">.</span><span class="n">thick_end</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Transcript.is_intersecting"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.is_intersecting">[docs]</a>    <span class="k">def</span> <span class="nf">is_intersecting</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param first: first exon to check</span>
<span class="sd">        :type first: tuple([int, int])</span>

<span class="sd">        :param second: second exon to check</span>
<span class="sd">        :type second: tuple([int, int])</span>

<span class="sd">        :rtype bool</span>

<span class="sd">        Implementation of the is_intersecting method.</span>
<span class="sd">        It checks overlaps between exons.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">first</span> <span class="o">==</span> <span class="n">second</span> <span class="ow">or</span> <span class="n">cls</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Transcript.overlap"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.overlap">[docs]</a>    <span class="k">def</span> <span class="nf">overlap</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param first: first exon to check</span>
<span class="sd">        :type first: tuple([int, int])</span>

<span class="sd">        :param second: second exon to check</span>
<span class="sd">        :type second: tuple([int, int])</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        This method checks the overlap between two int duplexes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lend</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">first</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">second</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">rend</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">first</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">second</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">rend</span> <span class="o">-</span> <span class="n">lend</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Transcript.find_communities"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.find_communities">[docs]</a>    <span class="k">def</span> <span class="nf">find_communities</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">objects</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param objects: a list of objects to analyse</span>
<span class="sd">        :type objects: list,set</span>

<span class="sd">        Wrapper for the clique_methods functions.</span>
<span class="sd">        As we are interested only in the communities, not the cliques,</span>
<span class="sd">        this wrapper discards the cliques</span>
<span class="sd">        (first element of the Abstractlocus.find_communities results)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">obj</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">)</span>
        <span class="n">communities</span> <span class="o">=</span> <span class="n">find_communities</span><span class="p">(</span><span class="n">define_graph</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">inters</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">is_intersecting</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">communities</span></div>

    <span class="nd">@classmethod</span>
    <span class="nd">@functools.lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">typed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<div class="viewcode-block" id="Transcript.get_available_metrics"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.get_available_metrics">[docs]</a>    <span class="k">def</span> <span class="nf">get_available_metrics</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;This function retrieves all metrics available for the class.&quot;&quot;&quot;</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">member</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span> <span class="k">if</span>
                   <span class="s2">&quot;__&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">member</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">member</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">Metric</span><span class="p">)]</span>

        <span class="c1"># metrics = list(x[0] for x in filter(</span>
        <span class="c1">#     lambda y: &quot;__&quot; not in y[0] and isinstance(cls.__dict__[y[0]], Metric),</span>
        <span class="c1">#     inspect.getmembers(cls)))</span>
        <span class="k">assert</span> <span class="s2">&quot;tid&quot;</span> <span class="ow">in</span> <span class="n">metrics</span> <span class="ow">and</span> <span class="s2">&quot;parent&quot;</span> <span class="ow">in</span> <span class="n">metrics</span> <span class="ow">and</span> <span class="s2">&quot;score&quot;</span> <span class="ow">in</span> <span class="n">metrics</span>
        <span class="n">_metrics</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">metric</span> <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metrics</span> <span class="k">if</span>
                           <span class="n">metric</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;tid&quot;</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="s2">&quot;score&quot;</span><span class="p">]])</span>
        <span class="n">final_metrics</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tid&quot;</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="s2">&quot;score&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">_metrics</span>
        <span class="k">return</span> <span class="n">final_metrics</span></div>

    <span class="c1"># ###################Class properties##################################</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property. It returns the logger instance attached to the class.</span>
<span class="sd">        :rtype : logging.Logger | None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span>

    <span class="nd">@logger.setter</span>
    <span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a logger for the instance.</span>
<span class="sd">        :param logger: a Logger instance</span>
<span class="sd">        :type logger: logging.Logger | None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">logger</span> <span class="o">=</span> <span class="n">create_null_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span> <span class="o">=</span> <span class="n">logger</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span> <span class="o">=</span> <span class="n">logger</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">json_conf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configuration dictionary. It can be None.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__json_conf</span>

    <span class="nd">@json_conf.setter</span>
    <span class="k">def</span> <span class="nf">json_conf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_conf</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for the configuration dictionary.</span>
<span class="sd">        :param json_conf: None or a dictionary</span>
<span class="sd">        :type json_conf: (None | dict)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json_conf</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="n">json_conf</span> <span class="ow">is</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__json_conf</span> <span class="o">=</span> <span class="n">json_conf</span>

    <span class="nd">@logger.deleter</span>
    <span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Destroyer for the logger. It sets the internal __logger attribute to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">phases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This property contains the first phase gleaned for each internal ORF from the</span>
<span class="sd">         GFF.</span>
<span class="sd">        :return: __phases, a list</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__phases</span>

    <span class="nd">@phases.setter</span>
    <span class="k">def</span> <span class="nf">phases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phases</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for phases. The input must be a list.</span>
<span class="sd">        :param phases:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">phases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__phases</span> <span class="o">=</span> <span class="n">phases</span>

    <span class="c1"># This will be id, no changes.</span>
    <span class="c1"># pylint: disable=invalid-name</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ID of the transcript - cannot be an undefined value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__id</span>

    <span class="nd">@id.setter</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param newid: a string which will become the ID of the instance.</span>
<span class="sd">        :type newid: str</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newid</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid value for id: {0}, type {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">newid</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">newid</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__id</span> <span class="o">=</span> <span class="nb">intern</span><span class="p">(</span><span class="n">newid</span><span class="p">)</span>
    <span class="c1"># pylint: enable=invalid-name</span>

    <span class="nd">@property</span>
    <span class="nd">@functools.lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">typed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">available_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the list of available metrics, using the &quot;get_metrics&quot; function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_available_metrics</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">if</span> <span class="s2">&quot;Name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">_</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span>

    <span class="nd">@name.setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid name: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">intern</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">strand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Strand of the transcript. One of None, &quot;-&quot;, &quot;+&quot;</span>

<span class="sd">        :rtype str | None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__strand</span>

    <span class="nd">@strand.setter</span>
    <span class="k">def</span> <span class="nf">strand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strand</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param strand</span>
<span class="sd">        :type strand: None | str</span>

<span class="sd">        Setter for the strand of the transcript. It must be one of None, &quot;-&quot;, &quot;+&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strand</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__strand</span> <span class="o">=</span> <span class="n">strand</span>
        <span class="k">elif</span> <span class="n">strand</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__strand</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid value for strand: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">strand</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">selected_internal_orf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property will return the tuple of tuples of the ORF selected as &quot;best&quot;.</span>
<span class="sd">        To avoid memory wasting, the tuple is accessed in real-time using</span>
<span class="sd">        a token (__max_internal_orf_index) which holds the position in the</span>
<span class="sd">        __internal_cds list of the longest CDS.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Non-sense to calculate the maximum CDS for transcripts without it</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__max_internal_orf_length</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf_index</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf_index</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">selected_internal_orf_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property will return the tuple of tuples of the CDS segments of</span>
<span class="sd">        the selected ORF inside the transcript. To avoid memory wasting,</span>
<span class="sd">        the tuple is accessed in real-time using a token</span>
<span class="sd">        (__max_internal_orf_index) which holds the position</span>
<span class="sd">        in the __internal_cds list of the longest CDS.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Non-sense to calculate the maximum CDS for transcripts without it</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected_internal_orf_cds</span>

    <span class="nd">@selected_internal_orf_cds.setter</span>
    <span class="k">def</span> <span class="nf">selected_internal_orf_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal_orf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for selected_internal_orf_cds</span>
<span class="sd">        :param internal_orf:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">internal_orf</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid internal ORF type ({0}): {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">internal_orf</span><span class="p">),</span>
                <span class="n">internal_orf</span>
            <span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_selected_internal_orf_cds</span> <span class="o">=</span> <span class="n">internal_orf</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">five_utr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the exons in the 5&#39; UTR of the selected ORF.</span>
<span class="sd">        If the start codon is absent, no UTR is given.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">utr_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">utr_segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf</span> <span class="k">if</span>
                        <span class="n">utr_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;UTR&quot;</span> <span class="ow">and</span> <span class="n">utr_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_start</span><span class="p">)</span>
            <span class="c1">#</span>
            <span class="c1">#</span>
            <span class="c1"># return list(</span>
            <span class="c1">#     filter(lambda exon: exon[0] == &quot;UTR&quot; and exon[1][0] &gt; self.selected_cds_start,</span>
            <span class="c1">#            self.selected_internal_orf))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">utr_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">utr_segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf</span> <span class="k">if</span>
                        <span class="n">utr_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;UTR&quot;</span> <span class="ow">and</span> <span class="n">utr_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_start</span><span class="p">)</span>
            <span class="c1">#</span>
            <span class="c1">#</span>
            <span class="c1"># return list(</span>
            <span class="c1">#     filter(lambda exon: exon[0] == &quot;UTR&quot; and exon[1][1] &lt; self.selected_cds_start,</span>
            <span class="c1">#            self.selected_internal_orf))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">three_utr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the exons in the 3&#39; UTR of the selected ORF.</span>
<span class="sd">        If the end codon is absent, no UTR is given.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">utr_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">utr_segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf</span> <span class="k">if</span>
                        <span class="n">utr_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;UTR&quot;</span> <span class="ow">and</span> <span class="n">utr_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span><span class="p">)</span>
            <span class="c1"># filter(lambda exon: exon[0] == &quot;UTR&quot; and exon[1][1] &lt; self.selected_cds_end,</span>
            <span class="c1">#        self.selected_internal_orf))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">utr_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">utr_segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf</span> <span class="k">if</span>
                        <span class="n">utr_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;UTR&quot;</span> <span class="ow">and</span> <span class="n">utr_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span><span class="p">)</span>
            <span class="c1">#</span>
            <span class="c1">#</span>
            <span class="c1"># return list(</span>
            <span class="c1">#     filter(lambda exon: exon[0] == &quot;UTR&quot; and exon[1][0] &gt; self.selected_cds_end,</span>
            <span class="c1">#            self.selected_internal_orf))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">selected_internal_orf_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Token which memorizes the position in the ORF list of the selected ORF.</span>
<span class="sd">        :rtype : None | int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_internal_orf_index</span>

    <span class="nd">@selected_internal_orf_index.setter</span>
    <span class="k">def</span> <span class="nf">selected_internal_orf_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter for selected_internal_orf_index.</span>
<span class="sd">        :param index:</span>
<span class="sd">        :type index: None,int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__max_internal_orf_index</span> <span class="o">=</span> <span class="n">index</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;No ORF corresponding to this index: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_internal_orf_index</span> <span class="o">=</span> <span class="n">index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">internal_orf_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns a list of the lengths of the internal ORFs.</span>
<span class="sd">        :rtype : list[int]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">internal_cds</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">internal_cds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">),</span> <span class="n">internal_cds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">internal_cds</span> <span class="k">if</span>
                         <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CDS&quot;</span><span class="p">)</span>
            <span class="n">lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">lengths</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lengths</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">non_overlapping_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns a set containing the set union of all CDS segments</span>
<span class="sd">        inside the internal CDSs. In the case of a transcript with no CDS, this is empty.</span>
<span class="sd">        In the case where there is only one CDS, this returns the combined_cds holder.</span>
<span class="sd">        In the case instead where there are multiple CDSs, the property will calculate</span>
<span class="sd">        the set union of all CDS segments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__non_overlapping_cds</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__non_overlapping_cds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">internal_cds</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">:</span>
                <span class="n">segments</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">internal_cds</span> <span class="k">if</span>
                                <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CDS&quot;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__non_overlapping_cds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__non_overlapping_cds</span>

    <span class="nd">@non_overlapping_cds.setter</span>
    <span class="k">def</span> <span class="nf">non_overlapping_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param arg: the unioin of all non-overlapping CDS segments.</span>
<span class="sd">        :type arg: set</span>
<span class="sd">        Setter for the non_overlapping_cds property.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__non_overlapping_cds</span> <span class="o">=</span> <span class="n">arg</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property stores the exons of the transcript as (start,end) tuples.</span>

<span class="sd">        :rtype : list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__exons</span>

    <span class="nd">@exons.setter</span>
    <span class="k">def</span> <span class="nf">exons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param args: a list/set of exons</span>
<span class="sd">        :type args: set | list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__exons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">combined_cds_introns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the introns which are located between CDS</span>
<span class="sd">        segments in the combined CDS.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combined_cds_introns</span>

        <span class="c1"># if self.number_internal_orfs &lt; 2:</span>
        <span class="c1">#     return self.selected_cds_introns</span>
        <span class="c1"># if self.number_internal_orfs == 0 or len(self.combined_cds) &lt; 2:</span>
        <span class="c1">#     return set()</span>
        <span class="c1">#</span>
        <span class="c1"># cintrons = []</span>
        <span class="c1"># for position in range(len(self.combined_cds) - 1):</span>
        <span class="c1">#     former = self.combined_cds[position]</span>
        <span class="c1">#     latter = self.combined_cds[position + 1]</span>
        <span class="c1">#     junc = intervaltree.Interval(former[1] + 1, latter[0] - 1)</span>
        <span class="c1">#     if junc in self.introns:</span>
        <span class="c1">#         cintrons.append(junc)</span>
        <span class="c1"># cintrons = set(cintrons)</span>
        <span class="c1"># return cintrons</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">selected_cds_introns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the introns which are located between</span>
<span class="sd">        CDS segments in the selected ORF.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected_cds_introns</span>

        <span class="c1"># if len(self.selected_cds) &lt; 2:</span>
        <span class="c1">#     return set()</span>
        <span class="c1"># if self.number_internal_orfs == 0 or len(self.combined_cds) &lt; 2:</span>
        <span class="c1">#     return set()</span>
        <span class="c1">#</span>
        <span class="c1"># cintrons = []</span>
        <span class="c1"># for first, second in zip(self.selected_cds[:-1], self.selected_cds[1:]):</span>
        <span class="c1">#     cintrons.append(</span>
        <span class="c1">#         intervaltree.Interval(first[1] + 1,</span>
        <span class="c1">#                               second[0] - 1)</span>
        <span class="c1">#     )</span>
        <span class="c1"># cintrons = set(cintrons)</span>
        <span class="c1"># assert len(cintrons) &gt; 0</span>
        <span class="c1"># return cintrons</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">combined_cds_start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the location of the start of the combined</span>
<span class="sd">        CDS for the transcript. If no CDS is defined, it defaults</span>
<span class="sd">        to the transcript start.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">combined_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is a list which contains all the non-overlapping CDS</span>
<span class="sd">        segments inside the cDNA. The list comprises the segments</span>
<span class="sd">        as duples (start,end).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__combined_cds</span>

    <span class="nd">@combined_cds.setter</span>
    <span class="k">def</span> <span class="nf">combined_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">combined</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for combined_cds. It performs some basic checks,</span>
<span class="sd">        e.g. that all the members of the list are integer duplexes.</span>

<span class="sd">        :param combined: list</span>
<span class="sd">        :type combined: list[(int,int)]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">combined</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">or</span>
                <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__wrong_combined_entry</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span> <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">combined</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid value for combined CDS: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">combined</span><span class="p">))</span>

        <span class="c1"># if len(combined) &gt; 0:</span>
        <span class="c1">#     if isinstance(combined[0], tuple):</span>
        <span class="c1">#         try:</span>
        <span class="c1">#             combined = [intervaltree.Interval(_[0], _[1]) for _ in combined]</span>
        <span class="c1">#         except IndexError:</span>
        <span class="c1">#             raise IndexError(combined)</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         assert isinstance(combined[0], intervaltree.Interval)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__combined_cds</span> <span class="o">=</span> <span class="n">combined</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__wrong_combined_entry</span><span class="p">(</span><span class="n">to_test</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method to test the correctness of entries for &quot;combined&quot;</span>
<span class="sd">        data</span>
<span class="sd">        :param to_test:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_test</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_test</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">to_test</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">to_test</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">combined_utr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is a list which contains all the non-overlapping UTR</span>
<span class="sd">        segments inside the cDNA.</span>
<span class="sd">        The list comprises the segments as duples (start,end).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__combined_utr</span>

    <span class="nd">@combined_utr.setter</span>
    <span class="k">def</span> <span class="nf">combined_utr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">combined</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter for combined UTR. It performs some basic checks,</span>
<span class="sd">        e.g. that all the members of the list</span>
<span class="sd">        are integer duplexes.</span>

<span class="sd">        :param combined: UTR list</span>
<span class="sd">        :type combined: list[(int,int)]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">combined</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid value for combined UTR: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">combined</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__wrong_combined_entry</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span> <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">combined</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid value for combined UTR: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">combined</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__combined_utr</span> <span class="o">=</span> <span class="n">combined</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">combined_cds_end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the location of the end of the combined CDS</span>
<span class="sd">        for the transcript. If no CDS is defined, it defaults</span>
<span class="sd">        to the transcript end.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">selected_cds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property return the CDS exons of the ORF selected as best</span>
<span class="sd">         inside the cDNA, in the form of duplices (start, end)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__selected_cds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__selected_cds</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf</span> <span class="k">if</span>
                                   <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CDS&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__selected_cds</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">selected_cds_start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the location of the start</span>
<span class="sd">        of the best CDS for the transcript.</span>
<span class="sd">        If no CDS is defined, it defaults to the transcript start.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">selected_cds_end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the location of the end</span>
<span class="sd">        of the best CDS for the transcript.</span>
<span class="sd">        If no CDS is defined, it defaults to the transcript start.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span>
                    <span class="s2">&quot;{0}, selected CDS: {1}, combined CDS: {2}, </span><span class="se">\</span>
<span class="s2">index {3}, internal ORFs: {4}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">exc</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf_index</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">))</span>
                <span class="k">raise</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">monoexonic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property. True if the transcript has only one exon, False otherwise.</span>
<span class="sd">        :rtype bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_coding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simple property to investigate whether a transcript is coding or not</span>
<span class="sd">        :return: boolean value</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cds_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This property returns an interval tree of the CDS segments.</span>
<span class="sd">        Used to calculate the non-coding parts of the CDS.</span>
<span class="sd">        :rtype: intervaltree.Intervaltree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cds_tree</span>

    <span class="nd">@cds_tree.setter</span>
    <span class="k">def</span> <span class="nf">cds_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for CDS tree. It checks that the calculated tree is actually valid.</span>
<span class="sd">        :param segments: the interval tree to be set.</span>
<span class="sd">        :type segments: intervaltree.Intervaltree</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">segments</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid cds segments: </span><span class="si">%s</span><span class="s2">, type </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="n">segments</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">segments</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__cds_tree</span> <span class="o">=</span> <span class="n">segments</span>

    <span class="c1"># ################### Class metrics ##################################</span>

    <span class="c1"># Disable normal checks on names and hidden methods, as</span>
    <span class="c1"># checkers get confused by the Metric method</span>
    <span class="c1"># pylint: disable=method-hidden,invalid-name</span>
    <span class="nd">@Metric</span>
    <span class="k">def</span> <span class="nf">tid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ID of the transcript - cannot be an undefined value. Alias of id.</span>
<span class="sd">        :rtype str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>

    <span class="nd">@tid.setter</span>
<div class="viewcode-block" id="Transcript.tid"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.tid">[docs]</a>    <span class="k">def</span> <span class="nf">tid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param tid: ID of the transcript.</span>
<span class="sd">        :type tid: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">tid</span></div>

    <span class="nd">@Metric</span>
    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Name of the parent feature of the transcript.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span>

    <span class="nd">@parent.setter</span>
<div class="viewcode-block" id="Transcript.parent"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.parent">[docs]</a>    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param parent: the parent of the transcript.</span>
<span class="sd">        :type parent: list</span>
<span class="sd">        :type parent: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">None</span><span class="p">))):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;,&quot;</span> <span class="ow">in</span> <span class="n">parent</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">parent</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid value for parent: {0}, type {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">parent</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">parent</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="p">[</span><span class="nb">intern</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span><span class="p">]</span></div>

    <span class="nd">@Metric</span>
    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Numerical value which summarizes the reliability of the transcript.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__score</span>

    <span class="nd">@score.setter</span>
<div class="viewcode-block" id="Transcript.score"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">score</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Setter for the numerical value which summarizes the reliability</span>
<span class="sd">        of the transcript.</span>
<span class="sd">        :param score: the new score of the transcript</span>
<span class="sd">        :type score: None</span>
<span class="sd">        :type score: int</span>
<span class="sd">        :type score: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">score</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">score</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Invalid value for score: {0}, type {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">score</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__score</span> <span class="o">=</span> <span class="n">score</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.combined_cds_length"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.combined_cds_length">[docs]</a>    <span class="k">def</span> <span class="nf">combined_cds_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property return the length of the CDS part of the transcript.&quot;&quot;&quot;</span>
        <span class="n">c_length</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">c_length</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">c_length</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.combined_cds_num"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.combined_cds_num">[docs]</a>    <span class="k">def</span> <span class="nf">combined_cds_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the number of non-overlapping CDS segments</span>
<span class="sd">        in the transcript.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.combined_cds_num_fraction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.combined_cds_num_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">combined_cds_num_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the fraction of non-overlapping CDS segments</span>
<span class="sd">        in the transcript</span>
<span class="sd">        vs. the total number of exons&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.combined_cds_fraction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.combined_cds_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">combined_cds_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property return the percentage of the CDS part of the transcript</span>
<span class="sd">        vs. the cDNA length&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_length</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdna_length</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.combined_utr_length"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.combined_utr_length">[docs]</a>    <span class="k">def</span> <span class="nf">combined_utr_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property return the length of the UTR part of the transcript.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_utr</span><span class="p">])</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.combined_utr_fraction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.combined_utr_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">combined_utr_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the fraction of the cDNA which is not coding according</span>
<span class="sd">        to any ORF. Complement of combined_cds_fraction&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_fraction</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.cdna_length"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.cdna_length">[docs]</a>    <span class="k">def</span> <span class="nf">cdna_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the length of the transcript.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cdna_length</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__cdna_length</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cdna_length</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.number_internal_orfs"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.number_internal_orfs">[docs]</a>    <span class="k">def</span> <span class="nf">number_internal_orfs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the number of ORFs inside a transcript.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.selected_cds_length"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.selected_cds_length">[docs]</a>    <span class="k">def</span> <span class="nf">selected_cds_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property calculates the length of the CDS selected as best inside</span>
<span class="sd">        the cDNA.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__max_internal_orf_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__max_internal_orf_length</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CDS&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_internal_orf_length</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.selected_cds_num"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.selected_cds_num">[docs]</a>    <span class="k">def</span> <span class="nf">selected_cds_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property calculates the number of CDS exons for the selected ORF&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf</span> <span class="k">if</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CDS&quot;</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.selected_cds_fraction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.selected_cds_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">selected_cds_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property calculates the fraction of the selected CDS vs. the cDNA length.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_length</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdna_length</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.highest_cds_exons_num"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.highest_cds_exons_num">[docs]</a>    <span class="k">def</span> <span class="nf">highest_cds_exons_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of CDS segments in the selected ORF</span>
<span class="sd">        (irrespective of the number of exons involved)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_internal_orf</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CDS&quot;</span><span class="p">)</span></div>
        <span class="c1"># return len(list(filter(lambda x: x[0] == &quot;CDS&quot;, self.selected_internal_orf)))</span>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.selected_cds_exons_fraction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.selected_cds_exons_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">selected_cds_exons_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the fraction of CDS segments in the selected ORF</span>
<span class="sd">        (irrespective of the number of exons involved)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">highest_cds_exon_number</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">)</span></div>

        <span class="c1"># return len(list(filter(lambda x: x[0] == &quot;CDS&quot;,</span>
        <span class="c1">#                        self.selected_internal_orf))) / len(self.exons)</span>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.highest_cds_exon_number"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.highest_cds_exon_number">[docs]</a>    <span class="k">def</span> <span class="nf">highest_cds_exon_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the maximum number of CDS segments</span>
<span class="sd">        among the ORFs; this number can refer to an ORF *DIFFERENT*</span>
<span class="sd">        from the maximal ORF.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">cds_numbers</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cds</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">:</span>
            <span class="n">cds_numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">cds</span> <span class="k">if</span> <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CDS&quot;</span><span class="p">))</span>
            <span class="c1"># len(list(filter(lambda x: x[0] == &quot;CDS&quot;, cds))))</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">cds_numbers</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.selected_cds_number_fraction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.selected_cds_number_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">selected_cds_number_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the proportion of best possible CDS segments</span>
<span class="sd">        vs. the number of exons. See selected_cds_number.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_num</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exon_num</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.cds_not_maximal"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.cds_not_maximal">[docs]</a>    <span class="k">def</span> <span class="nf">cds_not_maximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the length of the CDS excluded from the selected ORF.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_length</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_length</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.cds_not_maximal_fraction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.cds_not_maximal_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">cds_not_maximal_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the fraction of bases not in the selected ORF compared to</span>
<span class="sd">        the total number of CDS bases in the cDNA.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cds_not_maximal</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_length</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.five_utr_length"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.five_utr_length">[docs]</a>    <span class="k">def</span> <span class="nf">five_utr_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the length of the 5&#39; UTR of the selected ORF.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">utr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">utr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">utr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">five_utr</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.five_utr_num"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.five_utr_num">[docs]</a>    <span class="k">def</span> <span class="nf">five_utr_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the number of 5&#39; UTR segments for the selected ORF.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">five_utr</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.five_utr_num_complete"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.five_utr_num_complete">[docs]</a>    <span class="k">def</span> <span class="nf">five_utr_num_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the number of 5&#39; UTR segments for the selected ORF,</span>
<span class="sd">        considering only those which are complete exons.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">utr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">five_utr</span> <span class="k">if</span> <span class="n">utr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.three_utr_length"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.three_utr_length">[docs]</a>    <span class="k">def</span> <span class="nf">three_utr_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the length of the 5&#39; UTR of the selected ORF.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">three_utr</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.three_utr_num"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.three_utr_num">[docs]</a>    <span class="k">def</span> <span class="nf">three_utr_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the number of 3&#39; UTR segments</span>
<span class="sd">        (referred to the selected ORF).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">three_utr</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.three_utr_num_complete"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.three_utr_num_complete">[docs]</a>    <span class="k">def</span> <span class="nf">three_utr_num_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the number of 3&#39; UTR segments for the selected ORF,</span>
<span class="sd">        considering only those which are complete exons.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">utr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">three_utr</span> <span class="k">if</span> <span class="n">utr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.utr_num"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.utr_num">[docs]</a>    <span class="k">def</span> <span class="nf">utr_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of UTR segments (referred to the selected ORF).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">three_utr</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">five_utr</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.utr_num_complete"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.utr_num_complete">[docs]</a>    <span class="k">def</span> <span class="nf">utr_num_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of UTR segments which are</span>
<span class="sd">        complete exons (referred to the selected ORF).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">three_utr_num_complete</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">five_utr_num_complete</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.utr_fraction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.utr_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">utr_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property calculates the length of the UTR</span>
<span class="sd">        of the selected ORF vs. the cDNA length.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_fraction</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.utr_length"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.utr_length">[docs]</a>    <span class="k">def</span> <span class="nf">utr_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the sum of the 5&#39;+3&#39; UTR lengths&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">three_utr_length</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">five_utr_length</span></div>

    <span class="nd">@Metric</span>
    <span class="k">def</span> <span class="nf">has_start_codon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True if the selected ORF has a start codon.</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_start_codon</span>

    <span class="nd">@has_start_codon.setter</span>
<div class="viewcode-block" id="Transcript.has_start_codon"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.has_start_codon">[docs]</a>    <span class="k">def</span> <span class="nf">has_start_codon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter. Checks that the argument is boolean.</span>
<span class="sd">        :param value: boolean flag</span>
<span class="sd">        :type value: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid value for has_start_codon: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__has_start_codon</span> <span class="o">=</span> <span class="n">value</span></div>

    <span class="nd">@Metric</span>
    <span class="k">def</span> <span class="nf">has_stop_codon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True if the selected ORF has a stop codon.</span>
<span class="sd">        :rtype bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_stop_codon</span>

    <span class="nd">@has_stop_codon.setter</span>
<div class="viewcode-block" id="Transcript.has_stop_codon"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.has_stop_codon">[docs]</a>    <span class="k">def</span> <span class="nf">has_stop_codon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter. Checks that the argument is boolean.</span>
<span class="sd">        :param value: list</span>
<span class="sd">        :type value: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid value for has_stop_codon: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__has_stop_codon</span> <span class="o">=</span> <span class="n">value</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.is_complete"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.is_complete">[docs]</a>    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True if the selected ORF has both start and end.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__has_start_codon</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__has_stop_codon</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.exon_num"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.exon_num">[docs]</a>    <span class="k">def</span> <span class="nf">exon_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the number of exons of the transcript.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
    <span class="k">def</span> <span class="nf">exon_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the fraction of exons of the transcript</span>
<span class="sd">        which are contained in the sublocus.</span>
<span class="sd">        If the transcript is by itself, it returns 1. Set from outside.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__exon_fraction</span>

    <span class="nd">@exon_fraction.setter</span>
<div class="viewcode-block" id="Transcript.exon_fraction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.exon_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">exon_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter for exon_fraction. Set from the Locus-type classes.</span>
<span class="sd">        :param args: list of values, only the first is retained</span>
<span class="sd">        :type args: list(float) | float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid value for the fraction: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__exon_fraction</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="nd">@Metric</span>
    <span class="k">def</span> <span class="nf">intron_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the fraction of introns of the transcript</span>
<span class="sd">        vs. the total number of introns in the Locus.</span>
<span class="sd">        If the transcript is by itself, it returns 1. Set from outside.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__intron_fraction</span>

    <span class="nd">@intron_fraction.setter</span>
<div class="viewcode-block" id="Transcript.intron_fraction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.intron_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">intron_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter for intron_fraction. Set from the Locus-type classes.</span>
<span class="sd">        :param args: list of values, only the first is retained</span>
<span class="sd">        :type args: list(float) | float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid value for the fraction: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">monoexonic</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sd">&quot;&quot;&quot;It is impossible that the intron fraction is null</span>
<span class="sd">                when the transcript has at least one intron!&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__intron_fraction</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.max_intron_length"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.max_intron_length">[docs]</a>    <span class="k">def</span> <span class="nf">max_intron_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the greatest intron length for the transcript.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">introns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">intron</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">intron</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">intron</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">introns</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.min_intron_length"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.min_intron_length">[docs]</a>    <span class="k">def</span> <span class="nf">min_intron_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">introns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">intron</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">intron</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">intron</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">introns</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.start_distance_from_tss"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.start_distance_from_tss">[docs]</a>    <span class="k">def</span> <span class="nf">start_distance_from_tss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the distance of the start of the combined CDS</span>
<span class="sd">        from the transcript start site.</span>
<span class="sd">        If no CDS is defined, it defaults to 0.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_start_distance_from_tss</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">:</span>
                <span class="n">distance</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_start</span> <span class="o">&lt;=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">break</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="n">exons</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">[:]))</span>
            <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="n">exons</span><span class="p">:</span>
                <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_start</span> <span class="o">&gt;=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">distance</span></div>

    <span class="c1"># pylint: disable=invalid-name</span>
    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.selected_start_distance_from_tss"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.selected_start_distance_from_tss">[docs]</a>    <span class="k">def</span> <span class="nf">selected_start_distance_from_tss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the distance of the start of the best CDS</span>
<span class="sd">        from the transcript start site.</span>
<span class="sd">        If no CDS is defined, it defaults to 0.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined_cds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">:</span>
                <span class="n">distance</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_start</span> <span class="o">&lt;=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">break</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="n">exons</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exons</span><span class="p">[:]))</span>
            <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="n">exons</span><span class="p">:</span>
                <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_start</span> <span class="o">&gt;=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">distance</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.selected_end_distance_from_tes"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.selected_end_distance_from_tes">[docs]</a>    <span class="k">def</span> <span class="nf">selected_end_distance_from_tes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the distance of the end of the best CDS</span>
<span class="sd">        from the transcript end site.</span>
<span class="sd">        If no CDS is defined, it defaults to 0.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_coding</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
            <span class="c1"># Case 1: the stop is after the latest junction</span>
            <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span>
                                <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span> <span class="o">&lt;=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span>
                                <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span> <span class="o">&lt;=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">distance</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Exclude end</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">distance</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.selected_end_distance_from_junction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.selected_end_distance_from_junction">[docs]</a>    <span class="k">def</span> <span class="nf">selected_end_distance_from_junction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This metric returns the distance between the stop codon and the</span>
<span class="sd">        nearest downstream junction. In many eukaryotes, this distance</span>
<span class="sd">        cannot exceed 50-55 bps, otherwise the transcript becomes a target of NMD.</span>
<span class="sd">        If the transcript is not coding or there is no junction downstream of</span>
<span class="sd">        the stop codon, the metric returns 0.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">monoexonic</span> <span class="ow">is</span> <span class="bp">True</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_coding</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
            <span class="c1"># Case 1: the stop is after the latest junction</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splices</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span>
                                    <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span><span class="p">])[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span> <span class="o">&lt;=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span>  <span class="c1"># Exclude end</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splices</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span>
                                    <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span> <span class="o">&lt;=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">distance</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_cds_end</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Exclude end</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">distance</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.end_distance_from_junction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.end_distance_from_junction">[docs]</a>    <span class="k">def</span> <span class="nf">end_distance_from_junction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This metric returns the cDNA distance between the stop codon and</span>
<span class="sd">        the last junction in the transcript.</span>
<span class="sd">        In many eukaryotes, this distance cannot exceed 50-55 bps</span>
<span class="sd">        otherwise the transcript becomes a target of NMD.</span>
<span class="sd">        If the transcript is not coding or there is no junction downstream</span>
<span class="sd">        of the stop codon, the metric returns 0.</span>
<span class="sd">        This metric considers the combined CDS end.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">monoexonic</span> <span class="ow">is</span> <span class="bp">True</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_coding</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
            <span class="c1"># Case 1: the stop is after the latest junction</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splices</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span>
                                    <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span><span class="p">])[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span> <span class="o">&lt;=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splices</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span>
                                    <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span> <span class="o">&lt;=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">distance</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Exclude end</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">distance</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.end_distance_from_tes"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.end_distance_from_tes">[docs]</a>    <span class="k">def</span> <span class="nf">end_distance_from_tes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the distance of the end of the combined CDS</span>
<span class="sd">        from the transcript end site.</span>
<span class="sd">        If no CDS is defined, it defaults to 0.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_coding</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
            <span class="c1"># Case 1: the stop is after the latest junction</span>
            <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span>
                                <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span> <span class="o">&lt;=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exons</span>
                                <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span> <span class="o">&lt;=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">distance</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_cds_end</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Exclude end</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">distance</span> <span class="o">+=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">distance</span></div>

    <span class="nd">@Metric</span>
    <span class="k">def</span> <span class="nf">combined_cds_intron_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the fraction of CDS introns of the transcript</span>
<span class="sd">        vs. the total number of CDS introns in the Locus.</span>
<span class="sd">        If the transcript is by itself, it returns 1.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__combined_cds_intron_fraction</span>

    <span class="nd">@combined_cds_intron_fraction.setter</span>
<div class="viewcode-block" id="Transcript.combined_cds_intron_fraction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.combined_cds_intron_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">combined_cds_intron_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the setter for combined_cds_intron_fraction. It checks that the value is</span>
<span class="sd">        a valid type, i.e. a float or integer between 0 and 1, before setting it.</span>
<span class="sd">        :param value</span>
<span class="sd">        :type value: int,float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid value for the fraction: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__combined_cds_intron_fraction</span> <span class="o">=</span> <span class="n">value</span></div>

    <span class="nd">@Metric</span>
    <span class="k">def</span> <span class="nf">selected_cds_intron_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the fraction of CDS introns of</span>
<span class="sd">        the selected ORF of the transcript vs. the total number</span>
<span class="sd">        of CDS introns in the Locus (considering only the selected ORF).</span>
<span class="sd">        If the transcript is by itself, it should return 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__selected_cds_intron_fraction</span>

    <span class="nd">@selected_cds_intron_fraction.setter</span>
<div class="viewcode-block" id="Transcript.selected_cds_intron_fraction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.selected_cds_intron_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">selected_cds_intron_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter for selected_cds_intron_fraction.</span>
<span class="sd">        :param args: either a single float/int or a list (only the first value is retained)</span>
<span class="sd">        :type args: list(int) | list(float)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid value for the fraction: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__selected_cds_intron_fraction</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.retained_intron_num"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.retained_intron_num">[docs]</a>    <span class="k">def</span> <span class="nf">retained_intron_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property records the number of introns in the transcripts</span>
<span class="sd">        which are marked as being retained.</span>
<span class="sd">        See the corresponding method in the sublocus class.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">retained_introns</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
    <span class="k">def</span> <span class="nf">retained_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property returns the fraction of the cDNA which</span>
<span class="sd">        is contained in retained introns.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__retained_fraction</span>

    <span class="nd">@retained_fraction.setter</span>
<div class="viewcode-block" id="Transcript.retained_fraction"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.retained_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">retained_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter for retained_intron_fraction.</span>
<span class="sd">        :param args: either a single float/int or a list (only the first value is retained)</span>
<span class="sd">        :type args: list(int) | list(float)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid value for the fraction: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__retained_fraction</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.proportion_verified_introns"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.proportion_verified_introns">[docs]</a>    <span class="k">def</span> <span class="nf">proportion_verified_introns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This metric returns, as a fraction, how many of the transcript introns</span>
<span class="sd">        are validated by external data.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">monoexonic</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verified_introns</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">introns</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.non_verified_introns_num"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.non_verified_introns_num">[docs]</a>    <span class="k">def</span> <span class="nf">non_verified_introns_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This metric returns the number of introns of the transcript which are not validated</span>
<span class="sd">        by external data.</span>
<span class="sd">        :rtype : int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">introns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verified_introns</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># This is a clear error</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Erroneous number of verified introns for </span><span class="si">%s</span><span class="s2">; total </span><span class="si">%d</span><span class="s2">, verified </span><span class="si">%d</span><span class="s2">, subtraction </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">introns</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verified_introns</span><span class="p">),</span> <span class="n">num</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Introns for </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">; verified: </span><span class="si">%s</span><span class="s2">. Resetting verified to 0.&quot;</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">introns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verified_introns</span><span class="p">)</span>
            <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">introns</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">num</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.verified_introns_num"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.verified_introns_num">[docs]</a>    <span class="k">def</span> <span class="nf">verified_introns_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This metric returns the number of introns of the transcript which are validated</span>
<span class="sd">        by external data.</span>
<span class="sd">        :rtype : int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verified_introns</span><span class="p">)</span></div>

    <span class="nd">@Metric</span>
    <span class="k">def</span> <span class="nf">proportion_verified_introns_inlocus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This metric returns, as a fraction, how many of the</span>
<span class="sd">        verified introns inside the Locus</span>
<span class="sd">        are contained inside the transcript.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__proportion_verified_introns_inlocus</span>

    <span class="nd">@proportion_verified_introns_inlocus.setter</span>
<div class="viewcode-block" id="Transcript.proportion_verified_introns_inlocus"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.proportion_verified_introns_inlocus">[docs]</a>    <span class="k">def</span> <span class="nf">proportion_verified_introns_inlocus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter for retained_intron_fraction.</span>
<span class="sd">        :param args: either a single float/int or a list</span>
<span class="sd">        (only the first value is retained)</span>
<span class="sd">        :type args: list(int) | list(float)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid value for the fraction: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verified_introns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__proportion_verified_introns_inlocus</span> <span class="o">=</span> <span class="n">value</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.num_introns_greater_than_max"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.num_introns_greater_than_max">[docs]</a>    <span class="k">def</span> <span class="nf">num_introns_greater_than_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This metric returns the number of introns greater</span>
<span class="sd">        than the maximum acceptable intron size</span>
<span class="sd">        indicated in the constructor.</span>
<span class="sd">        :rtype : int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">intron</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">introns</span> <span class="k">if</span>
                   <span class="n">intron</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">intron</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">intron_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>
        <span class="c1">#</span>
        <span class="c1"># return len(list(filter(lambda x: x[1]-x[0]+1 &gt; self.intron_range[1],</span>
        <span class="c1">#                        self.introns)))</span>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.num_introns_smaller_than_min"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.num_introns_smaller_than_min">[docs]</a>    <span class="k">def</span> <span class="nf">num_introns_smaller_than_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This metric returns the number of introns smaller</span>
<span class="sd">        than the mininum acceptable intron size</span>
<span class="sd">        indicated in the constructor.</span>
<span class="sd">        :rtype : int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">intron</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">introns</span> <span class="k">if</span>
                   <span class="n">intron</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">intron</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">intron_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

        <span class="c1">#</span>
        <span class="c1"># return len(list(filter(lambda x: x[1]-x[0]+1 &lt; self.intron_range[0],</span>
        <span class="c1">#                        self.introns)))</span>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.snowy_blast_score"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.snowy_blast_score">[docs]</a>    <span class="k">def</span> <span class="nf">snowy_blast_score</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Metric that indicates how good a hit is compared to the competition, in terms of BLAST</span>
<span class="sd">        similarities.</span>
<span class="sd">        As in SnowyOwl, the score for each hit is calculated by taking the percentage of positive</span>
<span class="sd">        matches and dividing it by (2 * len(self.blast_hits)).</span>
<span class="sd">        IMPORTANT: when splitting transcripts by ORF, a blast hit is added to the new transcript</span>
<span class="sd">        only if it is contained within the new transcript.</span>
<span class="sd">        This WILL screw up a bit the homology score.</span>
<span class="sd">        :return</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blast_hits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__blast_score</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__blast_score</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blast_hits</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blast_hits</span><span class="p">:</span>
                <span class="n">score</span> <span class="o">+=</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;global_positives&quot;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blast_hits</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__blast_score</span> <span class="o">=</span> <span class="n">score</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__blast_score</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.best_bits"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.best_bits">[docs]</a>    <span class="k">def</span> <span class="nf">best_bits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Metric that returns the best BitS associated with the transcript.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;bits&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blast_hits</span><span class="p">])</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.blast_score"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.blast_score">[docs]</a>    <span class="k">def</span> <span class="nf">blast_score</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interchangeable alias for testing different blast-related scores.</span>
<span class="sd">        Current: best bit score.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return self.snowy_blast_score</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_bits</span></div>

    <span class="nd">@Metric</span>
<div class="viewcode-block" id="Transcript.canonical_intron_proportion"><a class="viewcode-back" href="../../../Mikado.loci.html#Mikado.loci.transcript.Transcript.canonical_intron_proportion">[docs]</a>    <span class="k">def</span> <span class="nf">canonical_intron_proportion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This metric returns the proportion of canonical introns</span>
<span class="sd">         of the transcript on its total number of introns.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;canonical_proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Luca Venturini, Shabhonam Caim.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>