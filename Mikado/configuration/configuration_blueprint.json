{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "id": "configuration_blueprint",
  "type": "object",
  "description": "Configuration file for Mikado. Please note that absent values, e.g. if a field is deleted, will be imputed by the default values for the program..\nSections:",
  "properties": {
    "filename": {"type": "string", "description": "Name of the configuration file."},
    "threads": {
      "type": "integer",
      "default": 4,
      "description": "Threads to be used per process.",
      "minimum": 1
    },
    "seed": {
      "type": ["integer"],
      "description": "Integer seed for random number generation, to ensure reproducibilities across runs.",
      "default": 0
    },
    "multiprocessing_method": {
      "type": "string",
      "default": "spawn",
      "description": "Which method (fork, spawn, forkserver) Mikado should use for multiprocessing.",
      "enum": ["fork", "spawn", "forkserver", ""]
    },
    "log_settings": {
      "description": "Settings related to the verbosity of logs.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "log_level": {
          "type": "string",
          "description": "Verbosity for SQL calls. Default: WARNING. In decreasing order: 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'",
          "enum": [
            "DEBUG",
            "INFO",
            "WARNING",
            "ERROR",
            "CRITICAL"
          ],
          "default": "INFO"
        },
        "sql_level": {
          "description": "General verbosity. Default: INFO. In decreasing order: 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'",
          "type": "string",
          "enum": [
            "DEBUG",
            "INFO",
            "WARNING",
            "ERROR",
            "CRITICAL"
          ],
          "default": "WARNING"
        },
        "log": {
          "type": ["null", "string"], "default": ""
        }
      }
    },
    "db_settings": {
      "description": "Settings related to DB connection.",
      "required": [
        "dbtype",
        "db"
      ],
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "db": {
          "description": "the DB to connect to. Required. Default: mikado.db",
          "default": "mikado.db",
          "type": "string"
        },
        "dbtype": {
          "default": "sqlite",
          "description": "Type of DB to use. Choices: sqlite, postgresql, mysql. Default: sqlite.",
          "enum": [
            "mysql",
            "postgresql",
            "sqlite"
          ],
          "type": "string"
        },
        "dbhost": {
          "description": "Host of the database. Unused if dbtype is sqlite. Default: localhost",
          "format": "hostname",
          "default": "localhost"
        },
        "dbuser": {
          "description": "DB user. Unused if dbtype is sqlite. Default: empty string",
          "type": "string",
          "default": ""
        },
        "dbpasswd": {
          "description": "DB password for the user. Unused if dbtype is sqlite. Default: empty string.",
          "type": "string",
          "default": ""
        },
        "dbport": {
          "description": "Integer. It indicates the default port for the DB. Unused if dbtype is sqlite. Default: 0",
          "type": "integer",
          "default": 0
        }
      }
    },
    "serialise":{
      "type": "object",
      "additionalProperties": false,
      "description": "Options related to data serialisation.",
      "required": ["max_regression", "codon_table", "substitution_matrix"],
      "properties": {
        "files": {
          "description": "Options related to input files for serialise",
          "type": "object",
          "additionalProperties": false,
          "required": ["transcripts"],
          "properties": {
            "junctions": {
              "description": "File of reliable junctions (from e.g. Portcullis), in BED12 format",
              "type": "array",
              "default": [],
              "optional": false
            },
            "xml": {
              "type": "array",
              "description": "BLAST file or folder of files, in XML or tabular format, optionally compressed.",
              "default": []
            },
            "blast_loading_debug": {
              "description": "Boolean flag. If True, the loading of BLAST files will happen in a single thread and debugging mode will be activated.",
              "type": "boolean",
              "default": false
            },
            "external_scores": {
              "description": "File of additional scores related to the input transcripts. Please see the documentation.",
              "type": ["string", "null"],
              "default": ""
            },
            "orfs": {
              "description": "File(s) containing the ORF calling for the input transcripts, in GFF3 or BED12 *transcriptomic* (ie in cDNA rather than genomic) coordinates.",
              "type": "array",
              "default": []
            },
            "transcripts": {
              "description": "Input transcripts in FASTA format, ie the output of Mikado prepare.",
              "type": "string",
              "default": "mikado_prepared.fasta"
            },
            "log": {
              "description": "log file.",
              "type": "string",
              "default": "serialise.log"
            },
            "blast_targets": {
              "description": "FASTA file(s) with the BLAST targets.",
              "type": "array",
              "default": []
            },
            "output_dir": {
              "description": "Output folder for mikado serialise.",
              "type": "string",
              "default": "."}
          }
        },
        "substitution_matrix": {
          "description": "Substitution matrix used for the BLAST. This value will be derived from the XML files, but it must be provided here or on the command line when using BLAST tabular data. Default: blosum62, the default for both BLAST and DIAMOND.",
            "enum": ["blosum45", "blosum50", "blosum62", null,
            "blosum80", "blosum90", "pam250", "pam30", "pam70"],
            "default": "blosum62"
        },
        "blast_flavour": {
          "description": "Type of BLAST used. Either BLASTP or BLASTX. Default: blastx, which should be the sane presumption in most instances.",
          "enum":  ["blastx", "blastp"],
          "default": "blastx"
        },
        "max_objects": {"type": "integer", "default": 10000000, "minimum": 1,
        "description": "Maximum number of objects to keep in memory while loading data into the database. Linearly related to memory usage and inversely correlated with runtime."},
        "max_regression": {"type": "number",
          "description": "if the ORF lacks a valid start site, this percentage indicates how far along the sequence Mikado should look for a good start site. Eg. with a value of 0.1, on a 300bp sequence with an open ORF Mikado would look for an alternative in-frame start codon in the first 30 bps (10% of the cDNA).",
          "minimum": 0,
          "maximum": 1,
          "default": 0.2},
        "start_adjustment": {"type":  "boolean", "default": true,
          "description": "Boolean switch. If set to true (default), if an ORF is truncated at the 5' Mikado will look for internal start codons. See 'max_regression'."},
        "max_target_seqs": {"type": "integer", "default": 100000, "minimum": 1,
        "description": "Equivalently to BLAST, it indicates the maximum number of targets to keep per blasted sequence."},
        "force": {"type": "boolean", "default": false,
          "description": "Whether to drop and reload everything into the DB"},
        "single_thread": {"type": "boolean", "default": false},
        "codon_table": {
          "description": "codon table to use for verifying/modifying the ORFs. Default: 0, ie the universal codon table but enforcing ATG as the only valid start codon.",
              "enum": [0, 1, 2, 3, 4, 5, 6, 9, 10, 11, 12, 13, 14, 15, 16, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
            "Standard", "SGC0", "Vertebrate Mitochondrial", "SGC1", "Yeast Mitochondrial", "SGC2", "Mold Mitochondrial",
                  "Protozoan Mitochondrial", "Coelenterate Mitochondrial", "Mycoplasma", "Spiroplasma", "SGC3",
                  "Invertebrate Mitochondrial", "SGC4", "Ciliate Nuclear", "Dasycladacean Nuclear",
                  "Hexamita Nuclear", "SGC5", "Echinoderm Mitochondrial", "Flatworm Mitochondrial",
                  "SGC8", "Euplotid Nuclear", "SGC9", "Bacterial", "Archaeal", "Plant Plastid",
                  "Alternative Yeast Nuclear", "Ascidian Mitochondrial", "Alternative Flatworm Mitochondrial",
                  "Blepharisma Macronuclear", "Chlorophycean Mitochondrial", "Trematode Mitochondrial",
                  "Scenedesmus obliquus Mitochondrial", "Thraustochytrium Mitochondrial",
                  "Pterobranchia Mitochondrial", "Candidate Division SR1", "Gracilibacteria",
                  "Pachysolen tannophilus Nuclear", "Karyorelict Nuclear", "Condylostoma Nuclear",
                  "Mesodinium Nuclear", "Peritrich Nuclear", "Blastocrithidia Nuclear"],
          "default": 0
            }
      }
    },
    "prepare":{
      "type": "object",
      "additionalProperties": false,
      "description": "Options related to the input data preparation.",
      "required": ["files", "strand_specific", "minimum_cdna_length", "max_intron_length"],
      "properties":
      {
        "exclude_redundant": {
          "type": "boolean", "default": false,
          "description": "Boolean. If set to True, fully redundant transcripts across the input files will be removed. Higher scoring transcripts *on the basis of the score associated to a given input file* will be preferentially retained."
        },
        "minimum_cdna_length": {
          "type": "integer", "default": 200, "minimum": 1,
          "description": "Minimum length of a transcript to be retained. Default: 200 bps"
        },
        "max_intron_length": {
          "type": "integer", "default": 1000000, "minimum": 20,
          "description": "Maximum length of an intron. Transcripts with introns bigger than this value will be split in various sub-transcripts. Default: 1,000,000 bps."
        },
        "files": {
          "description": "Options related to the input and output files.",
          "type": "object",
          "additionalProperties": false,
          "required": ["out", "out_fasta", "gff"],
          "properties": {
            "output_dir": {"type": "string", "default": ".", "description": "Output folder."},
            "out": {"type": "string", "default": "mikado_prepared.gtf", "description": "Output GTF file."},
            "out_fasta": {"type": "string", "default": "mikado_prepared.fasta",
            "description": "Output FASTA file of the cDNAs retained."},
            "log": {"type": "string", "default": "prepare.log", "description": "Log file."},
            "gff": { "type": "array", "default": [],
              "description": "List of the input files."},
            "labels": {"type": "array", "default": [],
              "description": "List of labels associated with each input GFF. This list must *either* be empty *or* be the same length as the 'gff' content above."},
            "strand_specific_assemblies": {"type": "array", "default": [],
            "description": "List of input assemblies to be considered as strand specific. Any 'reference' input is automatically marked as strand-specific."},
            "reference": {"type": "array", "default": [],
              "description": "List of input assemblies to be considered as of 'reference' quality. Transcripts from this list will be excluded only if they have glaring mistakes eg. an incorrect CDS."},
            "exclude_redundant": {"type": "array", "default": [],
            "description": "If the 'exclude_redundant' switch is set to true, this list specifies which assemblies can have the redundancy check performed on."},
            "strip_cds": {"type": "array", "default": [],
            "description": "List of input assemblies from which the CDS will be stripped. Useful to e.g. remove the CDS from GMAP alignments."},
            "source_score":{
              "description": "Dictionary linking assemblies with an optional score, for prioritising them during 'pick' (or de-prioritising if the score is negative).",
              "type": "object",
              "default": {},
              "properties": {
                "source": {"type": "string"},
                "score": {"type": "number"}
          }
        }
          }
        },
        "strip_cds": {"type": "boolean", "default": false,
        "description": "Boolean flag. If set, the CDS will be stripped from any non-reference input assembly."},
        "strip_faulty_cds": {"type": "boolean", "default": false,
          "description": "Boolean flag. If set to false, any transcript - *including reference transcripts* found to have an incorrect CDS will be discarded. If set to to true, these transcripts will be retained but their CDS will be stripped."
        },
        "single": {"type": "boolean", "default": false,
        "description": "Boolean flag. If set to true, Mikado will run in single-threaded mode, useful for debugging."},
        "lenient": {"type": "boolean", "default": false,
        "description": "Boolean flag. If set to true, Mikado will retain transcripts with no canonical junction or with canonical junctions on both strands. If set to false (default), such transcripts will instead be discarded."},
        "strand_specific": {"type": "boolean", "default": false,
          "description": "Boolean flag. If set to true, all assemblies will be considered as strand-specific. By default, Mikado will consider the strand-specificity of each assembly in isolation, see 'files/strand_specific_assemblies'."},
        "canonical": {"type": "array", "default": [
            ["GT", "AG"],
            ["GC", "AG"],
            ["AT", "AC"]
        ], "description": "Accepted canonical splicing junctions for the organism in examination."}
      }
    },
    "pick": {
      "type": "object",
      "description": "Parameters related to the Mikado pick stage.",
      "additionalProperties": false,
      "required": ["scoring_file"],
      "properties": {
        "scoring_file": {
          "type": "string",
          "default": "plant.yaml",
          "description": "Scoring file to be used by Mikado."
          },
        "alternative_splicing": {
          "description": "Parameters related to how Mikado will select and report alternative splicing events.",
          "required": ["report", "only_confirmed_introns", "pad"],
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "report": {
              "type": "boolean",
              "default": true,
              "description": "Boolean flag, about whether Mikado should find and report AS events or simply define one transcript per locus."
            },
            "cds_only": {"type":  "boolean", "default": false,
            "description": "Only consider the coding part of transcripts to determine the validity of the AS event."},
            "min_cds_overlap": {
              "description": "Minimum CDS overlap threshold (for coding transcripts) to be cleared for two transcripts to be considered AS events of each other.",
              "type": "number",
              "minimum": 0,
              "maximum": 1,
              "default": 0.5
            },
            "min_cdna_overlap": {
              "description": "Minimum cDNA overlap threshold to be cleared for two transcripts to be considered AS events of each other.",
              "type": "number",
              "minimum": 0,
              "maximum": 1,
              "default": 0.6
            },
            "keep_retained_introns": {
              "description": "Keep or discard AS events with a retained intron. Default: true",
              "type": "boolean",
              "default": true
            },
            "keep_cds_disrupted_by_ri": {
              "description": "Keep or discard AS events with their CDS disrupted by a retained intron event, ie either having their stop codon or ending with a truncated CDS within the intron of another transcript. Default: false.",
              "type": "boolean",
              "default": false
            },
            "max_isoforms": {
              "description": "Maximum number of isoforms to report per locus. Default: 10.",
              "type": "integer",
              "minimum": 1,
              "default": 10
            },
            "valid_ccodes": {
              "description": "AS event class codes considered as valid AS events. Valid codes are in categories 'Alternative splicing', 'Extension' (with junction F1 lower than 100%), and 'Overlap' (exluding m). Please run 'mikado util class_codes' or refer to the online documentation for an explanation of each code.",
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "j",
                  "e",
                  "o",
                  "h",
                  "J",
                  "C",
                  "g",
                  "G",
                  "=",
                  "n",
                  "_"
                ]
              },
              "default": [
                "j",
                "J",
                "G",
                "h"
              ]
            },
            "redundant_ccodes": {
              "description": "AS event class codes considered as a duplicate of other transcripts in the locus. Please run 'mikado util class_codes' or refer to the online documentation for an explanation of each code.",
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "j",
                  "n",
                  "O",
                  "e",
                  "o",
                  "h",
                  "J",
                  "C",
                  "c",
                  "m",
                  "mo",
                  "=",
                  "_",
                  "x",
                  "p",
                  "P",
                  "X",
                  "I",
                  "i"
                ]
              },
              "default": [
                "c",
                "m",
                "_",
                "=",
                "n"
              ]
            },
            "min_score_perc": {
              "description": "Minimum percentage of the score associated to an AS event *compared to the primary transcript* for the AS event to be considered valid. Default: 0.5, or 50%.",
              "type": "number",
              "default": 0.5,
              "minimum": 0,
              "maximum": 1
            },
            "only_confirmed_introns":{
              "description": "Boolean flag. If set to true (default), Mikado will only report AS events whose introns *not in common with the primary transcript* are verified by the junctions provided to serialise (usually Portcullis reliable junctions).",
              "type": "boolean",
              "default": true
            },
            "ts_distance": {
              "description": "When padding, this value indicates how many bps can be added to *either* of the 5' or 3' section of the transcript, excluding introns.",
              "type": "integer",
              "default": 2000,
              "minimum": 0
            },
            "pad": {
              "description": "Boolean flag. If set to true, Mikado will pad transcripts. Please refer to the online documentation.",
              "type": "boolean",
              "default": true
            },
            "ts_max_splices": {
              "description": "When padding, this value indicates the maximum number of splicing junctions that can be added to *either* of the 5' or 3' section of the transcript.",
              "type": "integer",
              "minimum": 0,
              "default": 2
            }
          }
        },
        "output_format": {
          "type": "object",
          "additionalProperties": false,
          "description": "Parameters related to the output format.",
          "properties": {
            "source": {
              "description": "Prefix for the source field in the mikado output.",
              "type": "string",
              "default": "Mikado"
            },
            "id_prefix": {
              "description": "Prefix for the ID of the genes/transcripts in the output",
              "type": "string",
              "default": "mikado"
            },
            "report_all_orfs": {
              "description": "Boolean switch. If set to true, Mikado will report all ORFs associated with a transcript in the final loci file.",
              "type": "boolean",
              "default": false
            }
          }
        },
        "orf_loading": {
          "additionalProperties": false,
          "type": "object",
          "description": "Parameters related to ORF loading.",
          "properties": {
            "minimal_secondary_orf_length": {
              "description": "Minimum length of a *secondary* ORF to be loaded after the first, in bp. Default: 200 bps",
              "type": "integer",
              "default": 200,
              "minimum": 0
            },
            "minimal_orf_length": {
              "description": "Minimum length in bps of an ORF to be loaded, as the primary ORF, onto a transcript. Default: 50 bps",
              "type": "integer",
              "default": 50,
              "minimum": 0
            },
            "strand_specific": {
              "description": "Boolean flag. If set to true, monoexonic transcripts with an available ORF on the opposite strand will still not be reversed.",
              "type": "boolean",
              "default": true
            }
          }
        },
        "chimera_split": {
          "type": "object",
          "additionalProperties": false,
          "title": "Parameters related to the splitting of transcripts in the presence of two or more ORFs.",
          "properties": {
            "blast_check": {
              "type": "boolean",
              "description": "Whether to use BLAST information to take a decision. See blast_params for details.",
              "default": true
            },
            "execute": {
              "description": "Whether to split multi-ORF transcripts at all. Boolean.",
              "type": "boolean",
              "default": true
            },
            "skip": {
              "description": "Input sources for which Mikado will skip the splitting, e.g. ultra-reliable full cDNA sequences.",
              "type": "array",
              "default": []
            },
            "blast_params": {
              "type": "object",
              "title": "Parameters for the BLAST check prior to splitting.",
              "properties": {
                "evalue": {
                  "description": "Minimum evalue for the whole hit. Default: 1e-6",
                  "type": "number",
                  "minimum": 0,
                  "default": 1e-06
                },
                "hsp_evalue": {
                  "description": "Minimum evalue for any HSP hit (some might be discarded even if the whole hit is valid). Default: 1e-6",
                  "type": "number",
                  "minimum": 0,
                  "default": 1e-06
                },
                "leniency": {
                  "type": "string",
                  "description": "One of 'STRINGENT', 'LENIENT', 'PERMISSIVE'. Please refer to the online documentation for details. Default: STRINGENT",
                  "enum": [
                    "STRINGENT",
                    "LENIENT",
                    "PERMISSIVE"
                  ],
                  "default": "STRINGENT"
                },
                "max_target_seqs": {
                  "type": "integer",
                  "description": "Maximum number of hits to consider. Default: 3",
                  "minimum": 1,
                  "default": 3
                },
                "minimal_hsp_overlap": {
                  "description": "Minimum overlap of the ORF with the HSP (*not* reciprocal). Default: 0.8, i.e. 80%",
                  "type": "number",
                  "minimum": 0,
                  "maximum": 1,
                  "default": 0.5
                },
                "min_overlap_duplication": {
                  "description": "min_overlap_duplication: minimum overlap (in %) for two ORFs to consider them as target duplications. This means that if two ORFs have no HSPs in common, but the coverage of their disjoint HSPs covers more than this percentage of the length of the *target*, they represent most probably a duplicated gene.",
                  "type": "number",
                  "minimum": 0,
                  "maximum": 1,
                  "default": 0.8
                }
              }
            }
          },
          "required": [
            "blast_check",
            "execute"
          ]
        },
        "run_options": {
          "title": "Generic run options for Mikado pick.",
          "type": "object",
          "additionalProperties": false,
          "required": ["single_thread", "intron_range"],
          "properties": {
            "shm": {
              "description": "boolean flag. If set and the DB is sqlite, it will be copied onto the /dev/shm faux partition, for a potentially faster execution.",
              "type": "boolean",
              "default": false
            },
            "exclude_cds": {
              "description": "boolean flag. If set, the CDS information will not be printed in Mikado output. Default: false",
              "type": "boolean",
              "default": false
            },
            "intron_range": {
              "description": "A range where most of the introns (99%) should fall into. Transcripts with too many introns larger or smaller than what is defined in this range will be penalised in the scoring. Default: [60, 900]",
              "type": "array",
              "items": {
                "type": "integer",
                "minimum": 0
              },
              "uniqueItems": true,
              "maxItems": 2,
              "minItems": 2,
              "default": [60, 10000]
            },
            "reference_update": {
              "description": "Boolean flag. If set, Mikado will run in reference-update mode, see documentation.",
              "type": "boolean",
              "default": false
            },
            "only_reference_update": {
              "description": "Boolean flag. If set, Mikado will run in reference-update mode, see documentation. Additionally, Mikado will ignore any locus where there is not at least one reference transcript.",
              "type": "boolean",
              "default": false
            },
            "check_references": {
              "description": "boolean flag. If set to true, transcripts marked as reference will still be checked for compliance with the requirements established in the scoring file.",
              "type": "boolean",
              "default": false
            },
            "single_thread": {
              "description": "Boolean flag. If set, multithreading will be disabled - useful for profiling and debugging.",
              "type": "boolean",
              "default": false
            }
          }
        },
        "clustering": {
          "type": "object",
          "additionalProperties": false,
          "description": "Parameters related to the clustering of transcripts into loci.",
          "properties": {
            "cds_only": {
              "description": "Boolean, it specifies whether to cluster transcripts only according to their CDS (if present).",
              "type": "boolean",
              "default": false
            },
            "min_cds_overlap": {
              "description": "Minimal CDS overlap for the second clustering, in percentage between 0 and 1. Default: 0.2, or 20%",
              "type": "number",
              "minimum": 0.000001,
              "maximum": 1,
              "default": 0.2
            },
            "min_cdna_overlap": {
              "description": "Minimal cDNA overlap for the second clustering, in percentage between 0 and 1. Default: 0.2, or 20%.",
              "type": "number",
              "minimum": 0.000001,
              "maximum": 1,
              "default": 0.2
            },
            "purge": {
              "description": "Boolean, it specifies whether to remove transcripts which fail the minimum requirements check, or if instead to just assign them a score of 0 (potentially retaining them in the final output).",
              "type": "boolean",
              "default": true
            },
            "flank": {
              "description": "Maximum distance for transcripts to be clustered within the same superlocus.",
              "type": "integer",
              "minimum": 0,
              "default": 200
            },
            "simple_overlap_for_monoexonic": {
              "description": "boolean. Disabled by default. If set to true, then any overlap, even minimal, will suffice to incude monoexonic transcripts in a locus.",
              "type": "boolean",
              "default": false
            }
          }
        },
        "fragments":{
            "additionalProperties": false,
            "type": "object",
            "title": "Parameters related to the handling of fragments.",
            "properties": {
            "remove": {
              "type": "boolean",
              "default": true,
              "description": "boolean. Whether to remove fragments or leave them, properly tagged, in the output file. Default: remove them."
            },
            "max_distance": {
              "description": "Maximum distance of a putative fragment from a valid gene, for it to be considered by this filter.",
              "type": "number",
              "minimum": 0,
              "default": 2000
            },
            "valid_class_codes": {
              "type": "array",
              "description": "Which class codes will be considered as fragments. Default: (p, P, x, X, i, m, _). Choices: '_' plus any class code with category 'Intronic', 'Fragment', or 'Overlap'. Please refer to the online documentation or run 'mikado util class_codes for details.",
              "items": {
                "type": "string",
                "enum": [
                  "p",
                  "P",
                  "i",
                  "I",
                  "ri",
                  "rI",
                  "x",
                  "X",
                  "m",
                  "_",
                  "e",
                  "o"
                ]
              },
              "default": [
                "p",
                "P",
                "x",
                "X",
                "i",
                "m",
                "_",
                "e",
                "o"
              ]
            }
            }
          },
          "files": {
          "additionalProperties": false,
          "type": "object",
          "description": "Input and output files for Mikado pick.",
          "required": ["input"],
          "properties": {
            "output_dir": {
              "description": "Output directory for mikado pick",
              "type": "string",
              "default": "."
            },
            "input": {
              "description": "Input GTF/GFF3/BED12 file. Default: mikado_prepared.gtf",
              "type": "string",
              "default": "mikado_prepared.gtf"
            },
            "loci_out": {
              "description": "Main output GFF3 file from Mikado pick. Default: mikado.loci.gff3",
              "type": "string",
              "default": "mikado.loci.gff3"
            },
            "subloci_out": {
              "description": "Optional GFF file with the intermediate subloci. Default: no output",
              "type": ["string", "null"],
              "default": ""
            },
            "monoloci_out": {
              "description": "optional GFF file with the intermediate monoloci. Default: no output",
              "type": ["string", "null"],
              "default": ""
            },
            "log": {"type": ["string", "null"], "default": "pick.log", "description": "Log file for mikado pick."}
          }
        }
      }
    },
    "reference": {
    "additionalProperties": false,
    "type": "object",
     "title": "Options related to the reference genome.",
    "required": ["genome"],
    "anyOf": [{"required": ["genome"]}, "genome_fai", "transcriptome"],
    "properties": {
      "genome": {
        "description": "The genome FASTA file. Required.",
        "type": "string",
        "default": ""
      },
      "genome_fai": {
        "description": "The corresponding FAI for the genome. Inferred if absent.",
        "type": ["string"],
        "default": ""
      },
      "transcriptome": {
        "type": ["string"],
        "default": "a GTF/GFF reference transcriptome. Currently ignored."
      }
     }
    }
  }
}
