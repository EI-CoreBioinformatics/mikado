<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Mikado.loci.transcript_methods.splitting &mdash; Mikado 19 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '19',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Mikado 19 documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Mikado.loci.transcript_methods.splitting</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the methods used by the Transcript class to split an instance into</span>
<span class="sd">multiple transcripts, if the conditions are met (multiple ORFs present and BLAST not</span>
<span class="sd">supporting them being part of the same transcript).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">intervaltree</span> <span class="kn">import</span> <span class="n">IntervalTree</span><span class="p">,</span> <span class="n">Interval</span>
<span class="kn">from</span> <span class="nn">...utilities</span> <span class="kn">import</span> <span class="n">overlap</span>
<span class="kn">from</span> <span class="nn">...exceptions</span> <span class="kn">import</span> <span class="n">InvalidTranscript</span>
<span class="kn">from</span> <span class="nn">...parsers.blast_utils</span> <span class="kn">import</span> <span class="n">merge</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Luca Venturini&#39;</span>


<div class="viewcode-block" id="check_split_by_blast"><a class="viewcode-back" href="../../../../Mikado.loci.transcript_methods.html#Mikado.loci.transcript_methods.splitting.check_split_by_blast">[docs]</a><span class="k">def</span> <span class="nf">check_split_by_blast</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">cds_boundaries</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method verifies if a transcript with multiple ORFs has support by BLAST to</span>
<span class="sd">    NOT split it into its different components.</span>

<span class="sd">    The minimal overlap between ORF and HSP is defined inside the JSON at the key</span>
<span class="sd">        [&quot;chimera_split&quot;][&quot;blast_params&quot;][&quot;minimal_hsp_overlap&quot;]</span>
<span class="sd">    basically, we consider a HSP a hit only if the overlap is over a certain threshold</span>
<span class="sd">    and the HSP evalue under a certain threshold.</span>

<span class="sd">    The split by CDS can be executed in three different ways - PERMISSIVE, LENIENT, STRINGENT:</span>

<span class="sd">    - PERMISSIVE: split if two CDSs do not have hits in common,</span>
<span class="sd">    even when one or both do not have a hit at all.</span>
<span class="sd">    - STRINGENT: split only if two CDSs have hits and none</span>
<span class="sd">    of those is in common between them.</span>
<span class="sd">    - LENIENT: split if *both* lack hits, OR *both* have hits and none</span>
<span class="sd">    of those is in common.</span>

<span class="sd">    :param transcript: the transcript instance</span>
<span class="sd">    :type transcript: mikado_lib.loci_objects.transcript.Transcript</span>
<span class="sd">    :param cds_boundaries:</span>
<span class="sd">    :return: cds_boundaries</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Establish the minimum overlap between an ORF and a BLAST hit to consider it</span>
    <span class="c1"># to establish belongingness</span>

    <span class="n">minimal_overlap</span> <span class="o">=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">json_conf</span><span class="p">[</span>
        <span class="s2">&quot;pick&quot;</span><span class="p">][</span><span class="s2">&quot;chimera_split&quot;</span><span class="p">][</span><span class="s2">&quot;blast_params&quot;</span><span class="p">][</span><span class="s2">&quot;minimal_hsp_overlap&quot;</span><span class="p">]</span>

    <span class="n">cds_hit_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">cds_boundaries</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cds_hit_dict</span><span class="p">:</span>
        <span class="n">cds_hit_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="c1"># BUG, this is a hacky fix</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="s2">&quot;blast_hits&quot;</span><span class="p">):</span>
        <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;BLAST hits store lost for </span><span class="si">%s</span><span class="s2">! Creating a mock one to avoid a crash&quot;</span><span class="p">,</span>

            <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">transcript</span><span class="o">.</span><span class="n">blast_hits</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> has </span><span class="si">%d</span><span class="s2"> possible hits&quot;</span><span class="p">,</span> <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">transcript</span><span class="o">.</span><span class="n">blast_hits</span><span class="p">))</span>

    <span class="c1"># Determine for each CDS which are the hits available</span>
    <span class="n">min_eval</span> <span class="o">=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">json_conf</span><span class="p">[</span><span class="s2">&quot;pick&quot;</span><span class="p">][</span><span class="s1">&#39;chimera_split&#39;</span><span class="p">][</span><span class="s1">&#39;blast_params&#39;</span><span class="p">][</span><span class="s1">&#39;hsp_evalue&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">transcript</span><span class="o">.</span><span class="n">blast_hits</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">_hsp</span> <span class="k">for</span> <span class="n">_hsp</span> <span class="ow">in</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;hsps&quot;</span><span class="p">]</span> <span class="k">if</span>
                        <span class="n">_hsp</span><span class="p">[</span><span class="s2">&quot;hsp_evalue&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">min_eval</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">cds_run</span> <span class="ow">in</span> <span class="n">cds_boundaries</span><span class="p">:</span>
                <span class="c1"># If I have a valid hit b/w the CDS region and the hit,</span>
                <span class="c1"># add the name to the set</span>
                <span class="n">overlap_threshold</span> <span class="o">=</span> <span class="n">minimal_overlap</span> <span class="o">*</span> <span class="p">(</span><span class="n">cds_run</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cds_run</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">overl</span> <span class="o">=</span> <span class="n">overlap</span><span class="p">(</span><span class="n">cds_run</span><span class="p">,</span> <span class="p">(</span><span class="n">hsp</span><span class="p">[</span><span class="s1">&#39;query_hsp_start&#39;</span><span class="p">],</span> <span class="n">hsp</span><span class="p">[</span><span class="s1">&#39;query_hsp_end&#39;</span><span class="p">]))</span>

                <span class="k">if</span> <span class="n">overl</span> <span class="o">&gt;=</span> <span class="n">overlap_threshold</span><span class="p">:</span>
                    <span class="n">cds_hit_dict</span><span class="p">[</span><span class="n">cds_run</span><span class="p">][(</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">],</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;target_length&quot;</span><span class="p">])]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>
                    <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;Overlap </span><span class="si">%s</span><span class="s2"> passed for </span><span class="si">%s</span><span class="s2"> between </span><span class="si">%s</span><span class="s2"> CDS and </span><span class="si">%s</span><span class="s2"> HSP (threshold </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                        <span class="n">overlap</span><span class="p">,</span>
                        <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                        <span class="n">cds_run</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">hsp</span><span class="p">[</span><span class="s1">&#39;query_hsp_start&#39;</span><span class="p">],</span> <span class="n">hsp</span><span class="p">[</span><span class="s1">&#39;query_hsp_end&#39;</span><span class="p">]),</span>
                        <span class="n">overlap_threshold</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;Overlap </span><span class="si">%s</span><span class="s2"> rejected for </span><span class="si">%s</span><span class="s2"> between </span><span class="si">%s</span><span class="s2"> CDS and </span><span class="si">%s</span><span class="s2"> HSP (threshold </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                        <span class="n">overlap</span><span class="p">,</span>
                        <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                        <span class="n">cds_run</span><span class="p">,</span> <span class="p">(</span><span class="n">hsp</span><span class="p">[</span><span class="s1">&#39;query_hsp_start&#39;</span><span class="p">],</span> <span class="n">hsp</span><span class="p">[</span><span class="s1">&#39;query_hsp_end&#39;</span><span class="p">]),</span>
                        <span class="n">overlap_threshold</span><span class="p">)</span>

    <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Final cds_hit_dict for </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">cds_hit_dict</span><span class="p">)</span>

    <span class="n">final_boundaries</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="n">__get_boundaries_from_blast</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">cds_boundaries</span><span class="p">,</span> <span class="n">cds_hit_dict</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="n">boundary</span> <span class="o">=</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">final_boundaries</span><span class="p">[</span><span class="n">boundary</span><span class="p">]</span> <span class="o">=</span> <span class="n">cds_boundaries</span><span class="p">[</span><span class="n">boundary</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nboun</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">boundary</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">final_boundaries</span><span class="p">[</span><span class="n">nboun</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">boun</span> <span class="ow">in</span> <span class="n">boundary</span><span class="p">:</span>
                <span class="n">final_boundaries</span><span class="p">[</span><span class="n">nboun</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cds_boundaries</span><span class="p">[</span><span class="n">boun</span><span class="p">])</span>
    <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Final boundaries for </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">final_boundaries</span><span class="p">)</span>

    <span class="n">cds_boundaries</span> <span class="o">=</span> <span class="n">final_boundaries</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">cds_boundaries</span></div>


<div class="viewcode-block" id="check_common_hits"><a class="viewcode-back" href="../../../../Mikado.loci.transcript_methods.html#Mikado.loci.transcript_methods.splitting.check_common_hits">[docs]</a><span class="k">def</span> <span class="nf">check_common_hits</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">cds_hits</span><span class="p">,</span> <span class="n">old_hits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This private method verifies whether we have to split a transcript</span>
<span class="sd">    if there are hits for both ORFs and some of them refer to the same target.</span>
<span class="sd">    To do so, we check whether the two CDS runs actually share at least one HSPs</span>
<span class="sd">    (in which case we do NOT want to split); if not, we verify whether the HSPs</span>
<span class="sd">    cover a large fraction of the target length. If this is the case, we decide to</span>
<span class="sd">    break down the transcript because we are probably in the presence of a tandem</span>
<span class="sd">    duplication.</span>

<span class="sd">    :param transcript: the transcript instance to analyse</span>
<span class="sd">    :type transcript: mikado_lib.loci_objects.transcript.Transcript</span>

<span class="sd">    :param cds_hits:</span>
<span class="sd">    :param old_hits:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">in_common</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cds_hits</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                                 <span class="nb">set</span><span class="p">(</span><span class="n">old_hits</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="c1"># We do not have any hit in common</span>
    <span class="n">min_overlap_duplication</span> <span class="o">=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">json_conf</span><span class="p">[</span>
        <span class="s2">&quot;pick&quot;</span><span class="p">][</span><span class="s1">&#39;chimera_split&#39;</span><span class="p">][</span><span class="s1">&#39;blast_params&#39;</span><span class="p">][</span><span class="s1">&#39;min_overlap_duplication&#39;</span><span class="p">]</span>
    <span class="n">to_break</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">common_hit</span> <span class="ow">in</span> <span class="n">in_common</span><span class="p">:</span>
        <span class="n">old_hsps</span> <span class="o">=</span> <span class="n">old_hits</span><span class="p">[</span><span class="n">common_hit</span><span class="p">]</span>
        <span class="n">cds_hsps</span> <span class="o">=</span> <span class="n">cds_hits</span><span class="p">[</span><span class="n">common_hit</span><span class="p">]</span>
        <span class="c1"># First check ... do we have HSPs in common?</span>
        <span class="c1"># if len(set.intersection(old_hsps, cds_hsps)) &gt; 0:</span>
        <span class="c1">#     to_break = False</span>
        <span class="c1">#     break</span>
        <span class="n">old_query_boundaries</span> <span class="o">=</span> <span class="n">IntervalTree</span><span class="p">([</span><span class="n">Interval</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="s2">&quot;query_hsp_start&quot;</span><span class="p">],</span>
                                                      <span class="n">h</span><span class="p">[</span><span class="s2">&quot;query_hsp_end&quot;</span><span class="p">])</span>
                                             <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">old_hsps</span><span class="p">])</span>
        <span class="c1"># Look for HSPs that span the two ORFs</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span>
                <span class="n">old_query_boundaries</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">new_cds</span><span class="p">[</span><span class="s2">&quot;query_hsp_start&quot;</span><span class="p">],</span>
                                            <span class="n">new_cds</span><span class="p">[</span><span class="s2">&quot;query_hsp_end&quot;</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
               <span class="k">for</span> <span class="n">new_cds</span> <span class="ow">in</span> <span class="n">cds_hsps</span><span class="p">):</span>
            <span class="n">to_break</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">old_target_boundaries</span> <span class="o">=</span> <span class="n">IntervalTree</span><span class="p">([</span>
            <span class="n">Interval</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="s2">&quot;target_hsp_start&quot;</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="s2">&quot;target_hsp_end&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">old_hsps</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">cds_hsp</span> <span class="ow">in</span> <span class="n">cds_hsps</span><span class="p">:</span>
            <span class="n">boundary</span> <span class="o">=</span> <span class="p">(</span><span class="n">cds_hsp</span><span class="p">[</span><span class="s2">&quot;target_hsp_start&quot;</span><span class="p">],</span> <span class="n">cds_hsp</span><span class="p">[</span><span class="s2">&quot;target_hsp_end&quot;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">target_hit</span> <span class="ow">in</span> <span class="n">old_target_boundaries</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="o">*</span><span class="n">boundary</span><span class="p">):</span>
                <span class="n">overlap_fraction</span> <span class="o">=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span>
                                                      <span class="n">target_hit</span><span class="p">)</span><span class="o">/</span><span class="n">common_hit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Checking overlap duplication for </span><span class="si">%s</span><span class="s2">; OF </span><span class="si">%s</span><span class="s2">, minimum </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                        <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">overlap_fraction</span><span class="p">,</span> <span class="n">min_overlap_duplication</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">overlap_fraction</span> <span class="o">&gt;=</span> <span class="n">min_overlap_duplication</span><span class="p">:</span>
                    <span class="n">to_break</span> <span class="o">=</span> <span class="bp">True</span> <span class="ow">and</span> <span class="n">to_break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">to_break</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">to_break</span></div>


<span class="k">def</span> <span class="nf">__get_boundaries_from_blast</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">cds_boundaries</span><span class="p">,</span> <span class="n">cds_hit_dict</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private method that calculates the CDS boundaries to keep</span>
<span class="sd">    given the blast hits. Called by check_split_by_blast</span>
<span class="sd">    :param cds_boundaries:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_boundaries</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">leniency</span> <span class="o">=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">json_conf</span><span class="p">[</span><span class="s2">&quot;pick&quot;</span><span class="p">][</span><span class="s1">&#39;chimera_split&#39;</span><span class="p">][</span><span class="s1">&#39;blast_params&#39;</span><span class="p">][</span><span class="s1">&#39;leniency&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">cds_boundary</span> <span class="ow">in</span> <span class="n">cds_boundaries</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">new_boundaries</span><span class="p">:</span>
            <span class="n">new_boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cds_boundary</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">old_boundary</span> <span class="o">=</span> <span class="n">new_boundaries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">cds_hits</span> <span class="o">=</span> <span class="n">cds_hit_dict</span><span class="p">[</span><span class="n">cds_boundary</span><span class="p">]</span>
            <span class="n">old_hits</span> <span class="o">=</span> <span class="n">cds_hit_dict</span><span class="p">[</span><span class="n">old_boundary</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cds_hits</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_hits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># No hit found for either CDS</span>
                <span class="c1"># If we are stringent, we DO NOT split</span>
                <span class="k">if</span> <span class="n">leniency</span> <span class="o">==</span> <span class="s2">&quot;STRINGENT&quot;</span><span class="p">:</span>
                    <span class="n">new_boundaries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cds_boundary</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Otherwise, we do split</span>
                    <span class="n">new_boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cds_boundary</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cds_hits</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_hits</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># We have hits for only one</span>
                <span class="c1"># If we are permissive, we split</span>
                <span class="k">if</span> <span class="n">leniency</span> <span class="o">==</span> <span class="s2">&quot;PERMISSIVE&quot;</span><span class="p">:</span>
                    <span class="n">new_boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cds_boundary</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_boundaries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cds_boundary</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">check_common_hits</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">cds_hits</span><span class="p">,</span> <span class="n">old_hits</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">new_boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cds_boundary</span><span class="p">])</span>
                <span class="c1"># We have hits in common</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_boundaries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cds_boundary</span><span class="p">)</span>
        <span class="c1"># } # Finish BLAST check</span>
    <span class="k">return</span> <span class="n">new_boundaries</span>


<span class="k">def</span> <span class="nf">__split_complex_exon</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">exon</span><span class="p">,</span> <span class="n">texon</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private method used to split an exon when it is only partially coding,</span>
<span class="sd">    :param exon: Exon to be analysed</span>
<span class="sd">    :param texon: Transcriptomic coordinates of the exon</span>
<span class="sd">    :param sentinel: tuple of boolean flags, it indicates whether there are transcripts on the left</span>
<span class="sd">    (first member) and/or on the right (second member) of the current instance.</span>

<span class="sd">    :param boundary: Transcriptomic coordinates of the ORF boundary.</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">sentinel</span>

    <span class="n">to_discard</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">new_exon</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exon</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># In this case we have that the exon ends exactly at the end of the</span>
        <span class="c1"># UTR, so we have to keep a one-base exon</span>
        <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Appending mixed UTR/CDS 5&#39; exon </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exon</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transcript</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
                <span class="c1"># Keep only the LAST base</span>
                <span class="n">to_discard</span> <span class="o">=</span> <span class="p">(</span><span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">new_exon</span> <span class="o">=</span> <span class="p">(</span><span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">texon</span> <span class="o">=</span> <span class="p">(</span><span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Appending monobase CDS exon </span><span class="si">%s</span><span class="s2"> (Texon </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                                        <span class="n">new_exon</span><span class="p">,</span>
                                        <span class="n">texon</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Keep only the FIRST base</span>
                <span class="n">to_discard</span> <span class="o">=</span> <span class="p">(</span><span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">new_exon</span> <span class="o">=</span> <span class="p">(</span><span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">texon</span> <span class="o">=</span> <span class="p">(</span><span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Appending monobase CDS exon </span><span class="si">%s</span><span class="s2"> (Texon </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                    <span class="n">new_exon</span><span class="p">,</span>
                    <span class="n">texon</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># In this case we have that the exon ends exactly at the end of the</span>
        <span class="c1"># CDS, so we have to keep a one-base exon</span>
        <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Appending mixed UTR/CDS right exon </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">exon</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transcript</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
                <span class="c1"># In this case we have to keep only the FIRST base</span>
                <span class="n">to_discard</span> <span class="o">=</span> <span class="p">(</span><span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">new_exon</span> <span class="o">=</span> <span class="p">(</span><span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">texon</span> <span class="o">=</span> <span class="p">(</span><span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Appending monobase CDS exon </span><span class="si">%s</span><span class="s2"> (Texon </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                    <span class="n">new_exon</span><span class="p">,</span>
                    <span class="n">texon</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># In this case we have to keep only the LAST base</span>
                <span class="n">to_discard</span> <span class="o">=</span> <span class="p">(</span><span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">new_exon</span> <span class="o">=</span> <span class="p">(</span><span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">texon</span> <span class="o">=</span> <span class="p">(</span><span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Appending monobase CDS exon </span><span class="si">%s</span><span class="s2"> (Texon </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                    <span class="n">new_exon</span><span class="p">,</span>
                    <span class="n">texon</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># Monoexonic</span>
        <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Exon </span><span class="si">%s</span><span class="s2">, case 3.1&quot;</span><span class="p">,</span> <span class="n">exon</span><span class="p">)</span>

        <span class="c1"># if transcript.monoexonic is False:</span>
        <span class="k">if</span> <span class="n">invert</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">new_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Case 3.1: Negative strand, another transcript on the left, new exon: </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">new_exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">new_exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Case 3.1: Negative strand, another transcript on the right, new exon: </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">new_exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">new_exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Case 3.1: Positive strand, another transcript on the left, new exon: </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">new_exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">new_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Case 3.1: Positive strand, another transcript on the right, new exon: </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">new_exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;[Monoexonic] Tstart shifted for </span><span class="si">%s</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> to </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;[Monoexonic] GStart shifted for </span><span class="si">%s</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> to </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;[Monoexonic] Tend shifted for </span><span class="si">%s</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> to </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;[Monoexonic] Gend shifted for </span><span class="si">%s</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> to </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># In this case we have that exon is sitting halfway</span>
        <span class="c1"># i.e. there is a partial 5&#39;UTR</span>
        <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transcript</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                <span class="n">new_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Tstart shifted for </span><span class="si">%s</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> to </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;GStart shifted for </span><span class="si">%s</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> to </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># In this case we have that exon is sitting halfway</span>
        <span class="c1"># i.e. there is a partial 3&#39;UTR</span>
        <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transcript</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                <span class="n">new_exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Tend shifted for </span><span class="si">%s</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> to </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Gend shifted for </span><span class="si">%s</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> to </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;New exon: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">new_exon</span><span class="p">)</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;New texon: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">texon</span><span class="p">)</span>

    <span class="c1"># Prevent monobase exons</span>
    <span class="c1"># if new_exon[0] == new_exon[1]:</span>
    <span class="c1">#     new_exon[1] += 1</span>
    <span class="n">new_exon</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">new_exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">new_exon</span><span class="p">,</span> <span class="n">texon</span><span class="p">,</span> <span class="n">to_discard</span>


<span class="k">def</span> <span class="nf">__create_splitted_exons</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">orf_strand</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a boundary in transcriptomic coordinates, this method will extract the</span>
<span class="sd">    exons retained in the splitted part of the model.</span>

<span class="sd">    :param boundary: the *transcriptomic* coordinates of start/end of the ORF(s)</span>
<span class="sd">    to be included in the new transcript</span>
<span class="sd">    :type boundary: (int,int)</span>

<span class="sd">    :param left: boolean flag indicating whether there is another sub-transcript</span>
<span class="sd">    to the left of the one we mean to create, irrespective of *genomic* strand</span>
<span class="sd">    :type left: bool</span>

<span class="sd">    :param left: boolean flag indicating whether there is another sub-transcript</span>
<span class="sd">    to the right of the one we mean to create, irrespective of *genomic* strand</span>
<span class="sd">    :type right: bool</span>


<span class="sd">    :return: my_exons (final exons), discarded_exons (eventual discarded exons),</span>
<span class="sd">    tstart (new transcript start), tend (new transcript end)</span>
<span class="sd">    :rtype: (list(int,int),list(int,int),int,int)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">my_exons</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">discarded_exons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tlength</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tstart</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;Inf&quot;</span><span class="p">)</span>
    <span class="n">tend</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-Inf&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">transcript</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
        <span class="n">reversal</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reversal</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Starting analysis on </span><span class="si">%s</span><span class="s2">, boundaries </span><span class="si">%s</span><span class="s2">, left: </span><span class="si">%s</span><span class="s2">, </span><span class="se">\</span>
<span class="s2">right: </span><span class="si">%s</span><span class="s2">, reversal: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">reversal</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">transcript</span><span class="o">.</span><span class="n">exons</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reversal</span><span class="p">):</span>
        <span class="c1"># Translate into transcript coordinates</span>
        <span class="n">elength</span> <span class="o">=</span> <span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">texon</span> <span class="o">=</span> <span class="p">[</span><span class="n">tlength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tlength</span> <span class="o">+</span> <span class="n">elength</span><span class="p">]</span>
        <span class="n">tlength</span> <span class="o">+=</span> <span class="n">elength</span>
        <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Analysing exon </span><span class="si">%s</span><span class="s2"> [</span><span class="si">%s</span><span class="s2">] for </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                <span class="n">exon</span><span class="p">,</span> <span class="n">texon</span><span class="p">,</span> <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

        <span class="c1"># SIMPLE CASES</span>
        <span class="c1"># Exon completely contained in the ORF</span>
        <span class="k">if</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Appending CDS exon </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exon</span><span class="p">)</span>
            <span class="n">my_exons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exon</span><span class="p">)</span>
        <span class="c1"># Exon on the left of the CDS</span>
        <span class="k">elif</span> <span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Appending 5&#39;UTR exon </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exon</span><span class="p">)</span>
                <span class="n">my_exons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exon</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Discarding 5&#39;UTR exon </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exon</span><span class="p">)</span>
                <span class="n">discarded_exons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exon</span><span class="p">)</span>
                <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Appending 3&#39;UTR exon </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exon</span><span class="p">)</span>
                <span class="n">my_exons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exon</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Discarding 3&#39;UTR exon </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exon</span><span class="p">)</span>
                <span class="n">discarded_exons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exon</span><span class="p">)</span>
                <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># exon with partial UTR, go to the relative function</span>
            <span class="c1"># to handle these complex cases</span>
            <span class="k">assert</span> <span class="n">transcript</span><span class="o">.</span><span class="n">strand</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
            <span class="n">exon</span><span class="p">,</span> <span class="n">texon</span><span class="p">,</span> <span class="n">to_discard</span> <span class="o">=</span> <span class="n">__split_complex_exon</span><span class="p">(</span>
                <span class="n">transcript</span><span class="p">,</span> <span class="n">exon</span><span class="p">,</span> <span class="n">texon</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">boundary</span><span class="p">,</span>
                <span class="n">invert</span><span class="o">=</span><span class="p">(</span><span class="n">transcript</span><span class="o">.</span><span class="n">strand</span> <span class="o">!=</span> <span class="n">orf_strand</span><span class="p">))</span>

            <span class="n">my_exons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exon</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">to_discard</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">discarded_exons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_discard</span><span class="p">)</span>

        <span class="n">tstart</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">texon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">tend</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tend</span><span class="p">,</span> <span class="n">texon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">my_exons</span><span class="p">,</span> <span class="n">discarded_exons</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span>


<span class="k">def</span> <span class="nf">__create_splitted_transcripts</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">cds_boundaries</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private method called by split_by_cds to create the various (N&gt;1) transcripts</span>
<span class="sd">    that are its output.</span>
<span class="sd">    :param cds_boundaries: a list of int tuples, containing the boundaries</span>
<span class="sd">     of the new transcripts.</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">spans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_transcripts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="n">bed12_objects</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="n">cds_boundaries</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">))):</span>
        <span class="n">new_transcript</span> <span class="o">=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">__class__</span><span class="p">()</span>
        <span class="n">new_transcript</span><span class="o">.</span><span class="n">feature</span> <span class="o">=</span> <span class="s2">&quot;mRNA&quot;</span>
        <span class="k">for</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="s2">&quot;strand&quot;</span><span class="p">,</span> <span class="s2">&quot;attributes&quot;</span><span class="p">]:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_transcript</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">attribute</span><span class="p">))</span>
        <span class="c1"># Determine which ORFs I have on my right and left</span>
        <span class="n">new_transcript</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># leftmost</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">counter</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cds_boundaries</span><span class="p">):</span>  <span class="c1"># rightmost</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Otherwise they start from 0</span>
        <span class="n">new_transcript</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="s2">&quot;{0}.split{1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
        <span class="n">new_transcript</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span>
        <span class="n">bed12_strand</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">strand</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">bed12_objects</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">bed12_strand</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">bed12_strand</span> <span class="o">=</span> <span class="n">bed12_strand</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Splitting exons for </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">new_transcript</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">my_exons</span><span class="p">,</span> <span class="n">discarded_exons</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span> <span class="o">=</span> <span class="n">__create_splitted_exons</span><span class="p">(</span>
            <span class="n">transcript</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bed12_strand</span><span class="p">)</span>

        <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;TID </span><span class="si">%s</span><span class="s2"> counter </span><span class="si">%d</span><span class="s2">, boundary </span><span class="si">%s</span><span class="s2">, left </span><span class="si">%s</span><span class="s2"> right </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span><span class="p">,</span>
                                <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                                <span class="n">counter</span><span class="p">,</span>
                                <span class="n">boundary</span><span class="p">,</span>
                                <span class="n">left</span><span class="p">,</span>
                                <span class="n">right</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;TID </span><span class="si">%s</span><span class="s2"> TEND </span><span class="si">%d</span><span class="s2"> Boun[1] </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                    <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">tend</span><span class="p">,</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;TID </span><span class="si">%s</span><span class="s2"> TSTART </span><span class="si">%d</span><span class="s2"> Boun[0] </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                    <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_exons</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">discarded_exons</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

        <span class="n">new_transcript</span><span class="o">.</span><span class="n">exons</span> <span class="o">=</span> <span class="n">my_exons</span>

        <span class="n">new_transcript</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="n">new_transcript</span><span class="o">.</span><span class="n">exons</span><span class="p">)</span>
        <span class="n">new_transcript</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">exon</span> <span class="ow">in</span> <span class="n">new_transcript</span><span class="o">.</span><span class="n">exons</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">new_transcript</span><span class="o">.</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">end</span>
        <span class="k">assert</span> <span class="n">new_transcript</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">start</span>
        <span class="k">assert</span> <span class="n">new_transcript</span><span class="o">.</span><span class="n">is_coding</span> <span class="ow">is</span> <span class="bp">False</span>
        <span class="n">new_transcript</span><span class="o">.</span><span class="n">json_conf</span> <span class="o">=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">json_conf</span>
        <span class="c1"># Now we have to modify the BED12s to reflect</span>
        <span class="c1"># the fact that we are starting/ending earlier</span>
        <span class="n">new_transcript</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
        <span class="c1"># if transcript.monoexonic is True:</span>
        <span class="c1"># if new_transcript.monoexonic is True:</span>
        <span class="c1">#     new_transcript.strand = None</span>

        <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Relocating </span><span class="si">%d</span><span class="s2"> ORFs into the new transcript (</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">), </span><span class="se">\</span>
<span class="s2">tcoordinates (</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="p">,</span>
                                <span class="nb">len</span><span class="p">(</span><span class="n">bed12_objects</span><span class="p">),</span>
                                <span class="n">new_transcript</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">new_transcript</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                                <span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span>
                                <span class="p">)</span>
        <span class="n">new_bed12s</span> <span class="o">=</span> <span class="n">__relocate_orfs</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">bed12_objects</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">new_bed12s</span> <span class="k">if</span> <span class="n">_</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Loading </span><span class="si">%d</span><span class="s2"> ORFs into the new transcript (</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">): </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                <span class="nb">len</span><span class="p">(</span><span class="n">new_bed12s</span><span class="p">),</span>
                                <span class="n">new_transcript</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">new_transcript</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                                <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">&quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">new_bed12s</span><span class="p">]))</span>
        <span class="n">new_transcript</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span>
        <span class="n">new_transcript</span><span class="o">.</span><span class="n">load_orfs</span><span class="p">(</span><span class="n">new_bed12s</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_transcript</span><span class="o">.</span><span class="n">selected_cds_length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">err_message</span> <span class="o">=</span> <span class="s2">&quot;No CDS information retained for {0} split {1}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
            <span class="n">err_message</span> <span class="o">+=</span> <span class="s2">&quot;BED: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new_bed12s</span><span class="p">]))</span>
            <span class="k">raise</span> <span class="n">InvalidTranscript</span><span class="p">(</span><span class="n">err_message</span><span class="p">)</span>

        <span class="c1"># Load the blast hits</span>
        <span class="n">__load_blast_hits</span><span class="p">(</span><span class="n">new_transcript</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">transcript</span><span class="p">)</span>
        <span class="n">new_transcript</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
        <span class="n">new_transcripts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_transcript</span><span class="p">)</span>
        <span class="n">nspan</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_transcript</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">new_transcript</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
        <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Transcript {0} split {1}, discarded exons: {2}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">discarded_exons</span><span class="p">))</span>
        <span class="n">__check_collisions</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">nspan</span><span class="p">,</span> <span class="n">spans</span><span class="p">)</span>
        <span class="n">spans</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">new_transcript</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">new_transcript</span><span class="o">.</span><span class="n">end</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">new_transcripts</span>


<span class="k">def</span> <span class="nf">__load_blast_hits</span><span class="p">(</span><span class="n">new_transcript</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">transcript</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to load the BLAST hits into the new splitted transcript.</span>
<span class="sd">    :param new_transcript: the splitted transcript</span>
<span class="sd">    :type new_transcript: mikado_lib.loci_objects.Transcript</span>
<span class="sd">    :param boundary: tuple(start, end) of the boundary of the new transcript</span>
<span class="sd">    :type boundary: tuple(int, int)</span>
<span class="sd">    :param transcript:  the original transcript</span>
<span class="sd">    :type transcript: mikado_lib.loci_objects.Transcript</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">transcript</span><span class="o">.</span><span class="n">blast_hits</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">overlap</span><span class="p">((</span><span class="n">hit</span><span class="p">[</span><span class="s2">&quot;query_start&quot;</span><span class="p">],</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;query_end&quot;</span><span class="p">]),</span> <span class="n">boundary</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="n">minimal_overlap</span> <span class="o">=</span> <span class="n">transcript</span><span class="o">.</span><span class="n">json_conf</span><span class="p">[</span>
                <span class="s2">&quot;pick&quot;</span><span class="p">][</span><span class="s2">&quot;chimera_split&quot;</span><span class="p">][</span><span class="s2">&quot;blast_params&quot;</span><span class="p">][</span><span class="s2">&quot;minimal_hsp_overlap&quot;</span><span class="p">]</span>
            <span class="n">new_hit</span> <span class="o">=</span> <span class="n">__recalculate_hit</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">minimal_overlap</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_hit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Hit </span><span class="si">%s</span><span class="s2">,</span>
<span class="s2">                                        previous id/query_al_length/t_al_length </span><span class="si">%f</span><span class="s2">/</span><span class="si">%f</span><span class="s2">/</span><span class="si">%f</span><span class="s2">,</span>
<span class="s2">                                        novel </span><span class="si">%f</span><span class="s2">/</span><span class="si">%f</span><span class="s2">/</span><span class="si">%f</span><span class="s2">&quot;&quot;&quot;</span><span class="p">,</span>
                                        <span class="n">new_hit</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">],</span>
                                        <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;global_identity&quot;</span><span class="p">],</span>
                                        <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;query_aligned_length&quot;</span><span class="p">],</span>
                                        <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;target_aligned_length&quot;</span><span class="p">],</span>
                                        <span class="n">new_hit</span><span class="p">[</span><span class="s2">&quot;global_identity&quot;</span><span class="p">],</span>
                                        <span class="n">new_hit</span><span class="p">[</span><span class="s2">&quot;query_aligned_length&quot;</span><span class="p">],</span>
                                        <span class="n">new_hit</span><span class="p">[</span><span class="s2">&quot;target_aligned_length&quot;</span><span class="p">])</span>

                <span class="n">new_transcript</span><span class="o">.</span><span class="n">blast_hits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hit</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Hit </span><span class="si">%s</span><span class="s2"> did not pass overlap checks for </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                        <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">],</span> <span class="n">new_transcript</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Ignoring hit </span><span class="si">%s</span><span class="s2"> as it is not intersecting&quot;</span><span class="p">,</span> <span class="n">hit</span><span class="p">)</span>
            <span class="k">continue</span>


<span class="k">def</span> <span class="nf">__check_collisions</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">nspan</span><span class="p">,</span> <span class="n">spans</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method checks whether a new transcript collides with a previously</span>
<span class="sd">    defined transcript.</span>
<span class="sd">    :param nspan:</span>
<span class="sd">    :param spans:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spans</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">for</span> <span class="n">span</span> <span class="ow">in</span> <span class="n">spans</span><span class="p">:</span>
        <span class="n">overl</span> <span class="o">=</span> <span class="n">overlap</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">nspan</span><span class="p">)</span>

        <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Comparing start-ends for split of </span><span class="si">%s</span><span class="s2">. SpanA: </span><span class="si">%s</span><span class="s2"> SpanB: </span><span class="si">%s</span><span class="s2"> Overlap: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span>
            <span class="n">nspan</span><span class="p">,</span> <span class="n">overl</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">overl</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">err_message</span> <span class="o">=</span> <span class="s2">&quot;Invalid overlap for {0}! T1: {1}. T2: {2}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">nspan</span><span class="p">)</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">err_message</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">InvalidTranscript</span><span class="p">(</span><span class="n">err_message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__recalculate_hit</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">minimal_overlap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Static method to recalculate coverage/identity for new hits.&quot;&quot;&quot;</span>

    <span class="n">__valid_matches</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">chr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">65</span><span class="p">,</span> <span class="mi">91</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">97</span><span class="p">,</span> <span class="mi">123</span><span class="p">)]</span> <span class="o">+</span>
                          <span class="p">[</span><span class="s2">&quot;|&quot;</span><span class="p">])</span>

    <span class="n">hit_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hit</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;hsps&quot;</span><span class="p">,)):</span>
        <span class="n">hit_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="n">hsp_dict_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># hit_dict[&quot;global_identity&quot;] = []</span>
    <span class="n">q_intervals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">t_intervals</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">identical_positions</span><span class="p">,</span> <span class="n">positives</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()</span>

    <span class="n">best_hsp</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hit</span><span class="p">[</span><span class="s2">&quot;hsps&quot;</span><span class="p">]:</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">overlap</span><span class="p">((</span><span class="n">hsp</span><span class="p">[</span><span class="s2">&quot;query_hsp_start&quot;</span><span class="p">],</span> <span class="n">hsp</span><span class="p">[</span><span class="s2">&quot;query_hsp_end&quot;</span><span class="p">]),</span> <span class="n">boundary</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_</span> <span class="o">&gt;=</span> <span class="n">minimal_overlap</span> <span class="o">*</span> <span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">hsp_dict_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hsp</span><span class="p">[</span><span class="s2">&quot;hsp_evalue&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">best_hsp</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">best_hsp</span> <span class="o">=</span> <span class="p">(</span><span class="n">hsp</span><span class="p">[</span><span class="s2">&quot;hsp_evalue&quot;</span><span class="p">],</span> <span class="n">hsp</span><span class="p">[</span><span class="s2">&quot;hsp_bits&quot;</span><span class="p">])</span>

            <span class="n">q_intervals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">hsp</span><span class="p">[</span><span class="s2">&quot;query_hsp_start&quot;</span><span class="p">],</span> <span class="n">hsp</span><span class="p">[</span><span class="s2">&quot;query_hsp_end&quot;</span><span class="p">]))</span>
            <span class="n">t_intervals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">hsp</span><span class="p">[</span><span class="s2">&quot;target_hsp_start&quot;</span><span class="p">],</span> <span class="n">hsp</span><span class="p">[</span><span class="s2">&quot;target_hsp_end&quot;</span><span class="p">]))</span>

            <span class="n">query_pos</span> <span class="o">=</span> <span class="n">hsp</span><span class="p">[</span><span class="s2">&quot;query_hsp_start&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">amino</span> <span class="ow">in</span> <span class="n">hsp</span><span class="p">[</span><span class="s2">&quot;match&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">amino</span> <span class="ow">in</span> <span class="n">__valid_matches</span> <span class="ow">or</span> <span class="n">amino</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
                    <span class="n">query_pos</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">positives</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">query_pos</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">amino</span> <span class="o">!=</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
                        <span class="n">identical_positions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">query_pos</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">amino</span> <span class="o">==</span> <span class="s2">&quot;_&quot;</span><span class="p">:</span>  <span class="c1"># Gap in the target sequence</span>
                    <span class="n">query_pos</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsp_dict_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">q_merged_intervals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">merge</span><span class="p">(</span><span class="n">q_intervals</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">q_aligned</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">q_merged_intervals</span><span class="p">])</span>
    <span class="n">hit_dict</span><span class="p">[</span><span class="s2">&quot;query_aligned_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_aligned</span>
    <span class="n">hit_dict</span><span class="p">[</span><span class="s2">&quot;query_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_merged_intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">hit_dict</span><span class="p">[</span><span class="s2">&quot;query_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_merged_intervals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">t_merged_intervals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">merge</span><span class="p">(</span><span class="n">t_intervals</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">t_aligned</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">t_merged_intervals</span><span class="p">])</span>
    <span class="n">hit_dict</span><span class="p">[</span><span class="s2">&quot;target_aligned_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_aligned</span>
    <span class="n">hit_dict</span><span class="p">[</span><span class="s2">&quot;target_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_merged_intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">hit_dict</span><span class="p">[</span><span class="s2">&quot;target_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_merged_intervals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">hit_dict</span><span class="p">[</span><span class="s2">&quot;global_identity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">identical_positions</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">q_aligned</span>
    <span class="n">hit_dict</span><span class="p">[</span><span class="s2">&quot;global_positives&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positives</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">q_aligned</span>
    <span class="n">hit_dict</span><span class="p">[</span><span class="s2">&quot;hsps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hsp_dict_list</span>
    <span class="n">hit_dict</span><span class="p">[</span><span class="s2">&quot;bits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;hsp_bits&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hit_dict</span><span class="p">[</span><span class="s2">&quot;hsps&quot;</span><span class="p">])</span>
    <span class="n">hit_dict</span><span class="p">[</span><span class="s2">&quot;evalue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;hsp_evalue&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hit_dict</span><span class="p">[</span><span class="s2">&quot;hsps&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">hit_dict</span>


<span class="k">def</span> <span class="nf">__relocate_orfs</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">bed12_objects</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to recalculate the coordinates of BED12 objects based on</span>
<span class="sd">    the new transcriptomic start/end</span>
<span class="sd">    :param bed12_objects: list of the BED12 ORFs to relocate</span>
<span class="sd">    :param tstart: New transcriptomic start</span>
<span class="sd">    :param tend: New transcriptomic end</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_bed12s</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">bed12_objects</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="n">thick_start</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="n">obj</span><span class="o">.</span><span class="n">thick_end</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">thick_end</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="n">obj</span><span class="o">.</span><span class="n">thick_start</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">old_start</span><span class="p">,</span> <span class="n">old_end</span> <span class="o">=</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span>
            <span class="n">local_tstart</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="n">old_end</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">local_tend</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="n">old_start</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">old_end</span> <span class="o">-</span> <span class="n">old_start</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">local_tend</span> <span class="o">-</span> <span class="n">local_tstart</span><span class="p">),</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">old_start</span><span class="p">,</span> <span class="n">old_end</span><span class="p">),</span> <span class="p">(</span><span class="n">local_tstart</span><span class="p">,</span> <span class="n">local_tend</span><span class="p">))</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">thick_end</span> <span class="o">-</span> <span class="n">thick_start</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">thick_end</span> <span class="o">-</span> <span class="n">obj</span><span class="o">.</span><span class="n">thick_start</span><span class="p">)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">strand</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">local_tend</span> <span class="o">-</span> <span class="n">local_tstart</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">fasta_length</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">end</span>
            <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">end</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">obj</span><span class="o">.</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">start</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">thick_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">thick_start</span> <span class="o">-</span> <span class="n">local_tstart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">thick_start</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">thick_end</span> <span class="o">=</span> <span class="n">thick_end</span> <span class="o">-</span> <span class="n">local_tstart</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">thick_end</span> <span class="o">&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">thick_start</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">block_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">block_starts</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">block_starts</span><span class="p">]</span>
            <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Inverting negative ORF in </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                      <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">tend</span><span class="p">)</span> <span class="o">-</span> <span class="n">tstart</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">fasta_length</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">end</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">thick_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">thick_start</span><span class="p">,</span> <span class="n">tend</span><span class="p">)</span> <span class="o">-</span> <span class="n">tstart</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">thick_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">thick_end</span><span class="p">,</span> <span class="n">tend</span><span class="p">)</span> <span class="o">-</span> <span class="n">tstart</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">block_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">block_starts</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">block_starts</span><span class="p">]</span>

        <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">thick_start</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">thick_start</span>
        <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">thick_end</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">thick_end</span>
        <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">invalid</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">obj</span><span class="o">.</span><span class="n">cds_len</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">fasta_length</span><span class="p">,</span>
                                      <span class="n">obj</span><span class="o">.</span><span class="n">invalid_reason</span><span class="p">,</span>
                                      <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

        <span class="n">new_bed12s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_bed12s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">new_bed12s</span>


<div class="viewcode-block" id="split_by_cds"><a class="viewcode-back" href="../../../../Mikado.loci.transcript_methods.html#Mikado.loci.transcript_methods.splitting.split_by_cds">[docs]</a><span class="k">def</span> <span class="nf">split_by_cds</span><span class="p">(</span><span class="n">transcript</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This method is used for transcripts that have multiple ORFs.</span>
<span class="sd">    It will split them according to the CDS information into multiple transcripts.</span>
<span class="sd">    UTR information will be retained only if no ORF is down/upstream.</span>

<span class="sd">    :param transcript: the transcript instance</span>
<span class="sd">    :type transcript: mikado_lib.loci_objects.transcript.Transcript</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">transcript</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>

    <span class="c1"># List of the transcript that will be retained</span>

    <span class="k">if</span> <span class="n">transcript</span><span class="o">.</span><span class="n">number_internal_orfs</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">new_transcripts</span> <span class="o">=</span> <span class="p">[</span><span class="n">transcript</span><span class="p">]</span>  <span class="c1"># If we only have one ORF this is easy</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="n">cds_boundaries</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">orf</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">transcript</span><span class="o">.</span><span class="n">loaded_bed12</span><span class="p">,</span>
                          <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;thick_start&quot;</span><span class="p">,</span> <span class="s2">&quot;thick_end&quot;</span><span class="p">)):</span>
            <span class="n">cds_boundaries</span><span class="p">[(</span><span class="n">orf</span><span class="o">.</span><span class="n">thick_start</span><span class="p">,</span> <span class="n">orf</span><span class="o">.</span><span class="n">thick_end</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">orf</span><span class="p">]</span>

        <span class="c1"># Check whether we have to split or not based on BLAST data</span>
        <span class="k">if</span> <span class="n">transcript</span><span class="o">.</span><span class="n">json_conf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transcript</span><span class="o">.</span><span class="n">json_conf</span><span class="p">[</span><span class="s2">&quot;pick&quot;</span><span class="p">][</span><span class="s2">&quot;chimera_split&quot;</span><span class="p">][</span><span class="s2">&quot;blast_check&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">cds_boundaries</span> <span class="o">=</span> <span class="n">check_split_by_blast</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">cds_boundaries</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cds_boundaries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Recheck how many boundaries we have - after the BLAST check</span>
            <span class="c1"># we might have determined that the transcript has not to be split</span>
            <span class="n">new_transcripts</span> <span class="o">=</span> <span class="p">[</span><span class="n">transcript</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_transcripts</span> <span class="o">=</span> <span class="n">__create_splitted_transcripts</span><span class="p">(</span><span class="n">transcript</span><span class="p">,</span> <span class="n">cds_boundaries</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">InvalidTranscript</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">exc</span> <span class="o">=</span> <span class="n">InvalidTranscript</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error in splitting </span><span class="si">%s</span><span class="s2"> by ORF&quot;</span><span class="p">,</span>
                                        <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;ORFs: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">transcript</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">]))</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;BED12: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">transcript</span><span class="o">.</span><span class="n">loaded_bed12</span><span class="p">]))</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Stripping </span><span class="si">%s</span><span class="s2"> of its CDS.&quot;</span><span class="p">,</span>
                                        <span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">transcript</span><span class="o">.</span><span class="n">strip_cds</span><span class="p">()</span>
                <span class="n">new_transcripts</span> <span class="o">=</span> <span class="p">[</span><span class="n">transcript</span><span class="p">]</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_transcripts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">transcript</span><span class="p">)</span>
    <span class="n">__original</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">internal</span> <span class="ow">in</span> <span class="n">transcript</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">:</span>
        <span class="n">__original</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">internal</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CDS&quot;</span><span class="p">]))</span>

    <span class="k">for</span> <span class="n">new_transc</span> <span class="ow">in</span> <span class="n">new_transcripts</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">internal</span> <span class="ow">in</span> <span class="n">new_transc</span><span class="o">.</span><span class="n">internal_orfs</span><span class="p">:</span>
            <span class="n">internal</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">internal</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CDS&quot;</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">internal</span> <span class="ow">in</span> <span class="n">__original</span><span class="p">,</span> <span class="p">(</span><span class="n">transcript</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">__original</span><span class="p">,</span> <span class="n">internal</span><span class="p">)</span>

        <span class="n">new_transc</span><span class="o">.</span><span class="n">verified_introns</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_transc</span><span class="o">.</span><span class="n">introns</span><span class="p">),</span>
                                                       <span class="n">transcript</span><span class="o">.</span><span class="n">verified_introns</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">new_transc</span>

    <span class="k">return</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Luca Venturini, Shabhonam Caim.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>