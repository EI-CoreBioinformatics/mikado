<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sqlalchemy.sql.selectable &mdash; Mikado 19 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '19',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Mikado 19 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sqlalchemy.sql.selectable</h1><div class="highlight"><pre>
<span></span><span class="c1"># sql/selectable.py</span>
<span class="c1"># Copyright (C) 2005-2016 the SQLAlchemy authors and contributors</span>
<span class="c1"># &lt;see AUTHORS file&gt;</span>
<span class="c1">#</span>
<span class="c1"># This module is part of SQLAlchemy and is released under</span>
<span class="c1"># the MIT License: http://www.opensource.org/licenses/mit-license.php</span>

<span class="sd">&quot;&quot;&quot;The :class:`.FromClause` class of SQL expression elements, representing</span>
<span class="sd">SQL tables and derived rowsets.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">.elements</span> <span class="kn">import</span> <span class="n">ClauseElement</span><span class="p">,</span> <span class="n">TextClause</span><span class="p">,</span> <span class="n">ClauseList</span><span class="p">,</span> \
    <span class="n">and_</span><span class="p">,</span> <span class="n">Grouping</span><span class="p">,</span> <span class="n">UnaryExpression</span><span class="p">,</span> <span class="n">literal_column</span><span class="p">,</span> <span class="n">BindParameter</span>
<span class="kn">from</span> <span class="nn">.elements</span> <span class="kn">import</span> <span class="n">_clone</span><span class="p">,</span> \
    <span class="n">_literal_as_text</span><span class="p">,</span> <span class="n">_interpret_as_column_or_from</span><span class="p">,</span> <span class="n">_expand_cloned</span><span class="p">,</span>\
    <span class="n">_select_iterables</span><span class="p">,</span> <span class="n">_anonymous_label</span><span class="p">,</span> <span class="n">_clause_element_as_expr</span><span class="p">,</span>\
    <span class="n">_cloned_intersection</span><span class="p">,</span> <span class="n">_cloned_difference</span><span class="p">,</span> <span class="n">True_</span><span class="p">,</span> \
    <span class="n">_literal_as_label_reference</span><span class="p">,</span> <span class="n">_literal_and_labels_as_label_reference</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">Immutable</span><span class="p">,</span> <span class="n">Executable</span><span class="p">,</span> <span class="n">_generative</span><span class="p">,</span> \
    <span class="n">ColumnCollection</span><span class="p">,</span> <span class="n">ColumnSet</span><span class="p">,</span> <span class="n">_from_objects</span><span class="p">,</span> <span class="n">Generative</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">type_api</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">inspection</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">exc</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">attrgetter</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">operators</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">.annotation</span> <span class="kn">import</span> <span class="n">Annotated</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.sql.visitors</span> <span class="kn">import</span> <span class="n">Visitable</span>


<span class="k">def</span> <span class="nf">_interpret_as_from</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="n">insp</span> <span class="o">=</span> <span class="n">inspection</span><span class="o">.</span><span class="n">inspect</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">raiseerr</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">insp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">util</span><span class="o">.</span><span class="n">warn_limited</span><span class="p">(</span>
                <span class="s2">&quot;Textual SQL FROM expression </span><span class="si">%(expr)r</span><span class="s2"> should be &quot;</span>
                <span class="s2">&quot;explicitly declared as text(</span><span class="si">%(expr)r</span><span class="s2">), &quot;</span>
                <span class="s2">&quot;or use table(</span><span class="si">%(expr)r</span><span class="s2">) for more specificity&quot;</span><span class="p">,</span>
                <span class="p">{</span><span class="s2">&quot;expr&quot;</span><span class="p">:</span> <span class="n">util</span><span class="o">.</span><span class="n">ellipses_string</span><span class="p">(</span><span class="n">element</span><span class="p">)})</span>

            <span class="k">return</span> <span class="n">TextClause</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">insp</span><span class="o">.</span><span class="n">selectable</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span><span class="s2">&quot;FROM expression expected&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_interpret_as_select</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="n">element</span> <span class="o">=</span> <span class="n">_interpret_as_from</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Alias</span><span class="p">):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">original</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">SelectBase</span><span class="p">):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">element</span>


<span class="k">class</span> <span class="nc">_OffsetLimitParam</span><span class="p">(</span><span class="n">BindParameter</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_limit_offset_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective_value</span>


<span class="k">def</span> <span class="nf">_offset_or_limit_clause</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert the given value to an &quot;offset or limit&quot; clause.</span>

<span class="sd">    This handles incoming integers and converts to an expression; if</span>
<span class="sd">    an expression is already given, it is passed through.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">element</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__clause_element__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Visitable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">asint</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_OffsetLimitParam</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_offset_or_limit_clause_asint</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">attrname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert the &quot;offset or limit&quot; clause of a select construct to an</span>
<span class="sd">    integer.</span>

<span class="sd">    This is only possible if the value is stored as a simple bound parameter.</span>
<span class="sd">    Otherwise, a compilation error is raised.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">clause</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">clause</span><span class="o">.</span><span class="n">_limit_offset_value</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">CompileError</span><span class="p">(</span>
            <span class="s2">&quot;This SELECT structure does not use a simple &quot;</span>
            <span class="s2">&quot;integer value for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">attrname</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">asint</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">subquery</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an :class:`.Alias` object derived</span>
<span class="sd">    from a :class:`.Select`.</span>

<span class="sd">    name</span>
<span class="sd">      alias name</span>

<span class="sd">    \*args, \**kwargs</span>

<span class="sd">      all other arguments are delivered to the</span>
<span class="sd">      :func:`select` function.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Select</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">alias</span><span class="p">(</span><span class="n">selectable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an :class:`.Alias` object.</span>

<span class="sd">    An :class:`.Alias` represents any :class:`.FromClause`</span>
<span class="sd">    with an alternate name assigned within SQL, typically using the ``AS``</span>
<span class="sd">    clause when generated, e.g. ``SELECT * FROM table AS aliasname``.</span>

<span class="sd">    Similar functionality is available via the</span>
<span class="sd">    :meth:`~.FromClause.alias` method</span>
<span class="sd">    available on all :class:`.FromClause` subclasses.</span>

<span class="sd">    When an :class:`.Alias` is created from a :class:`.Table` object,</span>
<span class="sd">    this has the effect of the table being rendered</span>
<span class="sd">    as ``tablename AS aliasname`` in a SELECT statement.</span>

<span class="sd">    For :func:`.select` objects, the effect is that of creating a named</span>
<span class="sd">    subquery, i.e. ``(select ...) AS aliasname``.</span>

<span class="sd">    The ``name`` parameter is optional, and provides the name</span>
<span class="sd">    to use in the rendered SQL.  If blank, an &quot;anonymous&quot; name</span>
<span class="sd">    will be deterministically generated at compile time.</span>
<span class="sd">    Deterministic means the name is guaranteed to be unique against</span>
<span class="sd">    other constructs used in the same statement, and will also be the</span>
<span class="sd">    same name for each successive compilation of the same statement</span>
<span class="sd">    object.</span>

<span class="sd">    :param selectable: any :class:`.FromClause` subclass,</span>
<span class="sd">        such as a table, select statement, etc.</span>

<span class="sd">    :param name: string name to be assigned as the alias.</span>
<span class="sd">        If ``None``, a name will be deterministically generated</span>
<span class="sd">        at compile time.</span>

<span class="sd">    :param flat: Will be passed through to if the given selectable</span>
<span class="sd">     is an instance of :class:`.Join` - see :meth:`.Join.alias`</span>
<span class="sd">     for details.</span>

<span class="sd">     .. versionadded:: 0.9.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">selectable</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Selectable</span><span class="p">(</span><span class="n">ClauseElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;mark a class as being selectable&quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;selectable&#39;</span>

    <span class="n">is_selectable</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">HasPrefixes</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">_prefixes</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">prefix_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add one or more expressions following the statement keyword, i.e.</span>
<span class="sd">        SELECT, INSERT, UPDATE, or DELETE. Generative.</span>

<span class="sd">        This is used to support backend-specific prefix keywords such as those</span>
<span class="sd">        provided by MySQL.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            stmt = table.insert().prefix_with(&quot;LOW_PRIORITY&quot;, dialect=&quot;mysql&quot;)</span>

<span class="sd">        Multiple prefixes can be specified by multiple calls</span>
<span class="sd">        to :meth:`.prefix_with`.</span>

<span class="sd">        :param \*expr: textual or :class:`.ClauseElement` construct which</span>
<span class="sd">         will be rendered following the INSERT, UPDATE, or DELETE</span>
<span class="sd">         keyword.</span>
<span class="sd">        :param \**kw: A single keyword &#39;dialect&#39; is accepted.  This is an</span>
<span class="sd">         optional string dialect name which will</span>
<span class="sd">         limit rendering of this prefix to only that dialect.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dialect</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dialect&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kw</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span><span class="s2">&quot;Unsupported argument(s): </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                    <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">kw</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_prefixes</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">dialect</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_prefixes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefixes</span><span class="p">,</span> <span class="n">dialect</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prefixes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefixes</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">_literal_as_text</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">dialect</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prefixes</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">HasSuffixes</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">_suffixes</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">suffix_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add one or more expressions following the statement as a whole.</span>

<span class="sd">        This is used to support backend-specific suffix keywords on</span>
<span class="sd">        certain constructs.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            stmt = select([col1, col2]).cte().suffix_with(</span>
<span class="sd">                &quot;cycle empno set y_cycle to 1 default 0&quot;, dialect=&quot;oracle&quot;)</span>

<span class="sd">        Multiple suffixes can be specified by multiple calls</span>
<span class="sd">        to :meth:`.suffix_with`.</span>

<span class="sd">        :param \*expr: textual or :class:`.ClauseElement` construct which</span>
<span class="sd">         will be rendered following the target clause.</span>
<span class="sd">        :param \**kw: A single keyword &#39;dialect&#39; is accepted.  This is an</span>
<span class="sd">         optional string dialect name which will</span>
<span class="sd">         limit rendering of this suffix to only that dialect.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dialect</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dialect&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kw</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span><span class="s2">&quot;Unsupported argument(s): </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                    <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">kw</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_suffixes</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">dialect</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_suffixes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">,</span> <span class="n">dialect</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">_literal_as_text</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">dialect</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">suffixes</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">FromClause</span><span class="p">(</span><span class="n">Selectable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent an element that can be used within the ``FROM``</span>
<span class="sd">    clause of a ``SELECT`` statement.</span>

<span class="sd">    The most common forms of :class:`.FromClause` are the</span>
<span class="sd">    :class:`.Table` and the :func:`.select` constructs.  Key</span>
<span class="sd">    features common to all :class:`.FromClause` objects include:</span>

<span class="sd">    * a :attr:`.c` collection, which provides per-name access to a collection</span>
<span class="sd">      of :class:`.ColumnElement` objects.</span>
<span class="sd">    * a :attr:`.primary_key` attribute, which is a collection of all those</span>
<span class="sd">      :class:`.ColumnElement` objects that indicate the ``primary_key`` flag.</span>
<span class="sd">    * Methods to generate various derivations of a &quot;from&quot; clause, including</span>
<span class="sd">      :meth:`.FromClause.alias`, :meth:`.FromClause.join`,</span>
<span class="sd">      :meth:`.FromClause.select`.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;fromclause&#39;</span>
    <span class="n">named_with_column</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">_hide_froms</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">_is_join</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">_is_select</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">_is_from_container</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="n">_textual</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="sd">&quot;&quot;&quot;a marker that allows us to easily distinguish a :class:`.TextAsFrom`</span>
<span class="sd">    or similar object from other kinds of :class:`.FromClause` objects.&quot;&quot;&quot;</span>

    <span class="n">schema</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;Define the &#39;schema&#39; attribute for this :class:`.FromClause`.</span>

<span class="sd">    This is typically ``None`` for most objects except that of</span>
<span class="sd">    :class:`.Table`, where it is taken as the value of the</span>
<span class="sd">    :paramref:`.Table.schema` argument.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_memoized_property</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">group_expirable_memoized_property</span><span class="p">([</span><span class="s2">&quot;_columns&quot;</span><span class="p">])</span>

    <span class="nd">@util.dependencies</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.sql.functions&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">functions</span><span class="p">,</span> <span class="n">whereclause</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a SELECT COUNT generated against this</span>
<span class="sd">        :class:`.FromClause`.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Select</span><span class="p">(</span>
            <span class="p">[</span><span class="n">functions</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;tbl_row_count&#39;</span><span class="p">)],</span>
            <span class="n">whereclause</span><span class="p">,</span>
            <span class="n">from_obj</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">],</span>
            <span class="o">**</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">whereclause</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a SELECT of this :class:`.FromClause`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`~.sql.expression.select` - general purpose</span>
<span class="sd">            method which allows for arbitrary column lists.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Select</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="n">whereclause</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`.Join` from this :class:`.FromClause`</span>
<span class="sd">        to another :class:`FromClause`.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import join</span>

<span class="sd">            j = user_table.join(address_table,</span>
<span class="sd">                            user_table.c.id == address_table.c.user_id)</span>
<span class="sd">            stmt = select([user_table]).select_from(j)</span>

<span class="sd">        would emit SQL along the lines of::</span>

<span class="sd">            SELECT user.id, user.name FROM user</span>
<span class="sd">            JOIN address ON user.id = address.user_id</span>

<span class="sd">        :param right: the right side of the join; this is any</span>
<span class="sd">         :class:`.FromClause` object such as a :class:`.Table` object, and</span>
<span class="sd">         may also be a selectable-compatible object such as an ORM-mapped</span>
<span class="sd">         class.</span>

<span class="sd">        :param onclause: a SQL expression representing the ON clause of the</span>
<span class="sd">         join.  If left at ``None``, :meth:`.FromClause.join` will attempt to</span>
<span class="sd">         join the two tables based on a foreign key relationship.</span>

<span class="sd">        :param isouter: if True, render a LEFT OUTER JOIN, instead of JOIN.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.join` - standalone function</span>

<span class="sd">            :class:`.Join` - the type of object produced</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">isouter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">outerjoin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`.Join` from this :class:`.FromClause`</span>
<span class="sd">        to another :class:`FromClause`, with the &quot;isouter&quot; flag set to</span>
<span class="sd">        True.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import outerjoin</span>

<span class="sd">            j = user_table.outerjoin(address_table,</span>
<span class="sd">                            user_table.c.id == address_table.c.user_id)</span>

<span class="sd">        The above is equivalent to::</span>

<span class="sd">            j = user_table.join(</span>
<span class="sd">                address_table,</span>
<span class="sd">                user_table.c.id == address_table.c.user_id,</span>
<span class="sd">                isouter=True)</span>

<span class="sd">        :param right: the right side of the join; this is any</span>
<span class="sd">         :class:`.FromClause` object such as a :class:`.Table` object, and</span>
<span class="sd">         may also be a selectable-compatible object such as an ORM-mapped</span>
<span class="sd">         class.</span>

<span class="sd">        :param onclause: a SQL expression representing the ON clause of the</span>
<span class="sd">         join.  If left at ``None``, :meth:`.FromClause.join` will attempt to</span>
<span class="sd">         join the two tables based on a foreign key relationship.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.FromClause.join`</span>

<span class="sd">            :class:`.Join`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return an alias of this :class:`.FromClause`.</span>

<span class="sd">        This is shorthand for calling::</span>

<span class="sd">            from sqlalchemy import alias</span>
<span class="sd">            a = alias(self, name=name)</span>

<span class="sd">        See :func:`~.expression.alias` for details.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_derived_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromclause</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if this FromClause is &#39;derived&#39; from the given</span>
<span class="sd">        FromClause.</span>

<span class="sd">        An example would be an Alias of a Table is derived from that Table.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this is essentially an &quot;identity&quot; check in the base class.</span>
        <span class="c1"># Other constructs override this to traverse through</span>
        <span class="c1"># contained elements.</span>
        <span class="k">return</span> <span class="n">fromclause</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cloned_set</span>

    <span class="k">def</span> <span class="nf">_is_lexical_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if this FromClause and the other represent</span>
<span class="sd">        the same lexical identity.</span>

<span class="sd">        This tests if either one is a copy of the other, or</span>
<span class="sd">        if they are the same via annotation identity.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cloned_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_cloned_set</span><span class="p">)</span>

    <span class="nd">@util.dependencies</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.sql.util&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">replace_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sqlutil</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">alias</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;replace all occurrences of FromClause &#39;old&#39; with the given Alias</span>
<span class="sd">        object, returning a copy of this :class:`.FromClause`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">sqlutil</span><span class="o">.</span><span class="n">ClauseAdapter</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">correspond_on_equivalents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">equivalents</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return corresponding_column for the given column, or if None</span>
<span class="sd">        search for a match in the given dictionary.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corresponding_column</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">require_embedded</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">equivalents</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">equiv</span> <span class="ow">in</span> <span class="n">equivalents</span><span class="p">[</span><span class="n">col</span><span class="p">]:</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corresponding_column</span><span class="p">(</span><span class="n">equiv</span><span class="p">,</span> <span class="n">require_embedded</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nc</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">nc</span>
        <span class="k">return</span> <span class="n">col</span>

    <span class="k">def</span> <span class="nf">corresponding_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">require_embedded</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a :class:`.ColumnElement`, return the exported</span>
<span class="sd">        :class:`.ColumnElement` object from this :class:`.Selectable`</span>
<span class="sd">        which corresponds to that original</span>
<span class="sd">        :class:`~sqlalchemy.schema.Column` via a common ancestor</span>
<span class="sd">        column.</span>

<span class="sd">        :param column: the target :class:`.ColumnElement` to be matched</span>

<span class="sd">        :param require_embedded: only return corresponding columns for</span>
<span class="sd">         the given :class:`.ColumnElement`, if the given</span>
<span class="sd">         :class:`.ColumnElement` is actually present within a sub-element</span>
<span class="sd">         of this :class:`.FromClause`.  Normally the column will match if</span>
<span class="sd">         it merely shares a common ancestor with one of the exported</span>
<span class="sd">         columns of this :class:`.FromClause`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">embedded</span><span class="p">(</span><span class="n">expanded_proxy_set</span><span class="p">,</span> <span class="n">target_set</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">target_set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">expanded_proxy_set</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">_expand_cloned</span><span class="p">([</span><span class="n">t</span><span class="p">])</span>
                           <span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">expanded_proxy_set</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c1"># don&#39;t dig around if the column is locally present</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">contains_column</span><span class="p">(</span><span class="n">column</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">column</span>
        <span class="n">col</span><span class="p">,</span> <span class="n">intersect</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="n">target_set</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">proxy_set</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">_all_columns</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="n">expanded_proxy_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_expand_cloned</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">proxy_set</span><span class="p">))</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">target_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">expanded_proxy_set</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">require_embedded</span>
                      <span class="ow">or</span> <span class="n">embedded</span><span class="p">(</span><span class="n">expanded_proxy_set</span><span class="p">,</span> <span class="n">target_set</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>

                    <span class="c1"># no corresponding column yet, pick this one.</span>

                    <span class="n">col</span><span class="p">,</span> <span class="n">intersect</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersect</span><span class="p">):</span>

                    <span class="c1"># &#39;c&#39; has a larger field of correspondence than</span>
                    <span class="c1"># &#39;col&#39;. i.e. selectable.c.a1_x-&gt;a1.c.x-&gt;table.c.x</span>
                    <span class="c1"># matches a1.c.x-&gt;table.c.x better than</span>
                    <span class="c1"># selectable.c.x-&gt;table.c.x does.</span>

                    <span class="n">col</span><span class="p">,</span> <span class="n">intersect</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">intersect</span><span class="p">:</span>

                    <span class="c1"># they have the same field of correspondence. see</span>
                    <span class="c1"># which proxy_set has fewer columns in it, which</span>
                    <span class="c1"># indicates a closer relationship with the root</span>
                    <span class="c1"># column. Also take into account the &quot;weight&quot;</span>
                    <span class="c1"># attribute which CompoundSelect() uses to give</span>
                    <span class="c1"># higher precedence to columns based on vertical</span>
                    <span class="c1"># position in the compound statement, and discard</span>
                    <span class="c1"># columns that have no reference to the target</span>
                    <span class="c1"># column (also occurs with CompoundSelect)</span>

                    <span class="n">col_distance</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                        <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
                        <span class="p">[</span><span class="n">sc</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span>
                         <span class="n">col</span><span class="o">.</span><span class="n">proxy_set</span> <span class="k">if</span> <span class="n">sc</span><span class="o">.</span><span class="n">shares_lineage</span><span class="p">(</span><span class="n">column</span><span class="p">)])</span>
                    <span class="n">c_distance</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                        <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
                        <span class="p">[</span><span class="n">sc</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span>
                         <span class="n">c</span><span class="o">.</span><span class="n">proxy_set</span> <span class="k">if</span> <span class="n">sc</span><span class="o">.</span><span class="n">shares_lineage</span><span class="p">(</span><span class="n">column</span><span class="p">)])</span>
                    <span class="k">if</span> <span class="n">c_distance</span> <span class="o">&lt;</span> <span class="n">col_distance</span><span class="p">:</span>
                        <span class="n">col</span><span class="p">,</span> <span class="n">intersect</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">col</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;a brief description of this FromClause.</span>

<span class="sd">        Used primarily for error message formatting.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s2">&quot; object&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reset_exported</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;delete memoized collections when a FromClause is cloned.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_memoized_property</span><span class="o">.</span><span class="n">expire_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_memoized_property</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A named-based collection of :class:`.ColumnElement` objects</span>
<span class="sd">        maintained by this :class:`.FromClause`.</span>

<span class="sd">        The :attr:`.columns`, or :attr:`.c` collection, is the gateway</span>
<span class="sd">        to the construction of SQL expressions using table-bound or</span>
<span class="sd">        other selectable-bound columns::</span>

<span class="sd">            select([mytable]).where(mytable.c.somecolumn == 5)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;_columns&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_collections</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_populate_column_collection</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">as_immutable</span><span class="p">()</span>

    <span class="nd">@_memoized_property</span>
    <span class="k">def</span> <span class="nf">primary_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the collection of Column objects which comprise the</span>
<span class="sd">        primary key of this FromClause.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_collections</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_populate_column_collection</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span>

    <span class="nd">@_memoized_property</span>
    <span class="k">def</span> <span class="nf">foreign_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the collection of ForeignKey objects which this</span>
<span class="sd">        FromClause references.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_collections</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_populate_column_collection</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">foreign_keys</span>

    <span class="n">c</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;columns&#39;</span><span class="p">),</span>
                 <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;An alias for the :attr:`.columns` attribute.&quot;</span><span class="p">)</span>
    <span class="n">_select_iterable</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;columns&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_init_collections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="s1">&#39;_columns&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span>
        <span class="k">assert</span> <span class="s1">&#39;primary_key&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span>
        <span class="k">assert</span> <span class="s1">&#39;foreign_keys&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span> <span class="o">=</span> <span class="n">ColumnCollection</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span> <span class="o">=</span> <span class="n">ColumnSet</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foreign_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_cols_populated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;_columns&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span>

    <span class="k">def</span> <span class="nf">_populate_column_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called on subclasses to establish the .c collection.</span>

<span class="sd">        Each implementation has a different way of establishing</span>
<span class="sd">        this collection.</span>

<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_refresh_for_new_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a column added to the .c collection of an underlying</span>
<span class="sd">        selectable, produce the local version of that column, assuming this</span>
<span class="sd">        selectable ultimately should proxy this column.</span>

<span class="sd">        this is used to &quot;ping&quot; a derived selectable to add a new column</span>
<span class="sd">        to its .c. collection when a Column has been added to one of the</span>
<span class="sd">        Table objects it ultimtely derives from.</span>

<span class="sd">        If the given selectable hasn&#39;t populated its .c. collection yet,</span>
<span class="sd">        it should at least pass on the message to the contained selectables,</span>
<span class="sd">        but it will return None.</span>

<span class="sd">        This method is currently used by Declarative to allow Table</span>
<span class="sd">        columns to be added to a partially constructed inheritance</span>
<span class="sd">        mapping that may have already produced joins.  The method</span>
<span class="sd">        isn&#39;t public right now, as the full span of implications</span>
<span class="sd">        and/or caveats aren&#39;t yet clear.</span>

<span class="sd">        It&#39;s also possible that this functionality could be invoked by</span>
<span class="sd">        default via an event, which would require that</span>
<span class="sd">        selectables maintain a weak referencing collection of all</span>
<span class="sd">        derivations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cols_populated</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="n">column</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">column</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">Join</span><span class="p">(</span><span class="n">FromClause</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;represent a ``JOIN`` construct between two :class:`.FromClause`</span>
<span class="sd">    elements.</span>

<span class="sd">    The public constructor function for :class:`.Join` is the module-level</span>
<span class="sd">    :func:`.join()` function, as well as the :meth:`.FromClause.join` method</span>
<span class="sd">    of any :class:`.FromClause` (e.g. such as :class:`.Table`).</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.join`</span>

<span class="sd">        :meth:`.FromClause.join`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;join&#39;</span>

    <span class="n">_is_join</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a new :class:`.Join`.</span>

<span class="sd">        The usual entrypoint here is the :func:`~.expression.join`</span>
<span class="sd">        function or the :meth:`.FromClause.join` method of any</span>
<span class="sd">        :class:`.FromClause` object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">_interpret_as_from</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">_interpret_as_from</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">onclause</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">onclause</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_primaries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">onclause</span> <span class="o">=</span> <span class="n">onclause</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">isouter</span> <span class="o">=</span> <span class="n">isouter</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_outerjoin</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an ``OUTER JOIN`` clause element.</span>

<span class="sd">        The returned object is an instance of :class:`.Join`.</span>

<span class="sd">        Similar functionality is also available via the</span>
<span class="sd">        :meth:`~.FromClause.outerjoin()` method on any</span>
<span class="sd">        :class:`.FromClause`.</span>

<span class="sd">        :param left: The left side of the join.</span>

<span class="sd">        :param right: The right side of the join.</span>

<span class="sd">        :param onclause:  Optional criterion for the ``ON`` clause, is</span>
<span class="sd">          derived from foreign key relationships established between</span>
<span class="sd">          left and right otherwise.</span>

<span class="sd">        To chain joins together, use the :meth:`.FromClause.join` or</span>
<span class="sd">        :meth:`.FromClause.outerjoin` methods on the resulting</span>
<span class="sd">        :class:`.Join` object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_join</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a :class:`.Join` object, given two :class:`.FromClause`</span>
<span class="sd">        expressions.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            j = join(user_table, address_table,</span>
<span class="sd">                     user_table.c.id == address_table.c.user_id)</span>
<span class="sd">            stmt = select([user_table]).select_from(j)</span>

<span class="sd">        would emit SQL along the lines of::</span>

<span class="sd">            SELECT user.id, user.name FROM user</span>
<span class="sd">            JOIN address ON user.id = address.user_id</span>

<span class="sd">        Similar functionality is available given any</span>
<span class="sd">        :class:`.FromClause` object (e.g. such as a :class:`.Table`) using</span>
<span class="sd">        the :meth:`.FromClause.join` method.</span>

<span class="sd">        :param left: The left side of the join.</span>

<span class="sd">        :param right: the right side of the join; this is any</span>
<span class="sd">         :class:`.FromClause` object such as a :class:`.Table` object, and</span>
<span class="sd">         may also be a selectable-compatible object such as an ORM-mapped</span>
<span class="sd">         class.</span>

<span class="sd">        :param onclause: a SQL expression representing the ON clause of the</span>
<span class="sd">         join.  If left at ``None``, :meth:`.FromClause.join` will attempt to</span>
<span class="sd">         join the two tables based on a foreign key relationship.</span>

<span class="sd">        :param isouter: if True, render a LEFT OUTER JOIN, instead of JOIN.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.FromClause.join` - method form, based on a given left side</span>

<span class="sd">            :class:`.Join` - the type of object produced</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">isouter</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Join object on </span><span class="si">%s</span><span class="s2">(</span><span class="si">%d</span><span class="s2">) and </span><span class="si">%s</span><span class="s2">(</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
            <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
            <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">is_derived_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromclause</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fromclause</span> <span class="ow">is</span> <span class="bp">self</span> <span class="ow">or</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">is_derived_from</span><span class="p">(</span><span class="n">fromclause</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">is_derived_from</span><span class="p">(</span><span class="n">fromclause</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FromGrouping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@util.dependencies</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.sql.util&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_populate_column_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sqlutil</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span> <span class="o">+</span> \
            <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sqlutil</span><span class="o">.</span><span class="n">reduce_columns</span><span class="p">(</span>
            <span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">primary_key</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">onclause</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">col</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foreign_keys</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">foreign_keys</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_refresh_for_new_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">_refresh_for_new_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">_refresh_for_new_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cols_populated</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">foreign_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">primary_key</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">col</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_exported</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onclause</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onclause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onclause</span>

    <span class="k">def</span> <span class="nf">_match_primaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">Join</span><span class="p">):</span>
            <span class="n">left_right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">right</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left_right</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_condition</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">a_subset</span><span class="o">=</span><span class="n">left_right</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_join_condition</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ignore_nonexistent_tables</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                <span class="n">a_subset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                <span class="n">consider_as_foreign_keys</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;create a join condition between two tables or selectables.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            join_condition(tablea, tableb)</span>

<span class="sd">        would produce an expression along the lines of::</span>

<span class="sd">            tablea.c.id==tableb.c.tablea_id</span>

<span class="sd">        The join is determined based on the foreign key relationships</span>
<span class="sd">        between the two selectables.   If there are multiple ways</span>
<span class="sd">        to join, or no way to join, an error is raised.</span>

<span class="sd">        :param ignore_nonexistent_tables:  Deprecated - this</span>
<span class="sd">        flag is no longer used.  Only resolution errors regarding</span>
<span class="sd">        the two given tables are propagated.</span>

<span class="sd">        :param a_subset: An optional expression that is a sub-component</span>
<span class="sd">        of ``a``.  An attempt will be made to join to just this sub-component</span>
<span class="sd">        first before looking at the full ``a`` construct, and if found</span>
<span class="sd">        will be successful even if there are other ways to join to ``a``.</span>
<span class="sd">        This allows the &quot;right side&quot; of a join to be passed thereby</span>
<span class="sd">        providing a &quot;natural join&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_joincond_scan_left_right</span><span class="p">(</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">a_subset</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">consider_as_foreign_keys</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_joincond_trim_constraints</span><span class="p">(</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">consider_as_foreign_keys</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">FromGrouping</span><span class="p">):</span>
                <span class="n">hint</span> <span class="o">=</span> <span class="s2">&quot; Perhaps you meant to convert the right side to a &quot;</span>\
                    <span class="s2">&quot;subquery using alias()?&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hint</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">NoForeignKeysError</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t find any foreign key relationships &quot;</span>
                <span class="s2">&quot;between &#39;</span><span class="si">%s</span><span class="s2">&#39; and &#39;</span><span class="si">%s</span><span class="s2">&#39;.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="n">hint</span><span class="p">))</span>

        <span class="n">crit</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">constraints</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">crit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">crit</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">and_</span><span class="p">(</span><span class="o">*</span><span class="n">crit</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_joincond_scan_left_right</span><span class="p">(</span>
            <span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a_subset</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">consider_as_foreign_keys</span><span class="p">):</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">left</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a_subset</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">fk</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="n">b</span><span class="o">.</span><span class="n">foreign_keys</span><span class="p">,</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">fk</span><span class="p">:</span> <span class="n">fk</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">_creation_order</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">consider_as_foreign_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> \
                        <span class="n">fk</span><span class="o">.</span><span class="n">parent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">consider_as_foreign_keys</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="n">fk</span><span class="o">.</span><span class="n">get_referent</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NoReferenceError</span> <span class="k">as</span> <span class="n">nrte</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nrte</span><span class="o">.</span><span class="n">table_name</span> <span class="o">==</span> <span class="n">left</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                        <span class="k">raise</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">constraints</span><span class="p">[</span><span class="n">fk</span><span class="o">.</span><span class="n">constraint</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">fk</span><span class="o">.</span><span class="n">parent</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">b</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">fk</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                        <span class="n">left</span><span class="o">.</span><span class="n">foreign_keys</span><span class="p">,</span>
                        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">fk</span><span class="p">:</span> <span class="n">fk</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">_creation_order</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">consider_as_foreign_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> \
                            <span class="n">fk</span><span class="o">.</span><span class="n">parent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">consider_as_foreign_keys</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">col</span> <span class="o">=</span> <span class="n">fk</span><span class="o">.</span><span class="n">get_referent</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                    <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NoReferenceError</span> <span class="k">as</span> <span class="n">nrte</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">nrte</span><span class="o">.</span><span class="n">table_name</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                            <span class="k">raise</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>

                    <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">constraints</span><span class="p">[</span><span class="n">fk</span><span class="o">.</span><span class="n">constraint</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">fk</span><span class="o">.</span><span class="n">parent</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">constraints</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">constraints</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_joincond_trim_constraints</span><span class="p">(</span>
            <span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">consider_as_foreign_keys</span><span class="p">):</span>
        <span class="c1"># more than one constraint matched.  narrow down the list</span>
        <span class="c1"># to include just those FKCs that match exactly to</span>
        <span class="c1"># &quot;consider_as_foreign_keys&quot;.</span>
        <span class="k">if</span> <span class="n">consider_as_foreign_keys</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">const</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">constraints</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">parent</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">const</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span>
                        <span class="n">consider_as_foreign_keys</span><span class="p">):</span>
                    <span class="k">del</span> <span class="n">constraints</span><span class="p">[</span><span class="n">const</span><span class="p">]</span>

        <span class="c1"># if still multiple constraints, but</span>
        <span class="c1"># they all refer to the exact same end result, use it.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dedupe</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">crit</span><span class="p">)</span> <span class="k">for</span> <span class="n">crit</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dedupe</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">constraints</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">constraints</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">constraints</span><span class="p">[</span><span class="n">key</span><span class="p">]}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">AmbiguousForeignKeysError</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t determine join between &#39;</span><span class="si">%s</span><span class="s2">&#39; and &#39;</span><span class="si">%s</span><span class="s2">&#39;; &quot;</span>
                <span class="s2">&quot;tables have more than one foreign key &quot;</span>
                <span class="s2">&quot;constraint relationship between them. &quot;</span>
                <span class="s2">&quot;Please specify the &#39;onclause&#39; of this &quot;</span>
                <span class="s2">&quot;join explicitly.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">description</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">whereclause</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a :class:`.Select` from this :class:`.Join`.</span>

<span class="sd">        The equivalent long-hand form, given a :class:`.Join` object</span>
<span class="sd">        ``j``, is::</span>

<span class="sd">            from sqlalchemy import select</span>
<span class="sd">            j = select([j.left, j.right], **kw).\\</span>
<span class="sd">                        where(whereclause).\\</span>
<span class="sd">                        select_from(j)</span>

<span class="sd">        :param whereclause: the WHERE criterion that will be sent to</span>
<span class="sd">          the :func:`select()` function</span>

<span class="sd">        :param \**kwargs: all other kwargs are sent to the</span>
<span class="sd">          underlying :func:`select()` function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">collist</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Select</span><span class="p">(</span><span class="n">collist</span><span class="p">,</span> <span class="n">whereclause</span><span class="p">,</span> <span class="n">from_obj</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">bind</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">bind</span>

    <span class="nd">@util.dependencies</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.sql.util&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sqlutil</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return an alias of this :class:`.Join`.</span>

<span class="sd">        The default behavior here is to first produce a SELECT</span>
<span class="sd">        construct from this :class:`.Join`, then to produce an</span>
<span class="sd">        :class:`.Alias` from that.  So given a join of the form::</span>

<span class="sd">            j = table_a.join(table_b, table_a.c.id == table_b.c.a_id)</span>

<span class="sd">        The JOIN by itself would look like::</span>

<span class="sd">            table_a JOIN table_b ON table_a.id = table_b.a_id</span>

<span class="sd">        Whereas the alias of the above, ``j.alias()``, would in a</span>
<span class="sd">        SELECT context look like::</span>

<span class="sd">            (SELECT table_a.id AS table_a_id, table_b.id AS table_b_id,</span>
<span class="sd">                table_b.a_id AS table_b_a_id</span>
<span class="sd">                FROM table_a</span>
<span class="sd">                JOIN table_b ON table_a.id = table_b.a_id) AS anon_1</span>

<span class="sd">        The equivalent long-hand form, given a :class:`.Join` object</span>
<span class="sd">        ``j``, is::</span>

<span class="sd">            from sqlalchemy import select, alias</span>
<span class="sd">            j = alias(</span>
<span class="sd">                select([j.left, j.right]).\\</span>
<span class="sd">                    select_from(j).\\</span>
<span class="sd">                    with_labels(True).\\</span>
<span class="sd">                    correlate(False),</span>
<span class="sd">                name=name</span>
<span class="sd">            )</span>

<span class="sd">        The selectable produced by :meth:`.Join.alias` features the same</span>
<span class="sd">        columns as that of the two individual selectables presented under</span>
<span class="sd">        a single name - the individual columns are &quot;auto-labeled&quot;, meaning</span>
<span class="sd">        the ``.c.`` collection of the resulting :class:`.Alias` represents</span>
<span class="sd">        the names of the individual columns using a</span>
<span class="sd">        ``&lt;tablename&gt;_&lt;columname&gt;`` scheme::</span>

<span class="sd">            j.c.table_a_id</span>
<span class="sd">            j.c.table_b_a_id</span>

<span class="sd">        :meth:`.Join.alias` also features an alternate</span>
<span class="sd">        option for aliasing joins which produces no enclosing SELECT and</span>
<span class="sd">        does not normally apply labels to the column names.  The</span>
<span class="sd">        ``flat=True`` option will call :meth:`.FromClause.alias`</span>
<span class="sd">        against the left and right sides individually.</span>
<span class="sd">        Using this option, no new ``SELECT`` is produced;</span>
<span class="sd">        we instead, from a construct as below::</span>

<span class="sd">            j = table_a.join(table_b, table_a.c.id == table_b.c.a_id)</span>
<span class="sd">            j = j.alias(flat=True)</span>

<span class="sd">        we get a result like this::</span>

<span class="sd">            table_a AS table_a_1 JOIN table_b AS table_b_1 ON</span>
<span class="sd">            table_a_1.id = table_b_1.a_id</span>

<span class="sd">        The ``flat=True`` argument is also propagated to the contained</span>
<span class="sd">        selectables, so that a composite join such as::</span>

<span class="sd">            j = table_a.join(</span>
<span class="sd">                    table_b.join(table_c,</span>
<span class="sd">                            table_b.c.id == table_c.c.b_id),</span>
<span class="sd">                    table_b.c.a_id == table_a.c.id</span>
<span class="sd">                ).alias(flat=True)</span>

<span class="sd">        Will produce an expression like::</span>

<span class="sd">            table_a AS table_a_1 JOIN (</span>
<span class="sd">                    table_b AS table_b_1 JOIN table_c AS table_c_1</span>
<span class="sd">                    ON table_b_1.id = table_c_1.b_id</span>
<span class="sd">            ) ON table_a_1.id = table_b_1.a_id</span>

<span class="sd">        The standalone :func:`~.expression.alias` function as well as the</span>
<span class="sd">        base :meth:`.FromClause.alias` method also support the ``flat=True``</span>
<span class="sd">        argument as a no-op, so that the argument can be passed to the</span>
<span class="sd">        ``alias()`` method of any selectable.</span>

<span class="sd">        .. versionadded:: 0.9.0 Added the ``flat=True`` option to create</span>
<span class="sd">          &quot;aliases&quot; of joins without enclosing inside of a SELECT</span>
<span class="sd">          subquery.</span>

<span class="sd">        :param name: name given to the alias.</span>

<span class="sd">        :param flat: if True, produce an alias of the left and right</span>
<span class="sd">         sides of this :class:`.Join` and return the join of those</span>
<span class="sd">         two selectables.   This produces join expression that does not</span>
<span class="sd">         include an enclosing SELECT.</span>

<span class="sd">         .. versionadded:: 0.9.0</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`~.expression.alias`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">,</span> <span class="s2">&quot;Can&#39;t send name argument with flat&quot;</span>
            <span class="n">left_a</span><span class="p">,</span> <span class="n">right_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">adapter</span> <span class="o">=</span> <span class="n">sqlutil</span><span class="o">.</span><span class="n">ClauseAdapter</span><span class="p">(</span><span class="n">left_a</span><span class="p">)</span><span class="o">.</span>\
                <span class="n">chain</span><span class="p">(</span><span class="n">sqlutil</span><span class="o">.</span><span class="n">ClauseAdapter</span><span class="p">(</span><span class="n">right_a</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">left_a</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">right_a</span><span class="p">,</span> <span class="n">adapter</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onclause</span><span class="p">),</span>
                               <span class="n">isouter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">isouter</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">use_labels</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">correlate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_hide_froms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_from_objects</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cloned_set</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">onclause</span><span class="o">.</span><span class="n">_from_objects</span> <span class="o">+</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">_from_objects</span> <span class="o">+</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">_from_objects</span>


<span class="k">class</span> <span class="nc">Alias</span><span class="p">(</span><span class="n">FromClause</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents an table or selectable alias (AS).</span>

<span class="sd">    Represents an alias, as typically applied to any table or</span>
<span class="sd">    sub-select within a SQL statement using the ``AS`` keyword (or</span>
<span class="sd">    without the keyword on certain databases such as Oracle).</span>

<span class="sd">    This object is constructed from the :func:`~.expression.alias` module</span>
<span class="sd">    level function as well as the :meth:`.FromClause.alias` method available</span>
<span class="sd">    on all :class:`.FromClause` subclasses.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;alias&#39;</span>
    <span class="n">named_with_column</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">_is_from_container</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">baseselectable</span> <span class="o">=</span> <span class="n">selectable</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseselectable</span><span class="p">,</span> <span class="n">Alias</span><span class="p">):</span>
            <span class="n">baseselectable</span> <span class="o">=</span> <span class="n">baseselectable</span><span class="o">.</span><span class="n">element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original</span> <span class="o">=</span> <span class="n">baseselectable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">supports_execution</span> <span class="o">=</span> <span class="n">baseselectable</span><span class="o">.</span><span class="n">supports_execution</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">supports_execution</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span> <span class="o">=</span> <span class="n">baseselectable</span><span class="o">.</span><span class="n">_execution_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">selectable</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="o">.</span><span class="n">named_with_column</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">_anonymous_label</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%%</span><span class="s1">(</span><span class="si">%d</span><span class="s1"> </span><span class="si">%s</span><span class="s1">)s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span>
                                                    <span class="ow">or</span> <span class="s1">&#39;anon&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">util</span><span class="o">.</span><span class="n">py3k</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="s1">&#39;backslashreplace&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Element </span><span class="si">%s</span><span class="s2"> does not support &quot;</span>
                                 <span class="s2">&quot;&#39;as_scalar()&#39;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_derived_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromclause</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fromclause</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cloned_set</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">is_derived_from</span><span class="p">(</span><span class="n">fromclause</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_populate_column_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_all_columns</span><span class="p">:</span>
            <span class="n">col</span><span class="o">.</span><span class="n">_make_proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_refresh_for_new_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_refresh_for_new_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cols_populated</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">col</span><span class="o">.</span><span class="n">_make_proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="c1"># don&#39;t apply anything to an aliased Table</span>
        <span class="c1"># for now.   May want to drive this from</span>
        <span class="c1"># the given **kw.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="n">TableClause</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_exported</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="n">baseselectable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseselectable</span><span class="p">,</span> <span class="n">Alias</span><span class="p">):</span>
            <span class="n">baseselectable</span> <span class="o">=</span> <span class="n">baseselectable</span><span class="o">.</span><span class="n">element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original</span> <span class="o">=</span> <span class="n">baseselectable</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_collections</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">column_collections</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">c</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">bind</span>


<span class="k">class</span> <span class="nc">CTE</span><span class="p">(</span><span class="n">Generative</span><span class="p">,</span> <span class="n">HasSuffixes</span><span class="p">,</span> <span class="n">Alias</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a Common Table Expression.</span>

<span class="sd">    The :class:`.CTE` object is obtained using the</span>
<span class="sd">    :meth:`.SelectBase.cte` method from any selectable.</span>
<span class="sd">    See that method for complete examples.</span>

<span class="sd">    .. versionadded:: 0.7.6</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;cte&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectable</span><span class="p">,</span>
                 <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">recursive</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">_cte_alias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">_restates</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">(),</span>
                 <span class="n">_suffixes</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recursive</span> <span class="o">=</span> <span class="n">recursive</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cte_alias</span> <span class="o">=</span> <span class="n">_cte_alias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restates</span> <span class="o">=</span> <span class="n">_restates</span>
        <span class="k">if</span> <span class="n">_suffixes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span> <span class="o">=</span> <span class="n">_suffixes</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CTE</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">selectable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CTE</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">recursive</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">recursive</span><span class="p">,</span>
            <span class="n">_cte_alias</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">_suffixes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CTE</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">recursive</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">recursive</span><span class="p">,</span>
            <span class="n">_restates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_restates</span><span class="o">.</span><span class="n">union</span><span class="p">([</span><span class="bp">self</span><span class="p">]),</span>
            <span class="n">_suffixes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">union_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CTE</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="o">.</span><span class="n">union_all</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">recursive</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">recursive</span><span class="p">,</span>
            <span class="n">_restates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_restates</span><span class="o">.</span><span class="n">union</span><span class="p">([</span><span class="bp">self</span><span class="p">]),</span>
            <span class="n">_suffixes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">FromGrouping</span><span class="p">(</span><span class="n">FromClause</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a grouping of a FROM clause&quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;grouping&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>

    <span class="k">def</span> <span class="nf">_init_collections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">columns</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">primary_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">primary_key</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">foreign_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">foreign_keys</span>

    <span class="k">def</span> <span class="nf">is_derived_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">is_derived_from</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FromGrouping</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_hide_froms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_hide_froms</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_from_objects</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;element&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;element&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">TableClause</span><span class="p">(</span><span class="n">Immutable</span><span class="p">,</span> <span class="n">FromClause</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a minimal &quot;table&quot; construct.</span>

<span class="sd">    This is a lightweight table object that has only a name and a</span>
<span class="sd">    collection of columns, which are typically produced</span>
<span class="sd">    by the :func:`.expression.column` function::</span>

<span class="sd">        from sqlalchemy import table, column</span>

<span class="sd">        user = table(&quot;user&quot;,</span>
<span class="sd">                column(&quot;id&quot;),</span>
<span class="sd">                column(&quot;name&quot;),</span>
<span class="sd">                column(&quot;description&quot;),</span>
<span class="sd">        )</span>

<span class="sd">    The :class:`.TableClause` construct serves as the base for</span>
<span class="sd">    the more commonly used :class:`~.schema.Table` object, providing</span>
<span class="sd">    the usual set of :class:`~.expression.FromClause` services including</span>
<span class="sd">    the ``.c.`` collection and statement generation methods.</span>

<span class="sd">    It does **not** provide all the additional schema-level services</span>
<span class="sd">    of :class:`~.schema.Table`, including constraints, references to other</span>
<span class="sd">    tables, or support for :class:`.MetaData`-level services.  It&#39;s useful</span>
<span class="sd">    on its own as an ad-hoc construct used to generate quick SQL</span>
<span class="sd">    statements when a more fully fledged :class:`~.schema.Table`</span>
<span class="sd">    is not on hand.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;table&#39;</span>

    <span class="n">named_with_column</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">implicit_returning</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="sd">&quot;&quot;&quot;:class:`.TableClause` doesn&#39;t support having a primary key or column</span>
<span class="sd">    -level defaults, so implicit returning doesn&#39;t apply.&quot;&quot;&quot;</span>

    <span class="n">_autoincrement_column</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;No PK or default support so no autoincrement column.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a new :class:`.TableClause`.</span>

<span class="sd">        The object returned is an instance of :class:`.TableClause`, which</span>
<span class="sd">        represents the &quot;syntactical&quot; portion of the schema-level</span>
<span class="sd">        :class:`~.schema.Table` object.</span>
<span class="sd">        It may be used to construct lightweight table constructs.</span>

<span class="sd">        .. versionchanged:: 1.0.0 :func:`.expression.table` can now</span>
<span class="sd">           be imported from the plain ``sqlalchemy`` namespace like any</span>
<span class="sd">           other SQL element.</span>

<span class="sd">        :param name: Name of the table.</span>

<span class="sd">        :param columns: A collection of :func:`.expression.column` constructs.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">TableClause</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span> <span class="o">=</span> <span class="n">ColumnCollection</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span> <span class="o">=</span> <span class="n">ColumnSet</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foreign_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append_column</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_collections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">util</span><span class="o">.</span><span class="n">py3k</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="s1">&#39;backslashreplace&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">c</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_collections</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">column_collections</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@util.dependencies</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.sql.functions&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">functions</span><span class="p">,</span> <span class="n">whereclause</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a SELECT COUNT generated against this</span>
<span class="sd">        :class:`.TableClause`.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Select</span><span class="p">(</span>
            <span class="p">[</span><span class="n">functions</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;tbl_row_count&#39;</span><span class="p">)],</span>
            <span class="n">whereclause</span><span class="p">,</span>
            <span class="n">from_obj</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">],</span>
            <span class="o">**</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@util.dependencies</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.sql.dml&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dml</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inline</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate an :func:`.insert` construct against this</span>
<span class="sd">        :class:`.TableClause`.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            table.insert().values(name=&#39;foo&#39;)</span>

<span class="sd">        See :func:`.insert` for argument and usage information.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dml</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">inline</span><span class="o">=</span><span class="n">inline</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@util.dependencies</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.sql.dml&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">dml</span><span class="p">,</span> <span class="n">whereclause</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inline</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate an :func:`.update` construct against this</span>
<span class="sd">        :class:`.TableClause`.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            table.update().where(table.c.id==7).values(name=&#39;foo&#39;)</span>

<span class="sd">        See :func:`.update` for argument and usage information.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dml</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">whereclause</span><span class="o">=</span><span class="n">whereclause</span><span class="p">,</span>
                          <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">inline</span><span class="o">=</span><span class="n">inline</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@util.dependencies</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.sql.dml&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dml</span><span class="p">,</span> <span class="n">whereclause</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a :func:`.delete` construct against this</span>
<span class="sd">        :class:`.TableClause`.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            table.delete().where(table.c.id==7)</span>

<span class="sd">        See :func:`.delete` for argument and usage information.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dml</span><span class="o">.</span><span class="n">Delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">whereclause</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">ForUpdateArg</span><span class="p">(</span><span class="n">ClauseElement</span><span class="p">):</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_legacy_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the for_update arugment of :func:`.select`.</span>

<span class="sd">        :param mode: Defines the lockmode to use.</span>

<span class="sd">            ``None`` - translates to no lockmode</span>

<span class="sd">            ``&#39;update&#39;`` - translates to ``FOR UPDATE``</span>
<span class="sd">            (standard SQL, supported by most dialects)</span>

<span class="sd">            ``&#39;nowait&#39;`` - translates to ``FOR UPDATE NOWAIT``</span>
<span class="sd">            (supported by Oracle, PostgreSQL 8.1 upwards)</span>

<span class="sd">            ``&#39;read&#39;`` - translates to ``LOCK IN SHARE MODE`` (for MySQL),</span>
<span class="sd">            and ``FOR SHARE`` (for PostgreSQL)</span>

<span class="sd">            ``&#39;read_nowait&#39;`` - translates to ``FOR SHARE NOWAIT``</span>
<span class="sd">            (supported by PostgreSQL). ``FOR SHARE`` and</span>
<span class="sd">            ``FOR SHARE NOWAIT`` (PostgreSQL).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">nowait</span> <span class="o">=</span> <span class="n">read</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="s1">&#39;nowait&#39;</span><span class="p">:</span>
            <span class="n">nowait</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">arg</span> <span class="o">==</span> <span class="s1">&#39;read&#39;</span><span class="p">:</span>
            <span class="n">read</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">arg</span> <span class="o">==</span> <span class="s1">&#39;read_nowait&#39;</span><span class="p">:</span>
            <span class="n">read</span> <span class="o">=</span> <span class="n">nowait</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span><span class="s2">&quot;Unknown for_update argument: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">arg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ForUpdateArg</span><span class="p">(</span><span class="n">read</span><span class="o">=</span><span class="n">read</span><span class="p">,</span> <span class="n">nowait</span><span class="o">=</span><span class="n">nowait</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">legacy_for_update_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nowait</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;read&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nowait</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;read_nowait&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nowait</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;nowait&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">of</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">of</span> <span class="o">=</span> <span class="p">[</span><span class="n">clone</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">of</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nowait</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">of</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Represents arguments specified to :meth:`.Select.for_update`.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nowait</span> <span class="o">=</span> <span class="n">nowait</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">read</span>
        <span class="k">if</span> <span class="n">of</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">of</span> <span class="o">=</span> <span class="p">[</span><span class="n">_interpret_as_column_or_from</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">of</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">of</span> <span class="o">=</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">SelectBase</span><span class="p">(</span><span class="n">Executable</span><span class="p">,</span> <span class="n">FromClause</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for SELECT statements.</span>


<span class="sd">    This includes :class:`.Select`, :class:`.CompoundSelect` and</span>
<span class="sd">    :class:`.TextAsFrom`.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">as_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a &#39;scalar&#39; representation of this selectable, which can be</span>
<span class="sd">        used as a column expression.</span>

<span class="sd">        Typically, a select statement which has only one column in its columns</span>
<span class="sd">        clause is eligible to be used as a scalar expression.</span>

<span class="sd">        The returned object is an instance of</span>
<span class="sd">        :class:`ScalarSelect`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ScalarSelect</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a &#39;scalar&#39; representation of this selectable, embedded as a</span>
<span class="sd">        subquery with a label.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`~.SelectBase.as_scalar`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">()</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cte</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :class:`.CTE`, or Common Table Expression instance.</span>

<span class="sd">        Common table expressions are a SQL standard whereby SELECT</span>
<span class="sd">        statements can draw upon secondary statements specified along</span>
<span class="sd">        with the primary statement, using a clause called &quot;WITH&quot;.</span>
<span class="sd">        Special semantics regarding UNION can also be employed to</span>
<span class="sd">        allow &quot;recursive&quot; queries, where a SELECT statement can draw</span>
<span class="sd">        upon the set of rows that have previously been selected.</span>

<span class="sd">        SQLAlchemy detects :class:`.CTE` objects, which are treated</span>
<span class="sd">        similarly to :class:`.Alias` objects, as special elements</span>
<span class="sd">        to be delivered to the FROM clause of the statement as well</span>
<span class="sd">        as to a WITH clause at the top of the statement.</span>

<span class="sd">        .. versionadded:: 0.7.6</span>

<span class="sd">        :param name: name given to the common table expression.  Like</span>
<span class="sd">         :meth:`._FromClause.alias`, the name can be left as ``None``</span>
<span class="sd">         in which case an anonymous symbol will be used at query</span>
<span class="sd">         compile time.</span>
<span class="sd">        :param recursive: if ``True``, will render ``WITH RECURSIVE``.</span>
<span class="sd">         A recursive common table expression is intended to be used in</span>
<span class="sd">         conjunction with UNION ALL in order to derive rows</span>
<span class="sd">         from those already selected.</span>

<span class="sd">        The following examples illustrate two examples from</span>
<span class="sd">        Postgresql&#39;s documentation at</span>
<span class="sd">        http://www.postgresql.org/docs/8.4/static/queries-with.html.</span>

<span class="sd">        Example 1, non recursive::</span>

<span class="sd">            from sqlalchemy import (Table, Column, String, Integer,</span>
<span class="sd">                                    MetaData, select, func)</span>

<span class="sd">            metadata = MetaData()</span>

<span class="sd">            orders = Table(&#39;orders&#39;, metadata,</span>
<span class="sd">                Column(&#39;region&#39;, String),</span>
<span class="sd">                Column(&#39;amount&#39;, Integer),</span>
<span class="sd">                Column(&#39;product&#39;, String),</span>
<span class="sd">                Column(&#39;quantity&#39;, Integer)</span>
<span class="sd">            )</span>

<span class="sd">            regional_sales = select([</span>
<span class="sd">                                orders.c.region,</span>
<span class="sd">                                func.sum(orders.c.amount).label(&#39;total_sales&#39;)</span>
<span class="sd">                            ]).group_by(orders.c.region).cte(&quot;regional_sales&quot;)</span>


<span class="sd">            top_regions = select([regional_sales.c.region]).\\</span>
<span class="sd">                    where(</span>
<span class="sd">                        regional_sales.c.total_sales &gt;</span>
<span class="sd">                        select([</span>
<span class="sd">                            func.sum(regional_sales.c.total_sales)/10</span>
<span class="sd">                        ])</span>
<span class="sd">                    ).cte(&quot;top_regions&quot;)</span>

<span class="sd">            statement = select([</span>
<span class="sd">                        orders.c.region,</span>
<span class="sd">                        orders.c.product,</span>
<span class="sd">                        func.sum(orders.c.quantity).label(&quot;product_units&quot;),</span>
<span class="sd">                        func.sum(orders.c.amount).label(&quot;product_sales&quot;)</span>
<span class="sd">                ]).where(orders.c.region.in_(</span>
<span class="sd">                    select([top_regions.c.region])</span>
<span class="sd">                )).group_by(orders.c.region, orders.c.product)</span>

<span class="sd">            result = conn.execute(statement).fetchall()</span>

<span class="sd">        Example 2, WITH RECURSIVE::</span>

<span class="sd">            from sqlalchemy import (Table, Column, String, Integer,</span>
<span class="sd">                                    MetaData, select, func)</span>

<span class="sd">            metadata = MetaData()</span>

<span class="sd">            parts = Table(&#39;parts&#39;, metadata,</span>
<span class="sd">                Column(&#39;part&#39;, String),</span>
<span class="sd">                Column(&#39;sub_part&#39;, String),</span>
<span class="sd">                Column(&#39;quantity&#39;, Integer),</span>
<span class="sd">            )</span>

<span class="sd">            included_parts = select([</span>
<span class="sd">                                parts.c.sub_part,</span>
<span class="sd">                                parts.c.part,</span>
<span class="sd">                                parts.c.quantity]).\\</span>
<span class="sd">                                where(parts.c.part==&#39;our part&#39;).\\</span>
<span class="sd">                                cte(recursive=True)</span>


<span class="sd">            incl_alias = included_parts.alias()</span>
<span class="sd">            parts_alias = parts.alias()</span>
<span class="sd">            included_parts = included_parts.union_all(</span>
<span class="sd">                select([</span>
<span class="sd">                    parts_alias.c.sub_part,</span>
<span class="sd">                    parts_alias.c.part,</span>
<span class="sd">                    parts_alias.c.quantity</span>
<span class="sd">                ]).</span>
<span class="sd">                    where(parts_alias.c.part==incl_alias.c.sub_part)</span>
<span class="sd">            )</span>

<span class="sd">            statement = select([</span>
<span class="sd">                        included_parts.c.sub_part,</span>
<span class="sd">                        func.sum(included_parts.c.quantity).</span>
<span class="sd">                          label(&#39;total_quantity&#39;)</span>
<span class="sd">                    ]).\\</span>
<span class="sd">                    group_by(included_parts.c.sub_part)</span>

<span class="sd">            result = conn.execute(statement).fetchall()</span>


<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.orm.query.Query.cte` - ORM version of</span>
<span class="sd">            :meth:`.SelectBase.cte`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CTE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">)</span>

    <span class="nd">@_generative</span>
    <span class="nd">@util.deprecated</span><span class="p">(</span><span class="s1">&#39;0.6&#39;</span><span class="p">,</span>
                     <span class="n">message</span><span class="o">=</span><span class="s2">&quot;``autocommit()`` is deprecated. Use &quot;</span>
                     <span class="s2">&quot;:meth:`.Executable.execution_options` with the &quot;</span>
                     <span class="s2">&quot;&#39;autocommit&#39; flag.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">autocommit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new selectable with the &#39;autocommit&#39; flag set to</span>
<span class="sd">        True.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">({</span><span class="s1">&#39;autocommit&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">_generate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override the default _generate() method to also clear out</span>
<span class="sd">        exported collections.&quot;&quot;&quot;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">_reset_exported</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">GenerativeSelect</span><span class="p">(</span><span class="n">SelectBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for SELECT statements where additional elements can be</span>
<span class="sd">    added.</span>

<span class="sd">    This serves as the base for :class:`.Select` and :class:`.CompoundSelect`</span>
<span class="sd">    where elements such as ORDER BY, GROUP BY can be added and column</span>
<span class="sd">    rendering can be controlled.  Compare to :class:`.TextAsFrom`, which,</span>
<span class="sd">    while it subclasses :class:`.SelectBase` and is also a SELECT construct,</span>
<span class="sd">    represents a fixed textual string which cannot be altered at this level,</span>
<span class="sd">    only wrapped as a subquery.</span>

<span class="sd">    .. versionadded:: 0.9.0 :class:`.GenerativeSelect` was added to</span>
<span class="sd">       provide functionality specific to :class:`.Select` and</span>
<span class="sd">       :class:`.CompoundSelect` while allowing :class:`.SelectBase` to be</span>
<span class="sd">       used for other SELECT-like objects, e.g. :class:`.TextAsFrom`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_order_by_clause</span> <span class="o">=</span> <span class="n">ClauseList</span><span class="p">()</span>
    <span class="n">_group_by_clause</span> <span class="o">=</span> <span class="n">ClauseList</span><span class="p">()</span>
    <span class="n">_limit_clause</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_offset_clause</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_for_update_arg</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">use_labels</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">for_update</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">offset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">order_by</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">group_by</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">bind</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">autocommit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_labels</span> <span class="o">=</span> <span class="n">use_labels</span>

        <span class="k">if</span> <span class="n">for_update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="p">(</span><span class="n">ForUpdateArg</span><span class="o">.</span>
                                    <span class="n">parse_legacy_select</span><span class="p">(</span><span class="n">for_update</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">autocommit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span><span class="s1">&#39;autocommit on select() is &#39;</span>
                                 <span class="s1">&#39;deprecated.  Use .execution_options(a&#39;</span>
                                 <span class="s1">&#39;utocommit=True)&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                    <span class="p">{</span><span class="s1">&#39;autocommit&#39;</span><span class="p">:</span> <span class="n">autocommit</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_limit_clause</span> <span class="o">=</span> <span class="n">_offset_or_limit_clause</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset_clause</span> <span class="o">=</span> <span class="n">_offset_or_limit_clause</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span> <span class="o">=</span> <span class="n">bind</span>

        <span class="k">if</span> <span class="n">order_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order_by_clause</span> <span class="o">=</span> <span class="n">ClauseList</span><span class="p">(</span>
                <span class="o">*</span><span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">order_by</span><span class="p">),</span>
                <span class="n">_literal_as_text</span><span class="o">=</span><span class="n">_literal_and_labels_as_label_reference</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">group_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_by_clause</span> <span class="o">=</span> <span class="n">ClauseList</span><span class="p">(</span>
                <span class="o">*</span><span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">group_by</span><span class="p">),</span>
                <span class="n">_literal_as_text</span><span class="o">=</span><span class="n">_literal_as_label_reference</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">for_update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide legacy dialect support for the ``for_update`` attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_for_update_arg</span><span class="o">.</span><span class="n">legacy_for_update_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@for_update.setter</span>
    <span class="k">def</span> <span class="nf">for_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="n">ForUpdateArg</span><span class="o">.</span><span class="n">parse_legacy_select</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">with_for_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nowait</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">of</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specify a ``FOR UPDATE`` clause for this :class:`.GenerativeSelect`.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            stmt = select([table]).with_for_update(nowait=True)</span>

<span class="sd">        On a database like Postgresql or Oracle, the above would render a</span>
<span class="sd">        statement like::</span>

<span class="sd">            SELECT table.a, table.b FROM table FOR UPDATE NOWAIT</span>

<span class="sd">        on other backends, the ``nowait`` option is ignored and instead</span>
<span class="sd">        would produce::</span>

<span class="sd">            SELECT table.a, table.b FROM table FOR UPDATE</span>

<span class="sd">        When called with no arguments, the statement will render with</span>
<span class="sd">        the suffix ``FOR UPDATE``.   Additional arguments can then be</span>
<span class="sd">        provided which allow for common database-specific</span>
<span class="sd">        variants.</span>

<span class="sd">        :param nowait: boolean; will render ``FOR UPDATE NOWAIT`` on Oracle</span>
<span class="sd">         and Postgresql dialects.</span>

<span class="sd">        :param read: boolean; will render ``LOCK IN SHARE MODE`` on MySQL,</span>
<span class="sd">         ``FOR SHARE`` on Postgresql.  On Postgresql, when combined with</span>
<span class="sd">         ``nowait``, will render ``FOR SHARE NOWAIT``.</span>

<span class="sd">        :param of: SQL expression or list of SQL expression elements</span>
<span class="sd">         (typically :class:`.Column` objects or a compatible expression) which</span>
<span class="sd">         will render into a ``FOR UPDATE OF`` clause; supported by PostgreSQL</span>
<span class="sd">         and Oracle.  May render as a table or as a column depending on</span>
<span class="sd">         backend.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="n">ForUpdateArg</span><span class="p">(</span><span class="n">nowait</span><span class="o">=</span><span class="n">nowait</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="n">read</span><span class="p">,</span> <span class="n">of</span><span class="o">=</span><span class="n">of</span><span class="p">)</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">apply_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new selectable with the &#39;use_labels&#39; flag set to True.</span>

<span class="sd">        This will result in column expressions being generated using labels</span>
<span class="sd">        against their table name, such as &quot;SELECT somecolumn AS</span>
<span class="sd">        tablename_somecolumn&quot;. This allows selectables which contain multiple</span>
<span class="sd">        FROM clauses to produce a unique set of column names regardless of</span>
<span class="sd">        name conflicts among the individual FROM clauses.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_labels</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an integer value for the limit.  This should only be used</span>
<span class="sd">        by code that cannot support a limit as a BindParameter or</span>
<span class="sd">        other custom clause as it will throw an exception if the limit</span>
<span class="sd">        isn&#39;t currently set to an integer.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_offset_or_limit_clause_asint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_limit_clause</span><span class="p">,</span> <span class="s2">&quot;limit&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_simple_int_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the LIMIT clause is a simple integer, False</span>
<span class="sd">        if it is not present or is a SQL expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_limit_clause</span><span class="p">,</span> <span class="n">_OffsetLimitParam</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_simple_int_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the OFFSET clause is a simple integer, False</span>
<span class="sd">        if it is not present or is a SQL expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset_clause</span><span class="p">,</span> <span class="n">_OffsetLimitParam</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an integer value for the offset.  This should only be used</span>
<span class="sd">        by code that cannot support an offset as a BindParameter or</span>
<span class="sd">        other custom clause as it will throw an exception if the</span>
<span class="sd">        offset isn&#39;t currently set to an integer.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_offset_or_limit_clause_asint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset_clause</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">)</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new selectable with the given LIMIT criterion</span>
<span class="sd">        applied.</span>

<span class="sd">        This is a numerical value which usually renders as a ``LIMIT``</span>
<span class="sd">        expression in the resulting select.  Backends that don&#39;t</span>
<span class="sd">        support ``LIMIT`` will attempt to provide similar</span>
<span class="sd">        functionality.</span>

<span class="sd">        .. versionchanged:: 1.0.0 - :meth:`.Select.limit` can now</span>
<span class="sd">           accept arbitrary SQL expressions as well as integer values.</span>

<span class="sd">        :param limit: an integer LIMIT parameter, or a SQL expression</span>
<span class="sd">         that provides an integer result.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_limit_clause</span> <span class="o">=</span> <span class="n">_offset_or_limit_clause</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new selectable with the given OFFSET criterion</span>
<span class="sd">        applied.</span>


<span class="sd">        This is a numeric value which usually renders as an ``OFFSET``</span>
<span class="sd">        expression in the resulting select.  Backends that don&#39;t</span>
<span class="sd">        support ``OFFSET`` will attempt to provide similar</span>
<span class="sd">        functionality.</span>


<span class="sd">        .. versionchanged:: 1.0.0 - :meth:`.Select.offset` can now</span>
<span class="sd">           accept arbitrary SQL expressions as well as integer values.</span>

<span class="sd">        :param offset: an integer OFFSET parameter, or a SQL expression</span>
<span class="sd">         that provides an integer result.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_offset_clause</span> <span class="o">=</span> <span class="n">_offset_or_limit_clause</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">order_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new selectable with the given list of ORDER BY</span>
<span class="sd">        criterion applied.</span>

<span class="sd">        The criterion will be appended to any pre-existing ORDER BY</span>
<span class="sd">        criterion.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">append_order_by</span><span class="p">(</span><span class="o">*</span><span class="n">clauses</span><span class="p">)</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new selectable with the given list of GROUP BY</span>
<span class="sd">        criterion applied.</span>

<span class="sd">        The criterion will be appended to any pre-existing GROUP BY</span>
<span class="sd">        criterion.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">append_group_by</span><span class="p">(</span><span class="o">*</span><span class="n">clauses</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append_order_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append the given ORDER BY criterion applied to this selectable.</span>

<span class="sd">        The criterion will be appended to any pre-existing ORDER BY criterion.</span>

<span class="sd">        This is an **in-place** mutation method; the</span>
<span class="sd">        :meth:`~.GenerativeSelect.order_by` method is preferred, as it</span>
<span class="sd">        provides standard :term:`method chaining`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clauses</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">clauses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order_by_clause</span> <span class="o">=</span> <span class="n">ClauseList</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_order_by_clause&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">clauses</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order_by_clause</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">clauses</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order_by_clause</span> <span class="o">=</span> <span class="n">ClauseList</span><span class="p">(</span>
                <span class="o">*</span><span class="n">clauses</span><span class="p">,</span>
                <span class="n">_literal_as_text</span><span class="o">=</span><span class="n">_literal_and_labels_as_label_reference</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append_group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append the given GROUP BY criterion applied to this selectable.</span>

<span class="sd">        The criterion will be appended to any pre-existing GROUP BY criterion.</span>

<span class="sd">        This is an **in-place** mutation method; the</span>
<span class="sd">        :meth:`~.GenerativeSelect.group_by` method is preferred, as it</span>
<span class="sd">        provides standard :term:`method chaining`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clauses</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">clauses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_by_clause</span> <span class="o">=</span> <span class="n">ClauseList</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_group_by_clause&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">clauses</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group_by_clause</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">clauses</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_by_clause</span> <span class="o">=</span> <span class="n">ClauseList</span><span class="p">(</span>
                <span class="o">*</span><span class="n">clauses</span><span class="p">,</span> <span class="n">_literal_as_text</span><span class="o">=</span><span class="n">_literal_as_label_reference</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_label_resolve_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit_clause</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_limit_clause</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_limit_clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset_clause</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset_clause</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset_clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CompoundSelect</span><span class="p">(</span><span class="n">GenerativeSelect</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Forms the basis of ``UNION``, ``UNION ALL``, and other</span>
<span class="sd">        SELECT-based set operations.</span>


<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.union`</span>

<span class="sd">        :func:`.union_all`</span>

<span class="sd">        :func:`.intersect`</span>

<span class="sd">        :func:`.intersect_all`</span>

<span class="sd">        :func:`.except`</span>

<span class="sd">        :func:`.except_all`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;compound_select&#39;</span>

    <span class="n">UNION</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s1">&#39;UNION&#39;</span><span class="p">)</span>
    <span class="n">UNION_ALL</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s1">&#39;UNION ALL&#39;</span><span class="p">)</span>
    <span class="n">EXCEPT</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s1">&#39;EXCEPT&#39;</span><span class="p">)</span>
    <span class="n">EXCEPT_ALL</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s1">&#39;EXCEPT ALL&#39;</span><span class="p">)</span>
    <span class="n">INTERSECT</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s1">&#39;INTERSECT&#39;</span><span class="p">)</span>
    <span class="n">INTERSECT_ALL</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s1">&#39;INTERSECT ALL&#39;</span><span class="p">)</span>

    <span class="n">_is_from_container</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="o">*</span><span class="n">selects</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto_correlate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;correlate&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyword</span> <span class="o">=</span> <span class="n">keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selects</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">numcols</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># some DBs do not like ORDER BY in the inner queries of a UNION, etc.</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">selects</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">_clause_element_as_expr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">numcols</span><span class="p">:</span>
                <span class="n">numcols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">_all_columns</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">_all_columns</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numcols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                    <span class="s1">&#39;All selectables passed to &#39;</span>
                    <span class="s1">&#39;CompoundSelect must have identical numbers of &#39;</span>
                    <span class="s1">&#39;columns; select #</span><span class="si">%d</span><span class="s1"> has </span><span class="si">%d</span><span class="s1"> columns, select &#39;</span>
                    <span class="s1">&#39;#</span><span class="si">%d</span><span class="s1"> has </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">_all_columns</span><span class="p">),</span>
                     <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">_all_columns</span><span class="p">))</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">selects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">GenerativeSelect</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_label_resolve_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_union</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">selects</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a ``UNION`` of multiple selectables.</span>

<span class="sd">        The returned object is an instance of</span>
<span class="sd">        :class:`.CompoundSelect`.</span>

<span class="sd">        A similar :func:`union()` method is available on all</span>
<span class="sd">        :class:`.FromClause` subclasses.</span>

<span class="sd">        \*selects</span>
<span class="sd">          a list of :class:`.Select` instances.</span>

<span class="sd">        \**kwargs</span>
<span class="sd">           available keyword arguments are the same as those of</span>
<span class="sd">           :func:`select`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompoundSelect</span><span class="p">(</span><span class="n">CompoundSelect</span><span class="o">.</span><span class="n">UNION</span><span class="p">,</span> <span class="o">*</span><span class="n">selects</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_union_all</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">selects</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a ``UNION ALL`` of multiple selectables.</span>

<span class="sd">        The returned object is an instance of</span>
<span class="sd">        :class:`.CompoundSelect`.</span>

<span class="sd">        A similar :func:`union_all()` method is available on all</span>
<span class="sd">        :class:`.FromClause` subclasses.</span>

<span class="sd">        \*selects</span>
<span class="sd">          a list of :class:`.Select` instances.</span>

<span class="sd">        \**kwargs</span>
<span class="sd">          available keyword arguments are the same as those of</span>
<span class="sd">          :func:`select`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompoundSelect</span><span class="p">(</span><span class="n">CompoundSelect</span><span class="o">.</span><span class="n">UNION_ALL</span><span class="p">,</span> <span class="o">*</span><span class="n">selects</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_except</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">selects</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an ``EXCEPT`` of multiple selectables.</span>

<span class="sd">        The returned object is an instance of</span>
<span class="sd">        :class:`.CompoundSelect`.</span>

<span class="sd">        \*selects</span>
<span class="sd">          a list of :class:`.Select` instances.</span>

<span class="sd">        \**kwargs</span>
<span class="sd">          available keyword arguments are the same as those of</span>
<span class="sd">          :func:`select`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompoundSelect</span><span class="p">(</span><span class="n">CompoundSelect</span><span class="o">.</span><span class="n">EXCEPT</span><span class="p">,</span> <span class="o">*</span><span class="n">selects</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_except_all</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">selects</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an ``EXCEPT ALL`` of multiple selectables.</span>

<span class="sd">        The returned object is an instance of</span>
<span class="sd">        :class:`.CompoundSelect`.</span>

<span class="sd">        \*selects</span>
<span class="sd">          a list of :class:`.Select` instances.</span>

<span class="sd">        \**kwargs</span>
<span class="sd">          available keyword arguments are the same as those of</span>
<span class="sd">          :func:`select`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompoundSelect</span><span class="p">(</span><span class="n">CompoundSelect</span><span class="o">.</span><span class="n">EXCEPT_ALL</span><span class="p">,</span> <span class="o">*</span><span class="n">selects</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_intersect</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">selects</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an ``INTERSECT`` of multiple selectables.</span>

<span class="sd">        The returned object is an instance of</span>
<span class="sd">        :class:`.CompoundSelect`.</span>

<span class="sd">        \*selects</span>
<span class="sd">          a list of :class:`.Select` instances.</span>

<span class="sd">        \**kwargs</span>
<span class="sd">          available keyword arguments are the same as those of</span>
<span class="sd">          :func:`select`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompoundSelect</span><span class="p">(</span><span class="n">CompoundSelect</span><span class="o">.</span><span class="n">INTERSECT</span><span class="p">,</span> <span class="o">*</span><span class="n">selects</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_intersect_all</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">selects</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an ``INTERSECT ALL`` of multiple selectables.</span>

<span class="sd">        The returned object is an instance of</span>
<span class="sd">        :class:`.CompoundSelect`.</span>

<span class="sd">        \*selects</span>
<span class="sd">          a list of :class:`.Select` instances.</span>

<span class="sd">        \**kwargs</span>
<span class="sd">          available keyword arguments are the same as those of</span>
<span class="sd">          :func:`select`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompoundSelect</span><span class="p">(</span>
            <span class="n">CompoundSelect</span><span class="o">.</span><span class="n">INTERSECT_ALL</span><span class="p">,</span> <span class="o">*</span><span class="n">selects</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_scalar_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">selects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_scalar_type</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FromGrouping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_derived_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromclause</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selects</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_derived_from</span><span class="p">(</span><span class="n">fromclause</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_populate_column_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">cols</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">_all_columns</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selects</span><span class="p">]):</span>

            <span class="c1"># this is a slightly hacky thing - the union exports a</span>
            <span class="c1"># column that resembles just that of the *first* selectable.</span>
            <span class="c1"># to get at a &quot;composite&quot; column, particularly foreign keys,</span>
            <span class="c1"># you have to dig through the proxies collection which we</span>
            <span class="c1"># generate below.  We may want to improve upon this, such as</span>
            <span class="c1"># perhaps _make_proxy can accept a list of other columns</span>
            <span class="c1"># that are &quot;shared&quot; - schema.column can then copy all the</span>
            <span class="c1"># ForeignKeys in. this would allow the union() to have all</span>
            <span class="c1"># those fks too.</span>

            <span class="n">proxy</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_make_proxy</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_label</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_labels</span> <span class="k">else</span> <span class="bp">None</span><span class="p">,</span>
                <span class="n">key</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_key_label</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_labels</span> <span class="k">else</span> <span class="bp">None</span><span class="p">)</span>

            <span class="c1"># hand-construct the &quot;_proxies&quot; collection to include all</span>
            <span class="c1"># derived columns place a &#39;weight&#39; annotation corresponding</span>
            <span class="c1"># to how low in the list of select()s the column occurs, so</span>
            <span class="c1"># that the corresponding_column() operation can resolve</span>
            <span class="c1"># conflicts</span>

            <span class="n">proxy</span><span class="o">.</span><span class="n">_proxies</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">c</span><span class="o">.</span><span class="n">_annotate</span><span class="p">({</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">})</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cols</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_refresh_for_new_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selects</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">_refresh_for_new_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cols_populated</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;CompoundSelect constructs don&#39;t support &quot;</span>
                                  <span class="s2">&quot;addition of columns to underlying &quot;</span>
                                  <span class="s2">&quot;selectables&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CompoundSelect</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_copy_internals</span><span class="p">(</span><span class="n">clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_exported</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selects</span> <span class="o">=</span> <span class="p">[</span><span class="n">clone</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selects</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_col_map&#39;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_map</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="s1">&#39;_order_by_clause&#39;</span><span class="p">,</span> <span class="s1">&#39;_group_by_clause&#39;</span><span class="p">,</span> <span class="s1">&#39;_for_update_arg&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">clone</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="o">**</span><span class="n">kw</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_collections</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">column_collections</span> <span class="ow">and</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="p">[])</span> \
            <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_order_by_clause</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by_clause</span><span class="p">]</span> \
            <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selects</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selects</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">bind</span>
            <span class="k">if</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_set_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bind</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span> <span class="o">=</span> <span class="n">bind</span>
    <span class="n">bind</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="n">_set_bind</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Select</span><span class="p">(</span><span class="n">HasPrefixes</span><span class="p">,</span> <span class="n">HasSuffixes</span><span class="p">,</span> <span class="n">GenerativeSelect</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a ``SELECT`` statement.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;select&#39;</span>

    <span class="n">_prefixes</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_suffixes</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_hints</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">immutabledict</span><span class="p">()</span>
    <span class="n">_statement_hints</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_distinct</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">_from_cloned</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_correlate</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_correlate_except</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_memoized_property</span> <span class="o">=</span> <span class="n">SelectBase</span><span class="o">.</span><span class="n">_memoized_property</span>
    <span class="n">_is_select</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">columns</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">whereclause</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">from_obj</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">distinct</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">having</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">correlate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">prefixes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">suffixes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a new :class:`.Select`.</span>

<span class="sd">        Similar functionality is also available via the</span>
<span class="sd">        :meth:`.FromClause.select` method on any :class:`.FromClause`.</span>

<span class="sd">        All arguments which accept :class:`.ClauseElement` arguments also</span>
<span class="sd">        accept string arguments, which will be converted as appropriate into</span>
<span class="sd">        either :func:`text()` or :func:`literal_column()` constructs.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`coretutorial_selecting` - Core Tutorial description of</span>
<span class="sd">            :func:`.select`.</span>

<span class="sd">        :param columns:</span>
<span class="sd">          A list of :class:`.ColumnElement` or :class:`.FromClause`</span>
<span class="sd">          objects which will form the columns clause of the resulting</span>
<span class="sd">          statement.   For those objects that are instances of</span>
<span class="sd">          :class:`.FromClause` (typically :class:`.Table` or :class:`.Alias`</span>
<span class="sd">          objects), the :attr:`.FromClause.c` collection is extracted</span>
<span class="sd">          to form a collection of :class:`.ColumnElement` objects.</span>

<span class="sd">          This parameter will also accept :class:`.Text` constructs as</span>
<span class="sd">          given, as well as ORM-mapped classes.</span>

<span class="sd">          .. note::</span>

<span class="sd">            The :paramref:`.select.columns` parameter is not available</span>
<span class="sd">            in the method form of :func:`.select`, e.g.</span>
<span class="sd">            :meth:`.FromClause.select`.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :meth:`.Select.column`</span>

<span class="sd">            :meth:`.Select.with_only_columns`</span>

<span class="sd">        :param whereclause:</span>
<span class="sd">          A :class:`.ClauseElement` expression which will be used to form the</span>
<span class="sd">          ``WHERE`` clause.   It is typically preferable to add WHERE</span>
<span class="sd">          criterion to an existing :class:`.Select` using method chaining</span>
<span class="sd">          with :meth:`.Select.where`.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :meth:`.Select.where`</span>

<span class="sd">        :param from_obj:</span>
<span class="sd">          A list of :class:`.ClauseElement` objects which will be added to the</span>
<span class="sd">          ``FROM`` clause of the resulting statement.  This is equivalent</span>
<span class="sd">          to calling :meth:`.Select.select_from` using method chaining on</span>
<span class="sd">          an existing :class:`.Select` object.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :meth:`.Select.select_from` - full description of explicit</span>
<span class="sd">            FROM clause specification.</span>

<span class="sd">        :param autocommit:</span>
<span class="sd">          Deprecated.  Use ``.execution_options(autocommit=&lt;True|False&gt;)``</span>
<span class="sd">          to set the autocommit option.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :meth:`.Executable.execution_options`</span>

<span class="sd">        :param bind=None:</span>
<span class="sd">          an :class:`~.Engine` or :class:`~.Connection` instance</span>
<span class="sd">          to which the</span>
<span class="sd">          resulting :class:`.Select` object will be bound.  The</span>
<span class="sd">          :class:`.Select` object will otherwise automatically bind to</span>
<span class="sd">          whatever :class:`~.base.Connectable` instances can be located within</span>
<span class="sd">          its contained :class:`.ClauseElement` members.</span>

<span class="sd">        :param correlate=True:</span>
<span class="sd">          indicates that this :class:`.Select` object should have its</span>
<span class="sd">          contained :class:`.FromClause` elements &quot;correlated&quot; to an enclosing</span>
<span class="sd">          :class:`.Select` object.  It is typically preferable to specify</span>
<span class="sd">          correlations on an existing :class:`.Select` construct using</span>
<span class="sd">          :meth:`.Select.correlate`.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :meth:`.Select.correlate` - full description of correlation.</span>

<span class="sd">        :param distinct=False:</span>
<span class="sd">          when ``True``, applies a ``DISTINCT`` qualifier to the columns</span>
<span class="sd">          clause of the resulting statement.</span>

<span class="sd">          The boolean argument may also be a column expression or list</span>
<span class="sd">          of column expressions - this is a special calling form which</span>
<span class="sd">          is understood by the Postgresql dialect to render the</span>
<span class="sd">          ``DISTINCT ON (&lt;columns&gt;)`` syntax.</span>

<span class="sd">          ``distinct`` is also available on an existing :class:`.Select`</span>
<span class="sd">          object via the :meth:`~.Select.distinct` method.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :meth:`.Select.distinct`</span>

<span class="sd">        :param for_update=False:</span>
<span class="sd">          when ``True``, applies ``FOR UPDATE`` to the end of the</span>
<span class="sd">          resulting statement.</span>

<span class="sd">          .. deprecated:: 0.9.0 - use</span>
<span class="sd">             :meth:`.Select.with_for_update` to specify the</span>
<span class="sd">             structure of the ``FOR UPDATE`` clause.</span>

<span class="sd">          ``for_update`` accepts various string values interpreted by</span>
<span class="sd">          specific backends, including:</span>

<span class="sd">          * ``&quot;read&quot;`` - on MySQL, translates to ``LOCK IN SHARE MODE``;</span>
<span class="sd">            on Postgresql, translates to ``FOR SHARE``.</span>
<span class="sd">          * ``&quot;nowait&quot;`` - on Postgresql and Oracle, translates to</span>
<span class="sd">            ``FOR UPDATE NOWAIT``.</span>
<span class="sd">          * ``&quot;read_nowait&quot;`` - on Postgresql, translates to</span>
<span class="sd">            ``FOR SHARE NOWAIT``.</span>

<span class="sd">         .. seealso::</span>

<span class="sd">            :meth:`.Select.with_for_update` - improved API for</span>
<span class="sd">            specifying the ``FOR UPDATE`` clause.</span>

<span class="sd">        :param group_by:</span>
<span class="sd">          a list of :class:`.ClauseElement` objects which will comprise the</span>
<span class="sd">          ``GROUP BY`` clause of the resulting select.  This parameter</span>
<span class="sd">          is typically specified more naturally using the</span>
<span class="sd">          :meth:`.Select.group_by` method on an existing :class:`.Select`.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :meth:`.Select.group_by`</span>

<span class="sd">        :param having:</span>
<span class="sd">          a :class:`.ClauseElement` that will comprise the ``HAVING`` clause</span>
<span class="sd">          of the resulting select when ``GROUP BY`` is used.  This parameter</span>
<span class="sd">          is typically specified more naturally using the</span>
<span class="sd">          :meth:`.Select.having` method on an existing :class:`.Select`.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :meth:`.Select.having`</span>

<span class="sd">        :param limit=None:</span>
<span class="sd">          a numerical value which usually renders as a ``LIMIT``</span>
<span class="sd">          expression in the resulting select.  Backends that don&#39;t</span>
<span class="sd">          support ``LIMIT`` will attempt to provide similar</span>
<span class="sd">          functionality.    This parameter is typically specified more naturally</span>
<span class="sd">          using the :meth:`.Select.limit` method on an existing</span>
<span class="sd">          :class:`.Select`.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :meth:`.Select.limit`</span>

<span class="sd">        :param offset=None:</span>
<span class="sd">          a numeric value which usually renders as an ``OFFSET``</span>
<span class="sd">          expression in the resulting select.  Backends that don&#39;t</span>
<span class="sd">          support ``OFFSET`` will attempt to provide similar</span>
<span class="sd">          functionality.  This parameter is typically specified more naturally</span>
<span class="sd">          using the :meth:`.Select.offset` method on an existing</span>
<span class="sd">          :class:`.Select`.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :meth:`.Select.offset`</span>

<span class="sd">        :param order_by:</span>
<span class="sd">          a scalar or list of :class:`.ClauseElement` objects which will</span>
<span class="sd">          comprise the ``ORDER BY`` clause of the resulting select.</span>
<span class="sd">          This parameter is typically specified more naturally using the</span>
<span class="sd">          :meth:`.Select.order_by` method on an existing :class:`.Select`.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :meth:`.Select.order_by`</span>

<span class="sd">        :param use_labels=False:</span>
<span class="sd">          when ``True``, the statement will be generated using labels</span>
<span class="sd">          for each column in the columns clause, which qualify each</span>
<span class="sd">          column with its parent table&#39;s (or aliases) name so that name</span>
<span class="sd">          conflicts between columns in different tables don&#39;t occur.</span>
<span class="sd">          The format of the label is &lt;tablename&gt;_&lt;column&gt;.  The &quot;c&quot;</span>
<span class="sd">          collection of the resulting :class:`.Select` object will use these</span>
<span class="sd">          names as well for targeting column members.</span>

<span class="sd">          This parameter can also be specified on an existing</span>
<span class="sd">          :class:`.Select` object using the :meth:`.Select.apply_labels`</span>
<span class="sd">          method.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :meth:`.Select.apply_labels`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto_correlate</span> <span class="o">=</span> <span class="n">correlate</span>
        <span class="k">if</span> <span class="n">distinct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">distinct</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">_literal_as_text</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">distinct</span><span class="p">)</span>
                <span class="p">]</span>

        <span class="k">if</span> <span class="n">from_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">OrderedSet</span><span class="p">(</span>
                <span class="n">_interpret_as_from</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">from_obj</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">OrderedSet</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">cols_present</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span><span class="s2">&quot;columns argument to select() must &quot;</span>
                                    <span class="s2">&quot;be a Python list or other iterable&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cols_present</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">_interpret_as_column_or_from</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ScalarSelect</span><span class="p">):</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">comma_op</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">whereclause</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_whereclause</span> <span class="o">=</span> <span class="n">_literal_as_text</span><span class="p">(</span>
                <span class="n">whereclause</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">_asbool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_whereclause</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">having</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_having</span> <span class="o">=</span> <span class="n">_literal_as_text</span><span class="p">(</span>
                <span class="n">having</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">_asbool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_having</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">prefixes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setup_prefixes</span><span class="p">(</span><span class="n">prefixes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">suffixes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setup_suffixes</span><span class="p">(</span><span class="n">suffixes</span><span class="p">)</span>

        <span class="n">GenerativeSelect</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_froms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># would love to cache this,</span>
        <span class="c1"># but there&#39;s just enough edge cases, particularly now that</span>
        <span class="c1"># declarative encourages construction of SQL expressions</span>
        <span class="c1"># without tables present, to just regen this each time.</span>
        <span class="n">froms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">translate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_cloned</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="n">_from_objects</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span><span class="p">),</span>
            <span class="n">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_whereclause</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_whereclause</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;select() construct refers to itself as a FROM&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">translate</span> <span class="ow">and</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">translate</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">translate</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">seen</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">_cloned_set</span><span class="p">):</span>
                <span class="n">froms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">_cloned_set</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">froms</span>

    <span class="k">def</span> <span class="nf">_get_display_froms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">explicit_correlate_froms</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                           <span class="n">implicit_correlate_froms</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the full list of &#39;from&#39; clauses to be displayed.</span>

<span class="sd">        Takes into account a set of existing froms which may be</span>
<span class="sd">        rendered in the FROM clause of enclosing selects; this Select</span>
<span class="sd">        may want to leave those absent if it is automatically</span>
<span class="sd">        correlating.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">froms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_froms</span>

        <span class="n">toremove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
            <span class="n">_expand_cloned</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">_hide_froms</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">froms</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">toremove</span><span class="p">:</span>
            <span class="c1"># if we&#39;re maintaining clones of froms,</span>
            <span class="c1"># add the copies out to the toremove list.  only include</span>
            <span class="c1"># clones that are lexical equivalents.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_cloned</span><span class="p">:</span>
                <span class="n">toremove</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_from_cloned</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span>
                    <span class="n">toremove</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_from_cloned</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_cloned</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">_is_lexical_equivalent</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="c1"># filter out to FROM clauses not in the list,</span>
            <span class="c1"># using a list to maintain ordering</span>
            <span class="n">froms</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">froms</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">toremove</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">:</span>
            <span class="n">to_correlate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span>
            <span class="k">if</span> <span class="n">to_correlate</span><span class="p">:</span>
                <span class="n">froms</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">froms</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span>
                    <span class="n">_cloned_intersection</span><span class="p">(</span>
                        <span class="n">_cloned_intersection</span><span class="p">(</span>
                            <span class="n">froms</span><span class="p">,</span> <span class="n">explicit_correlate_froms</span> <span class="ow">or</span> <span class="p">()),</span>
                        <span class="n">to_correlate</span>
                    <span class="p">)</span>
                <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correlate_except</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>

            <span class="n">froms</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">froms</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span>
                <span class="n">_cloned_difference</span><span class="p">(</span>
                    <span class="n">_cloned_intersection</span><span class="p">(</span>
                        <span class="n">froms</span><span class="p">,</span> <span class="n">explicit_correlate_froms</span> <span class="ow">or</span> <span class="p">()),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_correlate_except</span>
                <span class="p">)</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_correlate</span> <span class="ow">and</span> \
                <span class="n">implicit_correlate_froms</span> <span class="ow">and</span> \
                <span class="nb">len</span><span class="p">(</span><span class="n">froms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">froms</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">froms</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span>
                <span class="n">_cloned_intersection</span><span class="p">(</span><span class="n">froms</span><span class="p">,</span> <span class="n">implicit_correlate_froms</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">froms</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s2">&quot;Select statement &#39;</span><span class="si">%s</span><span class="s2">&quot;</span>
                                              <span class="s2">&quot;&#39; returned no FROM clauses &quot;</span>
                                              <span class="s2">&quot;due to auto-correlation; &quot;</span>
                                              <span class="s2">&quot;specify correlate(&lt;tables&gt;) &quot;</span>
                                              <span class="s2">&quot;to control correlation &quot;</span>
                                              <span class="s2">&quot;manually.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">froms</span>

    <span class="k">def</span> <span class="nf">_scalar_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">_select_iterable</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">froms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the displayed list of FromClause elements.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_display_froms</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">with_statement_hint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">dialect_name</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;add a statement hint to this :class:`.Select`.</span>

<span class="sd">        This method is similar to :meth:`.Select.with_hint` except that</span>
<span class="sd">        it does not require an individual table, and instead applies to the</span>
<span class="sd">        statement as a whole.</span>

<span class="sd">        Hints here are specific to the backend database and may include</span>
<span class="sd">        directives such as isolation levels, file directives, fetch directives,</span>
<span class="sd">        etc.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Select.with_hint`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_hint</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">dialect_name</span><span class="p">)</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">with_hint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectable</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">dialect_name</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an indexing or other executional context hint for the given</span>
<span class="sd">        selectable to this :class:`.Select`.</span>

<span class="sd">        The text of the hint is rendered in the appropriate</span>
<span class="sd">        location for the database backend in use, relative</span>
<span class="sd">        to the given :class:`.Table` or :class:`.Alias` passed as the</span>
<span class="sd">        ``selectable`` argument. The dialect implementation</span>
<span class="sd">        typically uses Python string substitution syntax</span>
<span class="sd">        with the token ``%(name)s`` to render the name of</span>
<span class="sd">        the table or alias. E.g. when using Oracle, the</span>
<span class="sd">        following::</span>

<span class="sd">            select([mytable]).\\</span>
<span class="sd">                with_hint(mytable, &quot;index(%(name)s ix_mytable)&quot;)</span>

<span class="sd">        Would render SQL as::</span>

<span class="sd">            select /*+ index(mytable ix_mytable) */ ... from mytable</span>

<span class="sd">        The ``dialect_name`` option will limit the rendering of a particular</span>
<span class="sd">        hint to a particular backend. Such as, to add hints for both Oracle</span>
<span class="sd">        and Sybase simultaneously::</span>

<span class="sd">            select([mytable]).\\</span>
<span class="sd">                with_hint(mytable, &quot;index(%(name)s ix_mytable)&quot;, &#39;oracle&#39;).\\</span>
<span class="sd">                with_hint(mytable, &quot;WITH INDEX ix_mytable&quot;, &#39;sybase&#39;)</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Select.with_statement_hint`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">selectable</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_statement_hints</span> <span class="o">+=</span> <span class="p">((</span><span class="n">dialect_name</span><span class="p">,</span> <span class="n">text</span><span class="p">),</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hints</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                <span class="p">{(</span><span class="n">selectable</span><span class="p">,</span> <span class="n">dialect_name</span><span class="p">):</span> <span class="n">text</span><span class="p">})</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s2">&quot;Select objects don&#39;t have a type.  &quot;</span>
                                      <span class="s2">&quot;Call as_scalar() on this Select &quot;</span>
                                      <span class="s2">&quot;object to return a &#39;scalar&#39; version &quot;</span>
                                      <span class="s2">&quot;of this Select.&quot;</span><span class="p">)</span>

    <span class="nd">@_memoized_property.method</span>
    <span class="k">def</span> <span class="nf">locate_all_froms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a Set of all FromClause elements referenced by this Select.</span>

<span class="sd">        This set is a superset of that returned by the ``froms`` property,</span>
<span class="sd">        which is specifically for those FromClause elements that would</span>
<span class="sd">        actually be rendered.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">froms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_froms</span>
        <span class="k">return</span> <span class="n">froms</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">_from_objects</span><span class="p">(</span><span class="o">*</span><span class="n">froms</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inner_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;an iterator of all ColumnElement expressions which would</span>
<span class="sd">        be rendered into the columns clause of the resulting SELECT statement.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_select_iterables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span><span class="p">)</span>

    <span class="nd">@_memoized_property</span>
    <span class="k">def</span> <span class="nf">_label_resolve_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">with_cols</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">_resolve_label</span> <span class="ow">or</span> <span class="n">c</span><span class="o">.</span><span class="n">_label</span> <span class="ow">or</span> <span class="n">c</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">_select_iterables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">_allow_label_resolve</span><span class="p">)</span>
        <span class="n">only_froms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span>
            <span class="n">_select_iterables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">froms</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">_allow_label_resolve</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">only_froms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">with_cols</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">with_cols</span><span class="p">,</span> <span class="n">only_froms</span>

    <span class="k">def</span> <span class="nf">is_derived_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromclause</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">fromclause</span><span class="o">.</span><span class="n">_cloned_set</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">locate_all_froms</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_derived_from</span><span class="p">(</span><span class="n">fromclause</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Select</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_copy_internals</span><span class="p">(</span><span class="n">clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="c1"># Select() object has been cloned and probably adapted by the</span>
        <span class="c1"># given clone function.  Apply the cloning function to internal</span>
        <span class="c1"># objects</span>

        <span class="c1"># 1. keep a dictionary of the froms we&#39;ve cloned, and what</span>
        <span class="c1"># they&#39;ve become.  This is consulted later when we derive</span>
        <span class="c1"># additional froms from &quot;whereclause&quot; and the columns clause,</span>
        <span class="c1"># which may still reference the uncloned parent table.</span>
        <span class="c1"># as of 0.7.4 we also put the current version of _froms, which</span>
        <span class="c1"># gets cleared on each generation.  previously we were &quot;baking&quot;</span>
        <span class="c1"># _froms into self._from_obj.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_from_cloned</span> <span class="o">=</span> <span class="n">from_cloned</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">clone</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_froms</span><span class="p">))</span>

        <span class="c1"># 3. update persistent _from_obj with the cloned versions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">OrderedSet</span><span class="p">(</span><span class="n">from_cloned</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">)</span>

        <span class="c1"># the _correlate collection is done separately, what can happen</span>
        <span class="c1"># here is the same item is _correlate as in _from_obj but the</span>
        <span class="c1"># _correlate version has an annotation on it - (specifically</span>
        <span class="c1"># RelationshipProperty.Comparator._criterion_exists() does</span>
        <span class="c1"># this). Also keep _correlate liberally open with its previous</span>
        <span class="c1"># contents, as this set is used for matching, not rendering.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">clone</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">)</span>

        <span class="c1"># 4. clone other things.   The difficulty here is that Column</span>
        <span class="c1"># objects are not actually cloned, and refer to their original</span>
        <span class="c1"># .table, resulting in the wrong &quot;from&quot; parent after a clone</span>
        <span class="c1"># operation.  Hence _from_cloned and _from_obj supersede what is</span>
        <span class="c1"># present here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">clone</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="s1">&#39;_whereclause&#39;</span><span class="p">,</span> <span class="s1">&#39;_having&#39;</span><span class="p">,</span> <span class="s1">&#39;_order_by_clause&#39;</span><span class="p">,</span> \
                <span class="s1">&#39;_group_by_clause&#39;</span><span class="p">,</span> <span class="s1">&#39;_for_update_arg&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">clone</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="o">**</span><span class="n">kw</span><span class="p">))</span>

        <span class="c1"># erase exported column list, _froms collection,</span>
        <span class="c1"># etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_exported</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_collections</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return child elements as per the ClauseElement specification.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">column_collections</span> <span class="ow">and</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">or</span> <span class="p">[])</span> <span class="o">+</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_froms</span><span class="p">)</span> <span class="o">+</span> \
            <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_whereclause</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_having</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_order_by_clause</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by_clause</span><span class="p">)</span>
             <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new select() construct with the given column expression</span>
<span class="sd">            added to its columns clause.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

    <span class="nd">@util.dependencies</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.sql.util&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reduce_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sqlutil</span><span class="p">,</span> <span class="n">only_synonyms</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :func`.select` construct with redundantly</span>
<span class="sd">        named, equivalently-valued columns removed from the columns clause.</span>

<span class="sd">        &quot;Redundant&quot; here means two columns where one refers to the</span>
<span class="sd">        other either based on foreign key, or via a simple equality</span>
<span class="sd">        comparison in the WHERE clause of the statement.   The primary purpose</span>
<span class="sd">        of this method is to automatically construct a select statement</span>
<span class="sd">        with all uniquely-named columns, without the need to use</span>
<span class="sd">        table-qualified labels as :meth:`.apply_labels` does.</span>

<span class="sd">        When columns are omitted based on foreign key, the referred-to</span>
<span class="sd">        column is the one that&#39;s kept.  When columns are omitted based on</span>
<span class="sd">        WHERE eqivalence, the first column in the columns clause is the</span>
<span class="sd">        one that&#39;s kept.</span>

<span class="sd">        :param only_synonyms: when True, limit the removal of columns</span>
<span class="sd">         to those which have the same name as the equivalent.   Otherwise,</span>
<span class="sd">         all columns that are equivalent to another are removed.</span>

<span class="sd">        .. versionadded:: 0.8</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_only_columns</span><span class="p">(</span>
            <span class="n">sqlutil</span><span class="o">.</span><span class="n">reduce_columns</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inner_columns</span><span class="p">,</span>
                <span class="n">only_synonyms</span><span class="o">=</span><span class="n">only_synonyms</span><span class="p">,</span>
                <span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_whereclause</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">with_only_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :func:`.select` construct with its columns</span>
<span class="sd">        clause replaced with the given columns.</span>

<span class="sd">        .. versionchanged:: 0.7.3</span>
<span class="sd">            Due to a bug fix, this method has a slight</span>
<span class="sd">            behavioral change as of version 0.7.3.</span>
<span class="sd">            Prior to version 0.7.3, the FROM clause of</span>
<span class="sd">            a :func:`.select` was calculated upfront and as new columns</span>
<span class="sd">            were added; in 0.7.3 and later it&#39;s calculated</span>
<span class="sd">            at compile time, fixing an issue regarding late binding</span>
<span class="sd">            of columns to parent tables.  This changes the behavior of</span>
<span class="sd">            :meth:`.Select.with_only_columns` in that FROM clauses no</span>
<span class="sd">            longer represented in the new list are dropped,</span>
<span class="sd">            but this behavior is more consistent in</span>
<span class="sd">            that the FROM clauses are consistently derived from the</span>
<span class="sd">            current columns clause.  The original intent of this method</span>
<span class="sd">            is to allow trimming of the existing columns list to be fewer</span>
<span class="sd">            columns than originally present; the use case of replacing</span>
<span class="sd">            the columns list with an entirely different one hadn&#39;t</span>
<span class="sd">            been anticipated until 0.7.3 was released; the usage</span>
<span class="sd">            guidelines below illustrate how this should be done.</span>

<span class="sd">        This method is exactly equivalent to as if the original</span>
<span class="sd">        :func:`.select` had been called with the given columns</span>
<span class="sd">        clause.   I.e. a statement::</span>

<span class="sd">            s = select([table1.c.a, table1.c.b])</span>
<span class="sd">            s = s.with_only_columns([table1.c.b])</span>

<span class="sd">        should be exactly equivalent to::</span>

<span class="sd">            s = select([table1.c.b])</span>

<span class="sd">        This means that FROM clauses which are only derived</span>
<span class="sd">        from the column list will be discarded if the new column</span>
<span class="sd">        list no longer contains that FROM::</span>

<span class="sd">            &gt;&gt;&gt; table1 = table(&#39;t1&#39;, column(&#39;a&#39;), column(&#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; table2 = table(&#39;t2&#39;, column(&#39;a&#39;), column(&#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; s1 = select([table1.c.a, table2.c.b])</span>
<span class="sd">            &gt;&gt;&gt; print s1</span>
<span class="sd">            SELECT t1.a, t2.b FROM t1, t2</span>
<span class="sd">            &gt;&gt;&gt; s2 = s1.with_only_columns([table2.c.b])</span>
<span class="sd">            &gt;&gt;&gt; print s2</span>
<span class="sd">            SELECT t2.b FROM t1</span>

<span class="sd">        The preferred way to maintain a specific FROM clause</span>
<span class="sd">        in the construct, assuming it won&#39;t be represented anywhere</span>
<span class="sd">        else (i.e. not in the WHERE clause, etc.) is to set it using</span>
<span class="sd">        :meth:`.Select.select_from`::</span>

<span class="sd">            &gt;&gt;&gt; s1 = select([table1.c.a, table2.c.b]).\\</span>
<span class="sd">            ...         select_from(table1.join(table2,</span>
<span class="sd">            ...                 table1.c.a==table2.c.a))</span>
<span class="sd">            &gt;&gt;&gt; s2 = s1.with_only_columns([table2.c.b])</span>
<span class="sd">            &gt;&gt;&gt; print s2</span>
<span class="sd">            SELECT t2.b FROM t1 JOIN t2 ON t1.a=t2.a</span>

<span class="sd">        Care should also be taken to use the correct</span>
<span class="sd">        set of column objects passed to :meth:`.Select.with_only_columns`.</span>
<span class="sd">        Since the method is essentially equivalent to calling the</span>
<span class="sd">        :func:`.select` construct in the first place with the given</span>
<span class="sd">        columns, the columns passed to :meth:`.Select.with_only_columns`</span>
<span class="sd">        should usually be a subset of those which were passed</span>
<span class="sd">        to the :func:`.select` construct, not those which are available</span>
<span class="sd">        from the ``.c`` collection of that :func:`.select`.  That</span>
<span class="sd">        is::</span>

<span class="sd">            s = select([table1.c.a, table1.c.b]).select_from(table1)</span>
<span class="sd">            s = s.with_only_columns([table1.c.b])</span>

<span class="sd">        and **not**::</span>

<span class="sd">            # usually incorrect</span>
<span class="sd">            s = s.with_only_columns([s.c.b])</span>

<span class="sd">        The latter would produce the SQL::</span>

<span class="sd">            SELECT b</span>
<span class="sd">            FROM (SELECT t1.a AS a, t1.b AS b</span>
<span class="sd">            FROM t1), t1</span>

<span class="sd">        Since the :func:`.select` construct is essentially being</span>
<span class="sd">        asked to select both from ``table1`` as well as itself.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_exported</span><span class="p">()</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">_interpret_as_column_or_from</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ScalarSelect</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">comma_op</span><span class="p">)</span>
            <span class="n">rc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span> <span class="o">=</span> <span class="n">rc</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">whereclause</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new select() construct with the given expression added to</span>
<span class="sd">        its WHERE clause, joined to the existing clause via AND, if any.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">append_whereclause</span><span class="p">(</span><span class="n">whereclause</span><span class="p">)</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">having</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">having</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new select() construct with the given expression added to</span>
<span class="sd">        its HAVING clause, joined to the existing clause via AND, if any.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append_having</span><span class="p">(</span><span class="n">having</span><span class="p">)</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">distinct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new select() construct which will apply DISTINCT to its</span>
<span class="sd">        columns clause.</span>

<span class="sd">        :param \*expr: optional column expressions.  When present,</span>
<span class="sd">         the Postgresql dialect will render a ``DISTINCT ON (&lt;expressions&gt;&gt;)``</span>
<span class="sd">         construct.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">expr</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">_literal_as_label_reference</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">+</span> <span class="n">expr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">select_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromclause</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new :func:`.select` construct with the</span>
<span class="sd">        given FROM expression</span>
<span class="sd">        merged into its list of FROM objects.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            table1 = table(&#39;t1&#39;, column(&#39;a&#39;))</span>
<span class="sd">            table2 = table(&#39;t2&#39;, column(&#39;b&#39;))</span>
<span class="sd">            s = select([table1.c.a]).\\</span>
<span class="sd">                select_from(</span>
<span class="sd">                    table1.join(table2, table1.c.a==table2.c.b)</span>
<span class="sd">                )</span>

<span class="sd">        The &quot;from&quot; list is a unique set on the identity of each element,</span>
<span class="sd">        so adding an already present :class:`.Table` or other selectable</span>
<span class="sd">        will have no effect.   Passing a :class:`.Join` that refers</span>
<span class="sd">        to an already present :class:`.Table` or other selectable will have</span>
<span class="sd">        the effect of concealing the presence of that selectable as</span>
<span class="sd">        an individual element in the rendered FROM list, instead</span>
<span class="sd">        rendering it into a JOIN clause.</span>

<span class="sd">        While the typical purpose of :meth:`.Select.select_from` is to</span>
<span class="sd">        replace the default, derived FROM clause with a join, it can</span>
<span class="sd">        also be called with individual table elements, multiple times</span>
<span class="sd">        if desired, in the case that the FROM clause cannot be fully</span>
<span class="sd">        derived from the columns clause::</span>

<span class="sd">            select([func.count(&#39;*&#39;)]).select_from(table1)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append_from</span><span class="p">(</span><span class="n">fromclause</span><span class="p">)</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fromclauses</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new :class:`.Select` which will correlate the given FROM</span>
<span class="sd">        clauses to that of an enclosing :class:`.Select`.</span>

<span class="sd">        Calling this method turns off the :class:`.Select` object&#39;s</span>
<span class="sd">        default behavior of &quot;auto-correlation&quot;.  Normally, FROM elements</span>
<span class="sd">        which appear in a :class:`.Select` that encloses this one via</span>
<span class="sd">        its :term:`WHERE clause`, ORDER BY, HAVING or</span>
<span class="sd">        :term:`columns clause` will be omitted from this :class:`.Select`</span>
<span class="sd">        object&#39;s :term:`FROM clause`.</span>
<span class="sd">        Setting an explicit correlation collection using the</span>
<span class="sd">        :meth:`.Select.correlate` method provides a fixed list of FROM objects</span>
<span class="sd">        that can potentially take place in this process.</span>

<span class="sd">        When :meth:`.Select.correlate` is used to apply specific FROM clauses</span>
<span class="sd">        for correlation, the FROM elements become candidates for</span>
<span class="sd">        correlation regardless of how deeply nested this :class:`.Select`</span>
<span class="sd">        object is, relative to an enclosing :class:`.Select` which refers to</span>
<span class="sd">        the same FROM object.  This is in contrast to the behavior of</span>
<span class="sd">        &quot;auto-correlation&quot; which only correlates to an immediate enclosing</span>
<span class="sd">        :class:`.Select`.   Multi-level correlation ensures that the link</span>
<span class="sd">        between enclosed and enclosing :class:`.Select` is always via</span>
<span class="sd">        at least one WHERE/ORDER BY/HAVING/columns clause in order for</span>
<span class="sd">        correlation to take place.</span>

<span class="sd">        If ``None`` is passed, the :class:`.Select` object will correlate</span>
<span class="sd">        none of its FROM entries, and all will render unconditionally</span>
<span class="sd">        in the local FROM clause.</span>

<span class="sd">        :param \*fromclauses: a list of one or more :class:`.FromClause`</span>
<span class="sd">         constructs, or other compatible constructs (i.e. ORM-mapped</span>
<span class="sd">         classes) to become part of the correlate collection.</span>

<span class="sd">         .. versionchanged:: 0.8.0 ORM-mapped classes are accepted by</span>
<span class="sd">            :meth:`.Select.correlate`.</span>

<span class="sd">        .. versionchanged:: 0.8.0 The :meth:`.Select.correlate` method no</span>
<span class="sd">           longer unconditionally removes entries from the FROM clause;</span>
<span class="sd">           instead, the candidate FROM entries must also be matched by a FROM</span>
<span class="sd">           entry located in an enclosing :class:`.Select`, which ultimately</span>
<span class="sd">           encloses this one as present in the WHERE clause, ORDER BY clause,</span>
<span class="sd">           HAVING clause, or columns clause of an enclosing :meth:`.Select`.</span>

<span class="sd">        .. versionchanged:: 0.8.2 explicit correlation takes place</span>
<span class="sd">           via any level of nesting of :class:`.Select` objects; in previous</span>
<span class="sd">           0.8 versions, correlation would only occur relative to the</span>
<span class="sd">           immediate enclosing :class:`.Select` construct.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Select.correlate_except`</span>

<span class="sd">            :ref:`correlated_subqueries`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto_correlate</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">fromclauses</span> <span class="ow">and</span> <span class="n">fromclauses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                <span class="n">_interpret_as_from</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fromclauses</span><span class="p">)</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">correlate_except</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fromclauses</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new :class:`.Select` which will omit the given FROM</span>
<span class="sd">        clauses from the auto-correlation process.</span>

<span class="sd">        Calling :meth:`.Select.correlate_except` turns off the</span>
<span class="sd">        :class:`.Select` object&#39;s default behavior of</span>
<span class="sd">        &quot;auto-correlation&quot; for the given FROM elements.  An element</span>
<span class="sd">        specified here will unconditionally appear in the FROM list, while</span>
<span class="sd">        all other FROM elements remain subject to normal auto-correlation</span>
<span class="sd">        behaviors.</span>

<span class="sd">        .. versionchanged:: 0.8.2 The :meth:`.Select.correlate_except`</span>
<span class="sd">           method was improved to fully prevent FROM clauses specified here</span>
<span class="sd">           from being omitted from the immediate FROM clause of this</span>
<span class="sd">           :class:`.Select`.</span>

<span class="sd">        If ``None`` is passed, the :class:`.Select` object will correlate</span>
<span class="sd">        all of its FROM entries.</span>

<span class="sd">        .. versionchanged:: 0.8.2 calling ``correlate_except(None)`` will</span>
<span class="sd">           correctly auto-correlate all FROM clauses.</span>

<span class="sd">        :param \*fromclauses: a list of one or more :class:`.FromClause`</span>
<span class="sd">         constructs, or other compatible constructs (i.e. ORM-mapped</span>
<span class="sd">         classes) to become part of the correlate-exception collection.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Select.correlate`</span>

<span class="sd">            :ref:`correlated_subqueries`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_auto_correlate</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">fromclauses</span> <span class="ow">and</span> <span class="n">fromclauses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_correlate_except</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_correlate_except</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_correlate_except</span> <span class="ow">or</span> <span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                <span class="n">_interpret_as_from</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fromclauses</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromclause</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;append the given correlation expression to this select()</span>
<span class="sd">        construct.</span>

<span class="sd">        This is an **in-place** mutation method; the</span>
<span class="sd">        :meth:`~.Select.correlate` method is preferred, as it provides</span>
<span class="sd">        standard :term:`method chaining`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_auto_correlate</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="n">_interpret_as_from</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fromclause</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;append the given column expression to the columns clause of this</span>
<span class="sd">        select() construct.</span>

<span class="sd">        This is an **in-place** mutation method; the</span>
<span class="sd">        :meth:`~.Select.column` method is preferred, as it provides standard</span>
<span class="sd">        :term:`method chaining`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_exported</span><span class="p">()</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">_interpret_as_column_or_from</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">ScalarSelect</span><span class="p">):</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">comma_op</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span> <span class="o">+</span> <span class="p">[</span><span class="n">column</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">append_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clause</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;append the given columns clause prefix expression to this select()</span>
<span class="sd">        construct.</span>

<span class="sd">        This is an **in-place** mutation method; the</span>
<span class="sd">        :meth:`~.Select.prefix_with` method is preferred, as it provides</span>
<span class="sd">        standard :term:`method chaining`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clause</span> <span class="o">=</span> <span class="n">_literal_as_text</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prefixes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefixes</span> <span class="o">+</span> <span class="p">(</span><span class="n">clause</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">append_whereclause</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">whereclause</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;append the given expression to this select() construct&#39;s WHERE</span>
<span class="sd">        criterion.</span>

<span class="sd">        The expression will be joined to existing WHERE criterion via AND.</span>

<span class="sd">        This is an **in-place** mutation method; the</span>
<span class="sd">        :meth:`~.Select.where` method is preferred, as it provides standard</span>
<span class="sd">        :term:`method chaining`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_exported</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_whereclause</span> <span class="o">=</span> <span class="n">and_</span><span class="p">(</span>
            <span class="n">True_</span><span class="o">.</span><span class="n">_ifnone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_whereclause</span><span class="p">),</span> <span class="n">whereclause</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append_having</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">having</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;append the given expression to this select() construct&#39;s HAVING</span>
<span class="sd">        criterion.</span>

<span class="sd">        The expression will be joined to existing HAVING criterion via AND.</span>

<span class="sd">        This is an **in-place** mutation method; the</span>
<span class="sd">        :meth:`~.Select.having` method is preferred, as it provides standard</span>
<span class="sd">        :term:`method chaining`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_exported</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_having</span> <span class="o">=</span> <span class="n">and_</span><span class="p">(</span><span class="n">True_</span><span class="o">.</span><span class="n">_ifnone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_having</span><span class="p">),</span> <span class="n">having</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromclause</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;append the given FromClause expression to this select() construct&#39;s</span>
<span class="sd">        FROM clause.</span>

<span class="sd">        This is an **in-place** mutation method; the</span>
<span class="sd">        :meth:`~.Select.select_from` method is preferred, as it provides</span>
<span class="sd">        standard :term:`method chaining`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_exported</span><span class="p">()</span>
        <span class="n">fromclause</span> <span class="o">=</span> <span class="n">_interpret_as_from</span><span class="p">(</span><span class="n">fromclause</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="o">.</span><span class="n">union</span><span class="p">([</span><span class="n">fromclause</span><span class="p">])</span>

    <span class="nd">@_memoized_property</span>
    <span class="k">def</span> <span class="nf">_columns_plus_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_labels</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">name_for_col</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">_label</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">_render_label_in_columns_clause</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

                <span class="n">name</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">_label</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">anon_label</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">c</span>

            <span class="k">return</span> <span class="p">[</span>
                <span class="n">name_for_col</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">unique_list</span><span class="p">(</span>
                    <span class="n">_select_iterables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">unique_list</span><span class="p">(</span>
                    <span class="n">_select_iterables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span><span class="p">))</span>
            <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_populate_column_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns_plus_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s1">&#39;_make_proxy&#39;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_labels</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">_key_label</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">anon_label</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="n">c</span><span class="o">.</span><span class="n">_make_proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                          <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                          <span class="n">name_is_truncatable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_refresh_for_new_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fromclause</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_froms</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">fromclause</span><span class="o">.</span><span class="n">_refresh_for_new_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_columns</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cols_populated</span><span class="p">:</span>
                    <span class="n">our_label</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">_key_label</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_labels</span> <span class="k">else</span> <span class="n">col</span><span class="o">.</span><span class="n">key</span>
                    <span class="k">if</span> <span class="n">our_label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">col</span><span class="o">.</span><span class="n">_make_proxy</span><span class="p">(</span>
                            <span class="bp">self</span><span class="p">,</span>
                            <span class="n">name</span><span class="o">=</span><span class="n">col</span><span class="o">.</span><span class="n">_label</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_labels</span> <span class="k">else</span> <span class="bp">None</span><span class="p">,</span>
                            <span class="n">key</span><span class="o">=</span><span class="n">col</span><span class="o">.</span><span class="n">_key_label</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_labels</span> <span class="k">else</span> <span class="bp">None</span><span class="p">,</span>
                            <span class="n">name_is_truncatable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a &#39;grouping&#39; construct as per the ClauseElement</span>
<span class="sd">        specification.</span>

<span class="sd">        This produces an element that can be embedded in an expression. Note</span>
<span class="sd">        that this method is called automatically as needed when constructing</span>
<span class="sd">        expressions and should not require explicit use.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">against</span><span class="p">,</span> <span class="n">CompoundSelect</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">FromGrouping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a SQL UNION of this select() construct against the given</span>
<span class="sd">        selectable.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">CompoundSelect</span><span class="o">.</span><span class="n">_create_union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">union_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a SQL UNION ALL of this select() construct against the given</span>
<span class="sd">        selectable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompoundSelect</span><span class="o">.</span><span class="n">_create_union_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">except_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a SQL EXCEPT of this select() construct against the given</span>
<span class="sd">        selectable.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">CompoundSelect</span><span class="o">.</span><span class="n">_create_except</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">except_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a SQL EXCEPT ALL of this select() construct against the</span>
<span class="sd">        given selectable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompoundSelect</span><span class="o">.</span><span class="n">_create_except_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a SQL INTERSECT of this select() construct against the given</span>
<span class="sd">        selectable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompoundSelect</span><span class="o">.</span><span class="n">_create_intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersect_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a SQL INTERSECT ALL of this select() construct against the</span>
<span class="sd">        given selectable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompoundSelect</span><span class="o">.</span><span class="n">_create_intersect_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span>
        <span class="n">froms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_froms</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">froms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_columns</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">bind</span>
                <span class="k">if</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span> <span class="o">=</span> <span class="n">e</span>
                    <span class="k">return</span> <span class="n">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">froms</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bind</span>
            <span class="k">if</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span> <span class="o">=</span> <span class="n">e</span>
                <span class="k">return</span> <span class="n">e</span>

        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_set_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bind</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span> <span class="o">=</span> <span class="n">bind</span>
    <span class="n">bind</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="n">_set_bind</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ScalarSelect</span><span class="p">(</span><span class="n">Generative</span><span class="p">,</span> <span class="n">Grouping</span><span class="p">):</span>
    <span class="n">_from_objects</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">_is_from_container</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">_scalar_type</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s1">&#39;Scalar Select expression has no &#39;</span>
                                      <span class="s1">&#39;columns; use this object directly &#39;</span>
                                      <span class="s1">&#39;within a column-level expression.&#39;</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">columns</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a WHERE clause to the SELECT statement referred to</span>
<span class="sd">        by this :class:`.ScalarSelect`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">crit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">Exists</span><span class="p">(</span><span class="n">UnaryExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent an ``EXISTS`` clause.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="n">UnaryExpression</span><span class="o">.</span><span class="n">__visit_name__</span>
    <span class="n">_from_objects</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a new :class:`.Exists` against an existing</span>
<span class="sd">        :class:`.Select` object.</span>

<span class="sd">        Calling styles are of the following forms::</span>

<span class="sd">            # use on an existing select()</span>
<span class="sd">            s = select([table.c.col1]).where(table.c.col2==5)</span>
<span class="sd">            s = exists(s)</span>

<span class="sd">            # construct a select() at once</span>
<span class="sd">            exists([&#39;*&#39;], **select_arguments).where(criterion)</span>

<span class="sd">            # columns argument is optional, generates &quot;EXISTS (SELECT *)&quot;</span>
<span class="sd">            # by default.</span>
<span class="sd">            exists().where(table.c.col2==5)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">SelectBase</span><span class="p">,</span> <span class="n">ScalarSelect</span><span class="p">)):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">([</span><span class="n">literal_column</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)],)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">Select</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">()</span><span class="o">.</span><span class="n">self_group</span><span class="p">()</span>

        <span class="n">UnaryExpression</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">exists</span><span class="p">,</span>
                                 <span class="n">type_</span><span class="o">=</span><span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span><span class="p">,</span>
                                 <span class="n">wraps_column_expression</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">whereclause</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Select</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="n">whereclause</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fromclause</span><span class="p">):</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="n">e</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="o">*</span><span class="n">fromclause</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">e</span>

    <span class="k">def</span> <span class="nf">correlate_except</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fromclause</span><span class="p">):</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="n">e</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">correlate_except</span><span class="p">(</span><span class="o">*</span><span class="n">fromclause</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">e</span>

    <span class="k">def</span> <span class="nf">select_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clause</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new :class:`.Exists` construct, applying the given</span>
<span class="sd">        expression to the :meth:`.Select.select_from` method of the select</span>
<span class="sd">        statement contained.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="n">e</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">e</span>

    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clause</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new exists() construct with the given expression added to</span>
<span class="sd">        its WHERE clause, joined to the existing clause via AND, if any.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="n">e</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">e</span>


<span class="k">class</span> <span class="nc">TextAsFrom</span><span class="p">(</span><span class="n">SelectBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrap a :class:`.TextClause` construct within a :class:`.SelectBase`</span>
<span class="sd">    interface.</span>

<span class="sd">    This allows the :class:`.TextClause` object to gain a ``.c`` collection</span>
<span class="sd">    and other FROM-like capabilities such as :meth:`.FromClause.alias`,</span>
<span class="sd">    :meth:`.SelectBase.cte`, etc.</span>

<span class="sd">    The :class:`.TextAsFrom` construct is produced via the</span>
<span class="sd">    :meth:`.TextClause.columns` method - see that method for details.</span>

<span class="sd">    .. versionadded:: 0.9.0</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.text`</span>

<span class="sd">        :meth:`.TextClause.columns`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">&quot;text_as_from&quot;</span>

    <span class="n">_textual</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">text</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_args</span> <span class="o">=</span> <span class="n">columns</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_bind</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">bindparams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">binds</span><span class="p">,</span> <span class="o">**</span><span class="n">bind_as_values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">bindparams</span><span class="p">(</span><span class="o">*</span><span class="n">binds</span><span class="p">,</span> <span class="o">**</span><span class="n">bind_as_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_populate_column_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_args</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">_make_proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_exported</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_scalar_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>


<span class="k">class</span> <span class="nc">AnnotatedFromClause</span><span class="p">(</span><span class="n">Annotated</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># force FromClause to generate their internal</span>
        <span class="c1"># collections into __dict__</span>
        <span class="n">element</span><span class="o">.</span><span class="n">c</span>
        <span class="n">Annotated</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Luca Venturini, Shabhonam Caim.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>