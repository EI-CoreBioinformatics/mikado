<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sqlalchemy.sql.elements &mdash; Mikado 19 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '19',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Mikado 19 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sqlalchemy.sql.elements</h1><div class="highlight"><pre>
<span></span><span class="c1"># sql/elements.py</span>
<span class="c1"># Copyright (C) 2005-2016 the SQLAlchemy authors and contributors</span>
<span class="c1"># &lt;see AUTHORS file&gt;</span>
<span class="c1">#</span>
<span class="c1"># This module is part of SQLAlchemy and is released under</span>
<span class="c1"># the MIT License: http://www.opensource.org/licenses/mit-license.php</span>

<span class="sd">&quot;&quot;&quot;Core SQL expression elements, including :class:`.ClauseElement`,</span>
<span class="sd">:class:`.ColumnElement`, and derived classes.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">util</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">inspection</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">type_api</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">operators</span>
<span class="kn">from</span> <span class="nn">.visitors</span> <span class="kn">import</span> <span class="n">Visitable</span><span class="p">,</span> <span class="n">cloned_traverse</span><span class="p">,</span> <span class="n">traverse</span>
<span class="kn">from</span> <span class="nn">.annotation</span> <span class="kn">import</span> <span class="n">Annotated</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">Executable</span><span class="p">,</span> <span class="n">PARSE_AUTOCOMMIT</span><span class="p">,</span> <span class="n">Immutable</span><span class="p">,</span> <span class="n">NO_ARG</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">_generative</span>
<span class="kn">import</span> <span class="nn">numbers</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">operator</span>


<span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">collate</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">collation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the clause ``expression COLLATE collation``.</span>

<span class="sd">    e.g.::</span>

<span class="sd">        collate(mycolumn, &#39;utf8_bin&#39;)</span>

<span class="sd">    produces::</span>

<span class="sd">        mycolumn COLLATE utf8_bin</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BinaryExpression</span><span class="p">(</span>
        <span class="n">expr</span><span class="p">,</span>
        <span class="n">_literal_as_text</span><span class="p">(</span><span class="n">collation</span><span class="p">),</span>
        <span class="n">operators</span><span class="o">.</span><span class="n">collate</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">between</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Produce a ``BETWEEN`` predicate clause.</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from sqlalchemy import between</span>
<span class="sd">        stmt = select([users_table]).where(between(users_table.c.id, 5, 7))</span>

<span class="sd">    Would produce SQL resembling::</span>

<span class="sd">        SELECT id, name FROM user WHERE id BETWEEN :id_1 AND :id_2</span>

<span class="sd">    The :func:`.between` function is a standalone version of the</span>
<span class="sd">    :meth:`.ColumnElement.between` method available on all</span>
<span class="sd">    SQL expressions, as in::</span>

<span class="sd">        stmt = select([users_table]).where(users_table.c.id.between(5, 7))</span>

<span class="sd">    All arguments passed to :func:`.between`, including the left side</span>
<span class="sd">    column expression, are coerced from Python scalar values if a</span>
<span class="sd">    the value is not a :class:`.ColumnElement` subclass.   For example,</span>
<span class="sd">    three fixed values can be compared as in::</span>

<span class="sd">        print(between(5, 3, 7))</span>

<span class="sd">    Which would produce::</span>

<span class="sd">        :param_1 BETWEEN :param_2 AND :param_3</span>

<span class="sd">    :param expr: a column expression, typically a :class:`.ColumnElement`</span>
<span class="sd">     instance or alternatively a Python scalar expression to be coerced</span>
<span class="sd">     into a column expression, serving as the left side of the ``BETWEEN``</span>
<span class="sd">     expression.</span>

<span class="sd">    :param lower_bound: a column or Python scalar expression serving as the</span>
<span class="sd">     lower bound of the right side of the ``BETWEEN`` expression.</span>

<span class="sd">    :param upper_bound: a column or Python scalar expression serving as the</span>
<span class="sd">     upper bound of the right side of the ``BETWEEN`` expression.</span>

<span class="sd">    :param symmetric: if True, will render &quot; BETWEEN SYMMETRIC &quot;. Note</span>
<span class="sd">     that not all databases support this syntax.</span>

<span class="sd">     .. versionadded:: 0.9.5</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`.ColumnElement.between`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="n">symmetric</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">literal</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a literal clause, bound to a bind parameter.</span>

<span class="sd">    Literal clauses are created automatically when non-</span>
<span class="sd">    :class:`.ClauseElement` objects (such as strings, ints, dates, etc.) are</span>
<span class="sd">    used in a comparison operation with a :class:`.ColumnElement` subclass,</span>
<span class="sd">    such as a :class:`~sqlalchemy.schema.Column` object.  Use this function</span>
<span class="sd">    to force the generation of a literal clause, which will be created as a</span>
<span class="sd">    :class:`BindParameter` with a bound value.</span>

<span class="sd">    :param value: the value to be bound. Can be any Python object supported by</span>
<span class="sd">        the underlying DB-API, or is translatable via the given type argument.</span>

<span class="sd">    :param type\_: an optional :class:`~sqlalchemy.types.TypeEngine` which</span>
<span class="sd">        will provide bind-parameter translation for this literal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">BindParameter</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">type_coerce</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">type_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Associate a SQL expression with a particular type, without rendering</span>
<span class="sd">    ``CAST``.</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from sqlalchemy import type_coerce</span>

<span class="sd">        stmt = select([type_coerce(log_table.date_string, StringDateTime())])</span>

<span class="sd">    The above construct will produce SQL that is usually otherwise unaffected</span>
<span class="sd">    by the :func:`.type_coerce` call::</span>

<span class="sd">        SELECT date_string FROM log</span>

<span class="sd">    However, when result rows are fetched, the ``StringDateTime`` type</span>
<span class="sd">    will be applied to result rows on behalf of the ``date_string`` column.</span>

<span class="sd">    A type that features bound-value handling will also have that behavior</span>
<span class="sd">    take effect when literal values or :func:`.bindparam` constructs are</span>
<span class="sd">    passed to :func:`.type_coerce` as targets.</span>
<span class="sd">    For example, if a type implements the :meth:`.TypeEngine.bind_expression`</span>
<span class="sd">    method or :meth:`.TypeEngine.bind_processor` method or equivalent,</span>
<span class="sd">    these functions will take effect at statement compilation/execution time</span>
<span class="sd">    when a literal value is passed, as in::</span>

<span class="sd">        # bound-value handling of MyStringType will be applied to the</span>
<span class="sd">        # literal value &quot;some string&quot;</span>
<span class="sd">        stmt = select([type_coerce(&quot;some string&quot;, MyStringType)])</span>

<span class="sd">    :func:`.type_coerce` is similar to the :func:`.cast` function,</span>
<span class="sd">    except that it does not render the ``CAST`` expression in the resulting</span>
<span class="sd">    statement.</span>

<span class="sd">    :param expression: A SQL expression, such as a :class:`.ColumnElement`</span>
<span class="sd">     expression or a Python string which will be coerced into a bound literal</span>
<span class="sd">     value.</span>

<span class="sd">    :param type_: A :class:`.TypeEngine` class or instance indicating</span>
<span class="sd">     the type to which the expression is coerced.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.cast`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">type_</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">to_instance</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="s1">&#39;__clause_element__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_coerce</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">(),</span> <span class="n">type_</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">BindParameter</span><span class="p">):</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="n">bp</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_</span>
        <span class="k">return</span> <span class="n">bp</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Visitable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">expression</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Null</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">literal</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Label</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">outparam</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create an &#39;OUT&#39; parameter for usage in functions (stored procedures),</span>
<span class="sd">    for databases which support them.</span>

<span class="sd">    The ``outparam`` can be used like a regular function parameter.</span>
<span class="sd">    The &quot;output&quot; value will be available from the</span>
<span class="sd">    :class:`~sqlalchemy.engine.ResultProxy` object via its ``out_parameters``</span>
<span class="sd">    attribute, which returns a dictionary containing the values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">BindParameter</span><span class="p">(</span>
        <span class="n">key</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">isoutparam</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">not_</span><span class="p">(</span><span class="n">clause</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a negation of the given clause, i.e. ``NOT(clause)``.</span>

<span class="sd">    The ``~`` operator is also overloaded on all</span>
<span class="sd">    :class:`.ColumnElement` subclasses to produce the</span>
<span class="sd">    same result.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">operators</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">clause</span><span class="p">))</span>


<span class="nd">@inspection._self_inspects</span>
<span class="k">class</span> <span class="nc">ClauseElement</span><span class="p">(</span><span class="n">Visitable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for elements of a programmatically constructed SQL</span>
<span class="sd">    expression.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;clause&#39;</span>

    <span class="n">_annotations</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">supports_execution</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">_from_objects</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">bind</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_is_clone_of</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">is_selectable</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_clause_element</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">description</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_order_by_label_element</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_is_from_container</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a shallow copy of this ClauseElement.</span>

<span class="sd">        This method may be used by a generative API.  Its also used as</span>
<span class="sd">        part of the &quot;deep&quot; copy afforded by a traversal that combines</span>
<span class="sd">        the _copy_internals() method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ClauseElement</span><span class="o">.</span><span class="n">_cloned_set</span><span class="o">.</span><span class="n">_reset</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">ColumnElement</span><span class="o">.</span><span class="n">comparator</span><span class="o">.</span><span class="n">_reset</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

        <span class="c1"># this is a marker that helps to &quot;equate&quot; clauses to each other</span>
        <span class="c1"># when a Select returns its list of FROM clauses.  the cloning</span>
        <span class="c1"># process leaves around a lot of remnants of the previous clause</span>
        <span class="c1"># typically in the form of column expressions still attached to the</span>
        <span class="c1"># old table.</span>
        <span class="n">c</span><span class="o">.</span><span class="n">_is_clone_of</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">c</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the &#39;constructor&#39; for this ClauseElement.</span>

<span class="sd">        This is for the purposes for creating a new object of</span>
<span class="sd">        this type.   Usually, its just the element&#39;s __class__.</span>
<span class="sd">        However, the &quot;Annotated&quot; version of the object overrides</span>
<span class="sd">        to return the class of its proxied element.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">_cloned_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the set consisting all cloned ancestors of this</span>
<span class="sd">        ClauseElement.</span>

<span class="sd">        Includes this ClauseElement.  This accessor tends to be used for</span>
<span class="sd">        FromClause objects to identify &#39;equivalent&#39; FROM clauses, regardless</span>
<span class="sd">        of transformative operations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">column_set</span><span class="p">()</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">_is_clone_of</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_is_clone_of&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_annotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a copy of this ClauseElement with annotations</span>
<span class="sd">        updated by the given dictionary.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Annotated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_with_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a copy of this ClauseElement with annotations</span>
<span class="sd">        replaced by the given dictionary.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Annotated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_deannotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a copy of this :class:`.ClauseElement` with annotations</span>
<span class="sd">        removed.</span>

<span class="sd">        :param values: optional tuple of individual values</span>
<span class="sd">         to remove.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">clone</span><span class="p">:</span>
            <span class="c1"># clone is used when we are also copying</span>
            <span class="c1"># the expression for a deep deannotation</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if no clone, since we have no annotations we return</span>
            <span class="c1"># self</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_execute_on_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">connection</span><span class="o">.</span><span class="n">_execute_clauseelement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unique_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">optionaldict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy with :func:`bindparam()` elements replaced.</span>

<span class="sd">        Same functionality as ``params()``, except adds `unique=True`</span>
<span class="sd">        to affected bind parameters so that multiple statements can be</span>
<span class="sd">        used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">optionaldict</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">optionaldict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy with :func:`bindparam()` elements replaced.</span>

<span class="sd">        Returns a copy of this ClauseElement with :func:`bindparam()`</span>
<span class="sd">        elements replaced with values taken from the given dictionary::</span>

<span class="sd">          &gt;&gt;&gt; clause = column(&#39;x&#39;) + bindparam(&#39;foo&#39;)</span>
<span class="sd">          &gt;&gt;&gt; print clause.compile().params</span>
<span class="sd">          {&#39;foo&#39;:None}</span>
<span class="sd">          &gt;&gt;&gt; print clause.params({&#39;foo&#39;:7}).compile().params</span>
<span class="sd">          {&#39;foo&#39;:7}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="n">optionaldict</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unique</span><span class="p">,</span> <span class="n">optionaldict</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">optionaldict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">optionaldict</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">optionaldict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s2">&quot;params() takes zero or one positional dictionary argument&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">visit_bindparam</span><span class="p">(</span><span class="n">bind</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bind</span><span class="o">.</span><span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">bind</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">bind</span><span class="o">.</span><span class="n">key</span><span class="p">]</span>
                <span class="n">bind</span><span class="o">.</span><span class="n">required</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
                <span class="n">bind</span><span class="o">.</span><span class="n">_convert_to_unique</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cloned_traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{</span><span class="s1">&#39;bindparam&#39;</span><span class="p">:</span> <span class="n">visit_bindparam</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare this ClauseElement to the given ClauseElement.</span>

<span class="sd">        Subclasses should override the default behavior, which is a</span>
<span class="sd">        straight identity comparison.</span>

<span class="sd">        \**kw are arguments consumed by subclass compare() methods and</span>
<span class="sd">        may be used to modify the criteria for comparison.</span>
<span class="sd">        (see :class:`.ColumnElement`)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reassign internal elements to be clones of themselves.</span>

<span class="sd">        Called during a copy-and-traverse operation on newly</span>
<span class="sd">        shallow-copied elements to create a deep copy.</span>

<span class="sd">        The given clone function should be used, which may be applying</span>
<span class="sd">        additional transformations to the element (i.e. replacement</span>
<span class="sd">        traversal, cloned traversal, annotations).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return immediate child elements of this :class:`.ClauseElement`.</span>

<span class="sd">        This is used for visit traversal.</span>

<span class="sd">        \**kwargs may contain flags that change the collection that is</span>
<span class="sd">        returned, for example to return a subset of items in order to</span>
<span class="sd">        cut down on larger traversals, or to return child items from a</span>
<span class="sd">        different context (such as schema-level collections instead of</span>
<span class="sd">        clause-level).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a &#39;grouping&#39; to this :class:`.ClauseElement`.</span>

<span class="sd">        This method is overridden by subclasses to return a</span>
<span class="sd">        &quot;grouping&quot; construct, i.e. parenthesis.   In particular</span>
<span class="sd">        it&#39;s used by &quot;binary&quot; expressions to provide a grouping</span>
<span class="sd">        around themselves when placed into a larger expression,</span>
<span class="sd">        as well as by :func:`.select` constructs when placed into</span>
<span class="sd">        the FROM clause of another :func:`.select`.  (Note that</span>
<span class="sd">        subqueries should be normally created using the</span>
<span class="sd">        :meth:`.Select.alias` method, as many platforms require</span>
<span class="sd">        nested SELECT statements to be named).</span>

<span class="sd">        As expressions are composed together, the application of</span>
<span class="sd">        :meth:`self_group` is automatic - end-user code should never</span>
<span class="sd">        need to use this method directly.  Note that SQLAlchemy&#39;s</span>
<span class="sd">        clause constructs take operator precedence into account -</span>
<span class="sd">        so parenthesis might not be needed, for example, in</span>
<span class="sd">        an expression like ``x OR (y AND z)`` - AND takes precedence</span>
<span class="sd">        over OR.</span>

<span class="sd">        The base :meth:`self_group` method of :class:`.ClauseElement`</span>
<span class="sd">        just returns self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@util.dependencies</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.engine.default&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dialect</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compile this SQL expression.</span>

<span class="sd">        The return value is a :class:`~.Compiled` object.</span>
<span class="sd">        Calling ``str()`` or ``unicode()`` on the returned value will yield a</span>
<span class="sd">        string representation of the result. The</span>
<span class="sd">        :class:`~.Compiled` object also can return a</span>
<span class="sd">        dictionary of bind parameter names and values</span>
<span class="sd">        using the ``params`` accessor.</span>

<span class="sd">        :param bind: An ``Engine`` or ``Connection`` from which a</span>
<span class="sd">            ``Compiled`` will be acquired. This argument takes precedence over</span>
<span class="sd">            this :class:`.ClauseElement`&#39;s bound engine, if any.</span>

<span class="sd">        :param column_keys: Used for INSERT and UPDATE statements, a list of</span>
<span class="sd">            column names which should be present in the VALUES clause of the</span>
<span class="sd">            compiled statement. If ``None``, all columns from the target table</span>
<span class="sd">            object are rendered.</span>

<span class="sd">        :param dialect: A ``Dialect`` instance from which a ``Compiled``</span>
<span class="sd">            will be acquired. This argument takes precedence over the `bind`</span>
<span class="sd">            argument as well as this :class:`.ClauseElement`&#39;s bound engine,</span>
<span class="sd">            if any.</span>

<span class="sd">        :param inline: Used for INSERT statements, for a dialect which does</span>
<span class="sd">            not support inline retrieval of newly generated primary key</span>
<span class="sd">            columns, will force the expression used to create the new primary</span>
<span class="sd">            key value to be rendered inline within the INSERT statement&#39;s</span>
<span class="sd">            VALUES clause. This typically refers to Sequence execution but may</span>
<span class="sd">            also refer to any server-side default generation function</span>
<span class="sd">            associated with a primary key `Column`.</span>

<span class="sd">        :param compile_kwargs: optional dictionary of additional parameters</span>
<span class="sd">            that will be passed through to the compiler within all &quot;visit&quot;</span>
<span class="sd">            methods.  This allows any custom flag to be passed through to</span>
<span class="sd">            a custom compilation construct, for example.  It is also used</span>
<span class="sd">            for the case of passing the ``literal_binds`` flag through::</span>

<span class="sd">                from sqlalchemy.sql import table, column, select</span>

<span class="sd">                t = table(&#39;t&#39;, column(&#39;x&#39;))</span>

<span class="sd">                s = select([t]).where(t.c.x == 5)</span>

<span class="sd">                print s.compile(compile_kwargs={&quot;literal_binds&quot;: True})</span>

<span class="sd">            .. versionadded:: 0.9.0</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`faq_sql_expression_string`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dialect</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bind</span><span class="p">:</span>
                <span class="n">dialect</span> <span class="o">=</span> <span class="n">bind</span><span class="o">.</span><span class="n">dialect</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
                <span class="n">dialect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="o">.</span><span class="n">dialect</span>
                <span class="n">bind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dialect</span> <span class="o">=</span> <span class="n">default</span><span class="o">.</span><span class="n">DefaultDialect</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compiler</span><span class="p">(</span><span class="n">dialect</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="n">bind</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compiler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dialect</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a compiler appropriate for this ClauseElement, given a</span>
<span class="sd">        Dialect.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dialect</span><span class="o">.</span><span class="n">statement_compiler</span><span class="p">(</span><span class="n">dialect</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">util</span><span class="o">.</span><span class="n">py3k</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compile</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compile</span><span class="p">())</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="s1">&#39;backslashreplace&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&#39;and&#39; at the ClauseElement level.</span>

<span class="sd">        .. deprecated:: 0.9.5 - conjunctions are intended to be</span>
<span class="sd">           at the :class:`.ColumnElement`. level</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">and_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&#39;or&#39; at the ClauseElement level.</span>

<span class="sd">        .. deprecated:: 0.9.5 - conjunctions are intended to be</span>
<span class="sd">           at the :class:`.ColumnElement`. level</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">or_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;negation_clause&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">negation_clause</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negate</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">inv</span><span class="p">),</span>
            <span class="n">operator</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">inv</span><span class="p">,</span>
            <span class="n">negate</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Boolean value of this clause is not defined&quot;</span><span class="p">)</span>

    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="n">__bool__</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">friendly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span>
        <span class="k">if</span> <span class="n">friendly</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1"> at 0x</span><span class="si">%x</span><span class="s1">; </span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__module__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">friendly</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ColumnElement</span><span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">ColumnOperators</span><span class="p">,</span> <span class="n">ClauseElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a column-oriented SQL expression suitable for usage in the</span>
<span class="sd">    &quot;columns&quot; clause, WHERE clause etc. of a statement.</span>

<span class="sd">    While the most familiar kind of :class:`.ColumnElement` is the</span>
<span class="sd">    :class:`.Column` object, :class:`.ColumnElement` serves as the basis</span>
<span class="sd">    for any unit that may be present in a SQL expression, including</span>
<span class="sd">    the expressions themselves, SQL functions, bound parameters,</span>
<span class="sd">    literal expressions, keywords such as ``NULL``, etc.</span>
<span class="sd">    :class:`.ColumnElement` is the ultimate base class for all such elements.</span>

<span class="sd">    A wide variety of SQLAlchemy Core functions work at the SQL expression</span>
<span class="sd">    level, and are intended to accept instances of :class:`.ColumnElement` as</span>
<span class="sd">    arguments.  These functions will typically document that they accept a</span>
<span class="sd">    &quot;SQL expression&quot; as an argument.  What this means in terms of SQLAlchemy</span>
<span class="sd">    usually refers to an input which is either already in the form of a</span>
<span class="sd">    :class:`.ColumnElement` object, or a value which can be **coerced** into</span>
<span class="sd">    one.  The coercion rules followed by most, but not all, SQLAlchemy Core</span>
<span class="sd">    functions with regards to SQL expressions are as follows:</span>

<span class="sd">        * a literal Python value, such as a string, integer or floating</span>
<span class="sd">          point value, boolean, datetime, ``Decimal`` object, or virtually</span>
<span class="sd">          any other Python object, will be coerced into a &quot;literal bound</span>
<span class="sd">          value&quot;.  This generally means that a :func:`.bindparam` will be</span>
<span class="sd">          produced featuring the given value embedded into the construct; the</span>
<span class="sd">          resulting :class:`.BindParameter` object is an instance of</span>
<span class="sd">          :class:`.ColumnElement`.  The Python value will ultimately be sent</span>
<span class="sd">          to the DBAPI at execution time as a paramterized argument to the</span>
<span class="sd">          ``execute()`` or ``executemany()`` methods, after SQLAlchemy</span>
<span class="sd">          type-specific converters (e.g. those provided by any associated</span>
<span class="sd">          :class:`.TypeEngine` objects) are applied to the value.</span>

<span class="sd">        * any special object value, typically ORM-level constructs, which</span>
<span class="sd">          feature a method called ``__clause_element__()``.  The Core</span>
<span class="sd">          expression system looks for this method when an object of otherwise</span>
<span class="sd">          unknown type is passed to a function that is looking to coerce the</span>
<span class="sd">          argument into a :class:`.ColumnElement` expression.  The</span>
<span class="sd">          ``__clause_element__()`` method, if present, should return a</span>
<span class="sd">          :class:`.ColumnElement` instance.  The primary use of</span>
<span class="sd">          ``__clause_element__()`` within SQLAlchemy is that of class-bound</span>
<span class="sd">          attributes on ORM-mapped classes; a ``User`` class which contains a</span>
<span class="sd">          mapped attribute named ``.name`` will have a method</span>
<span class="sd">          ``User.name.__clause_element__()`` which when invoked returns the</span>
<span class="sd">          :class:`.Column` called ``name`` associated with the mapped table.</span>

<span class="sd">        * The Python ``None`` value is typically interpreted as ``NULL``,</span>
<span class="sd">          which in SQLAlchemy Core produces an instance of :func:`.null`.</span>

<span class="sd">    A :class:`.ColumnElement` provides the ability to generate new</span>
<span class="sd">    :class:`.ColumnElement`</span>
<span class="sd">    objects using Python expressions.  This means that Python operators</span>
<span class="sd">    such as ``==``, ``!=`` and ``&lt;`` are overloaded to mimic SQL operations,</span>
<span class="sd">    and allow the instantiation of further :class:`.ColumnElement` instances</span>
<span class="sd">    which are composed from other, more fundamental :class:`.ColumnElement`</span>
<span class="sd">    objects.  For example, two :class:`.ColumnClause` objects can be added</span>
<span class="sd">    together with the addition operator ``+`` to produce</span>
<span class="sd">    a :class:`.BinaryExpression`.</span>
<span class="sd">    Both :class:`.ColumnClause` and :class:`.BinaryExpression` are subclasses</span>
<span class="sd">    of :class:`.ColumnElement`::</span>

<span class="sd">        &gt;&gt;&gt; from sqlalchemy.sql import column</span>
<span class="sd">        &gt;&gt;&gt; column(&#39;a&#39;) + column(&#39;b&#39;)</span>
<span class="sd">        &lt;sqlalchemy.sql.expression.BinaryExpression object at 0x101029dd0&gt;</span>
<span class="sd">        &gt;&gt;&gt; print column(&#39;a&#39;) + column(&#39;b&#39;)</span>
<span class="sd">        a + b</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :class:`.Column`</span>

<span class="sd">        :func:`.expression.column`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;column&#39;</span>
    <span class="n">primary_key</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">foreign_keys</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">_label</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;The named label that can be used to target</span>
<span class="sd">    this column in a result set.</span>

<span class="sd">    This label is almost always the label used when</span>
<span class="sd">    rendering &lt;expr&gt; AS &lt;label&gt; in a SELECT statement.  It also</span>
<span class="sd">    refers to a name that this column expression can be located from</span>
<span class="sd">    in a result set.</span>

<span class="sd">    For a regular Column bound to a Table, this is typically the label</span>
<span class="sd">    &lt;tablename&gt;_&lt;columnname&gt;.  For other constructs, different rules</span>
<span class="sd">    may apply, such as anonymized labels and others.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">key</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;the &#39;key&#39; that in some circumstances refers to this object in a</span>
<span class="sd">    Python namespace.</span>

<span class="sd">    This typically refers to the &quot;key&quot; of the column as present in the</span>
<span class="sd">    ``.c`` collection of a selectable, e.g. sometable.c[&quot;somekey&quot;] would</span>
<span class="sd">    return a Column with a .key of &quot;somekey&quot;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_key_label</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;A label-based version of &#39;key&#39; that in some circumstances refers</span>
<span class="sd">    to this object in a Python namespace.</span>


<span class="sd">    _key_label comes into play when a select() statement is constructed with</span>
<span class="sd">    apply_labels(); in this case, all Column objects in the ``.c`` collection</span>
<span class="sd">    are rendered as &lt;tablename&gt;_&lt;columnname&gt; in SQL; this is essentially the</span>
<span class="sd">    value of ._label.  But to locate those columns in the ``.c`` collection,</span>
<span class="sd">    the name is along the lines of &lt;tablename&gt;_&lt;key&gt;; that&#39;s the typical</span>
<span class="sd">    value of .key_label.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_render_label_in_columns_clause</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="sd">&quot;&quot;&quot;A flag used by select._columns_plus_names that helps to determine</span>
<span class="sd">    we are actually going to render in terms of &quot;SELECT &lt;col&gt; AS &lt;label&gt;&quot;.</span>
<span class="sd">    This flag can be returned as False for some Column objects that want</span>
<span class="sd">    to be rendered as simple &quot;SELECT &lt;col&gt;&quot;; typically columns that don&#39;t have</span>
<span class="sd">    any parent table and are named the same as what the label would be</span>
<span class="sd">    in any case.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_resolve_label</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;The name that should be used to identify this ColumnElement in a</span>
<span class="sd">    select() object when &quot;label resolution&quot; logic is used; this refers</span>
<span class="sd">    to using a string name in an expression like order_by() or group_by()</span>
<span class="sd">    that wishes to target a labeled expression in the columns clause.</span>

<span class="sd">    The name is distinct from that of .name or ._label to account for the case</span>
<span class="sd">    where anonymizing logic may be used to change the name that&#39;s actually</span>
<span class="sd">    rendered at compile time; this attribute should hold onto the original</span>
<span class="sd">    name that was user-assigned when producing a .label() construct.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_allow_label_resolve</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="sd">&quot;&quot;&quot;A flag that can be flipped to prevent a column from being resolvable</span>
<span class="sd">    by string label name.&quot;&quot;&quot;</span>

    <span class="n">_alt_names</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">against</span> <span class="ow">in</span> <span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">_asbool</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">_type_affinity</span>
                <span class="ow">is</span> <span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span><span class="o">.</span><span class="n">_type_affinity</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">AsBoolean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">istrue</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">isfalse</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">_type_affinity</span> <span class="ow">is</span> <span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span><span class="o">.</span><span class="n">_type_affinity</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AsBoolean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">isfalse</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">istrue</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_negate</span><span class="p">()</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">comparator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">comparator_factory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">comparator_factory</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Object </span><span class="si">%r</span><span class="s2"> associated with &#39;.type&#39; attribute &quot;</span>
                <span class="s2">&quot;is not a TypeEngine class or object&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">comparator_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparator</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s1">&#39;Neither </span><span class="si">%r</span><span class="s1"> object nor </span><span class="si">%r</span><span class="s1"> object has an attribute </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparator</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                    <span class="n">key</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">operate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparator</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reverse_operate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BindParameter</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span>
                             <span class="n">_compared_to_operator</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span>
                             <span class="n">_compared_to_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a column expression.</span>

<span class="sd">        Part of the inspection interface; returns self.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_select_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">)</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">base_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">column_set</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proxy_set</span>
                               <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s1">&#39;_proxies&#39;</span><span class="p">))</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">proxy_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">column_set</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_proxies&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proxies</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">proxy_set</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">shares_lineage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othercolumn</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the given :class:`.ColumnElement`</span>
<span class="sd">        has a common ancestor to this :class:`.ColumnElement`.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proxy_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">othercolumn</span><span class="o">.</span><span class="n">proxy_set</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_compare_name_for_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the given column element compares to this one</span>
<span class="sd">        when targeting within a result row.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">_make_proxy</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">selectable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name_is_truncatable</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new :class:`.ColumnElement` representing this</span>
<span class="sd">        :class:`.ColumnElement` as it appears in the select list of a</span>
<span class="sd">        descending selectable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anon_label</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnsupportedCompilationError</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anon_label</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">co</span> <span class="o">=</span> <span class="n">ColumnClause</span><span class="p">(</span>
            <span class="n">_as_truncated</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">name_is_truncatable</span> <span class="k">else</span> <span class="n">name</span><span class="p">,</span>
            <span class="n">type_</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
            <span class="n">_selectable</span><span class="o">=</span><span class="n">selectable</span>
        <span class="p">)</span>
        <span class="n">co</span><span class="o">.</span><span class="n">_proxies</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">selectable</span><span class="o">.</span><span class="n">_is_clone_of</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">co</span><span class="o">.</span><span class="n">_is_clone_of</span> <span class="o">=</span> \
                <span class="n">selectable</span><span class="o">.</span><span class="n">_is_clone_of</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">selectable</span><span class="o">.</span><span class="n">_columns</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">co</span>
        <span class="k">return</span> <span class="n">co</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">use_proxies</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">equivalents</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare this ColumnElement to another.</span>

<span class="sd">        Special arguments understood:</span>

<span class="sd">        :param use_proxies: when True, consider two columns that</span>
<span class="sd">          share a common base column as equivalent (i.e. shares_lineage())</span>

<span class="sd">        :param equivalents: a dictionary of columns as keys mapped to sets</span>
<span class="sd">          of columns. If the given &quot;other&quot; column is present in this</span>
<span class="sd">          dictionary, if any of the columns in the corresponding set() pass</span>
<span class="sd">          the comparison test, the result is True. This is used to expand the</span>
<span class="sd">          comparison to other columns that may be known to be equivalent to</span>
<span class="sd">          this one via foreign key or other criterion.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_compare</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">equivalents</span> <span class="ow">and</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">equivalents</span><span class="p">:</span>
            <span class="n">to_compare</span> <span class="o">=</span> <span class="n">equivalents</span><span class="p">[</span><span class="n">other</span><span class="p">]</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">to_compare</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">oth</span> <span class="ow">in</span> <span class="n">to_compare</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_proxies</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">shares_lineage</span><span class="p">(</span><span class="n">oth</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="nb">hash</span><span class="p">(</span><span class="n">oth</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a type cast, i.e. ``CAST(&lt;expression&gt; AS &lt;type&gt;)``.</span>

<span class="sd">        This is a shortcut to the :func:`~.expression.cast` function.</span>

<span class="sd">        .. versionadded:: 1.0.7</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a column label, i.e. ``&lt;columnname&gt; AS &lt;name&gt;``.</span>

<span class="sd">        This is a shortcut to the :func:`~.expression.label` function.</span>

<span class="sd">        if &#39;name&#39; is None, an anonymous label name will be generated.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Label</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">anon_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;provides a constant &#39;anonymous label&#39; for this ColumnElement.</span>

<span class="sd">        This is a label() expression which will be named at compile time.</span>
<span class="sd">        The same label() is returned each time anon_label is called so</span>
<span class="sd">        that expressions can reference anon_label multiple times, producing</span>
<span class="sd">        the same label name at compile time.</span>

<span class="sd">        the compiler uses this function automatically at compile time</span>
<span class="sd">        for expressions that are known to be &#39;unnamed&#39; like binary</span>
<span class="sd">        expressions and function calls.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_clone_of</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_clone_of</span>

        <span class="k">return</span> <span class="n">_anonymous_label</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">%%</span><span class="s1">(</span><span class="si">%d</span><span class="s1"> </span><span class="si">%s</span><span class="s1">)s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;anon&#39;</span><span class="p">))</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">BindParameter</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a &quot;bound expression&quot;.</span>

<span class="sd">    :class:`.BindParameter` is invoked explicitly using the</span>
<span class="sd">    :func:`.bindparam` function, as in::</span>

<span class="sd">        from sqlalchemy import bindparam</span>

<span class="sd">        stmt = select([users_table]).\\</span>
<span class="sd">                    where(users_table.c.name == bindparam(&#39;username&#39;))</span>

<span class="sd">    Detailed discussion of how :class:`.BindParameter` is used is</span>
<span class="sd">    at :func:`.bindparam`.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.bindparam`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;bindparam&#39;</span>

    <span class="n">_is_crud</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">NO_ARG</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">unique</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="n">NO_ARG</span><span class="p">,</span>
                 <span class="n">quote</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">callable_</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">isoutparam</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">_compared_to_operator</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">_compared_to_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a &quot;bound expression&quot;.</span>

<span class="sd">        The return value is an instance of :class:`.BindParameter`; this</span>
<span class="sd">        is a :class:`.ColumnElement` subclass which represents a so-called</span>
<span class="sd">        &quot;placeholder&quot; value in a SQL expression, the value of which is</span>
<span class="sd">        supplied at the point at which the statement in executed against a</span>
<span class="sd">        database connection.</span>

<span class="sd">        In SQLAlchemy, the :func:`.bindparam` construct has</span>
<span class="sd">        the ability to carry along the actual value that will be ultimately</span>
<span class="sd">        used at expression time.  In this way, it serves not just as</span>
<span class="sd">        a &quot;placeholder&quot; for eventual population, but also as a means of</span>
<span class="sd">        representing so-called &quot;unsafe&quot; values which should not be rendered</span>
<span class="sd">        directly in a SQL statement, but rather should be passed along</span>
<span class="sd">        to the :term:`DBAPI` as values which need to be correctly escaped</span>
<span class="sd">        and potentially handled for type-safety.</span>

<span class="sd">        When using :func:`.bindparam` explicitly, the use case is typically</span>
<span class="sd">        one of traditional deferment of parameters; the :func:`.bindparam`</span>
<span class="sd">        construct accepts a name which can then be referred to at execution</span>
<span class="sd">        time::</span>

<span class="sd">            from sqlalchemy import bindparam</span>

<span class="sd">            stmt = select([users_table]).\\</span>
<span class="sd">                        where(users_table.c.name == bindparam(&#39;username&#39;))</span>

<span class="sd">        The above statement, when rendered, will produce SQL similar to::</span>

<span class="sd">            SELECT id, name FROM user WHERE name = :username</span>

<span class="sd">        In order to populate the value of ``:username`` above, the value</span>
<span class="sd">        would typically be applied at execution time to a method</span>
<span class="sd">        like :meth:`.Connection.execute`::</span>

<span class="sd">            result = connection.execute(stmt, username=&#39;wendy&#39;)</span>

<span class="sd">        Explicit use of :func:`.bindparam` is also common when producing</span>
<span class="sd">        UPDATE or DELETE statements that are to be invoked multiple times,</span>
<span class="sd">        where the WHERE criterion of the statement is to change on each</span>
<span class="sd">        invocation, such as::</span>

<span class="sd">            stmt = (users_table.update().</span>
<span class="sd">                    where(user_table.c.name == bindparam(&#39;username&#39;)).</span>
<span class="sd">                    values(fullname=bindparam(&#39;fullname&#39;))</span>
<span class="sd">                    )</span>

<span class="sd">            connection.execute(</span>
<span class="sd">                stmt, [{&quot;username&quot;: &quot;wendy&quot;, &quot;fullname&quot;: &quot;Wendy Smith&quot;},</span>
<span class="sd">                       {&quot;username&quot;: &quot;jack&quot;, &quot;fullname&quot;: &quot;Jack Jones&quot;},</span>
<span class="sd">                       ]</span>
<span class="sd">            )</span>

<span class="sd">        SQLAlchemy&#39;s Core expression system makes wide use of</span>
<span class="sd">        :func:`.bindparam` in an implicit sense.   It is typical that Python</span>
<span class="sd">        literal values passed to virtually all SQL expression functions are</span>
<span class="sd">        coerced into fixed :func:`.bindparam` constructs.  For example, given</span>
<span class="sd">        a comparison operation such as::</span>

<span class="sd">            expr = users_table.c.name == &#39;Wendy&#39;</span>

<span class="sd">        The above expression will produce a :class:`.BinaryExpression`</span>
<span class="sd">        construct, where the left side is the :class:`.Column` object</span>
<span class="sd">        representing the ``name`` column, and the right side is a</span>
<span class="sd">        :class:`.BindParameter` representing the literal value::</span>

<span class="sd">            print(repr(expr.right))</span>
<span class="sd">            BindParameter(&#39;%(4327771088 name)s&#39;, &#39;Wendy&#39;, type_=String())</span>

<span class="sd">        The expression above will render SQL such as::</span>

<span class="sd">            user.name = :name_1</span>

<span class="sd">        Where the ``:name_1`` parameter name is an anonymous name.  The</span>
<span class="sd">        actual string ``Wendy`` is not in the rendered string, but is carried</span>
<span class="sd">        along where it is later used within statement execution.  If we</span>
<span class="sd">        invoke a statement like the following::</span>

<span class="sd">            stmt = select([users_table]).where(users_table.c.name == &#39;Wendy&#39;)</span>
<span class="sd">            result = connection.execute(stmt)</span>

<span class="sd">        We would see SQL logging output as::</span>

<span class="sd">            SELECT &quot;user&quot;.id, &quot;user&quot;.name</span>
<span class="sd">            FROM &quot;user&quot;</span>
<span class="sd">            WHERE &quot;user&quot;.name = %(name_1)s</span>
<span class="sd">            {&#39;name_1&#39;: &#39;Wendy&#39;}</span>

<span class="sd">        Above, we see that ``Wendy`` is passed as a parameter to the database,</span>
<span class="sd">        while the placeholder ``:name_1`` is rendered in the appropriate form</span>
<span class="sd">        for the target database, in this case the Postgresql database.</span>

<span class="sd">        Similarly, :func:`.bindparam` is invoked automatically</span>
<span class="sd">        when working with :term:`CRUD` statements as far as the &quot;VALUES&quot;</span>
<span class="sd">        portion is concerned.   The :func:`.insert` construct produces an</span>
<span class="sd">        ``INSERT`` expression which will, at statement execution time,</span>
<span class="sd">        generate bound placeholders based on the arguments passed, as in::</span>

<span class="sd">            stmt = users_table.insert()</span>
<span class="sd">            result = connection.execute(stmt, name=&#39;Wendy&#39;)</span>

<span class="sd">        The above will produce SQL output as::</span>

<span class="sd">            INSERT INTO &quot;user&quot; (name) VALUES (%(name)s)</span>
<span class="sd">            {&#39;name&#39;: &#39;Wendy&#39;}</span>

<span class="sd">        The :class:`.Insert` construct, at compilation/execution time,</span>
<span class="sd">        rendered a single :func:`.bindparam` mirroring the column</span>
<span class="sd">        name ``name`` as a result of the single ``name`` parameter</span>
<span class="sd">        we passed to the :meth:`.Connection.execute` method.</span>

<span class="sd">        :param key:</span>
<span class="sd">          the key (e.g. the name) for this bind param.</span>
<span class="sd">          Will be used in the generated</span>
<span class="sd">          SQL statement for dialects that use named parameters.  This</span>
<span class="sd">          value may be modified when part of a compilation operation,</span>
<span class="sd">          if other :class:`BindParameter` objects exist with the same</span>
<span class="sd">          key, or if its length is too long and truncation is</span>
<span class="sd">          required.</span>

<span class="sd">        :param value:</span>
<span class="sd">          Initial value for this bind param.  Will be used at statement</span>
<span class="sd">          execution time as the value for this parameter passed to the</span>
<span class="sd">          DBAPI, if no other value is indicated to the statement execution</span>
<span class="sd">          method for this particular parameter name.  Defaults to ``None``.</span>

<span class="sd">        :param callable\_:</span>
<span class="sd">          A callable function that takes the place of &quot;value&quot;.  The function</span>
<span class="sd">          will be called at statement execution time to determine the</span>
<span class="sd">          ultimate value.   Used for scenarios where the actual bind</span>
<span class="sd">          value cannot be determined at the point at which the clause</span>
<span class="sd">          construct is created, but embedded bind values are still desirable.</span>

<span class="sd">        :param type\_:</span>
<span class="sd">          A :class:`.TypeEngine` class or instance representing an optional</span>
<span class="sd">          datatype for this :func:`.bindparam`.  If not passed, a type</span>
<span class="sd">          may be determined automatically for the bind, based on the given</span>
<span class="sd">          value; for example, trivial Python types such as ``str``,</span>
<span class="sd">          ``int``, ``bool``</span>
<span class="sd">          may result in the :class:`.String`, :class:`.Integer` or</span>
<span class="sd">          :class:`.Boolean` types being autoamtically selected.</span>

<span class="sd">          The type of a :func:`.bindparam` is significant especially in that</span>
<span class="sd">          the type will apply pre-processing to the value before it is</span>
<span class="sd">          passed to the database.  For example, a :func:`.bindparam` which</span>
<span class="sd">          refers to a datetime value, and is specified as holding the</span>
<span class="sd">          :class:`.DateTime` type, may apply conversion needed to the</span>
<span class="sd">          value (such as stringification on SQLite) before passing the value</span>
<span class="sd">          to the database.</span>

<span class="sd">        :param unique:</span>
<span class="sd">          if True, the key name of this :class:`.BindParameter` will be</span>
<span class="sd">          modified if another :class:`.BindParameter` of the same name</span>
<span class="sd">          already has been located within the containing</span>
<span class="sd">          expression.  This flag is used generally by the internals</span>
<span class="sd">          when producing so-called &quot;anonymous&quot; bound expressions, it</span>
<span class="sd">          isn&#39;t generally applicable to explicitly-named :func:`.bindparam`</span>
<span class="sd">          constructs.</span>

<span class="sd">        :param required:</span>
<span class="sd">          If ``True``, a value is required at execution time.  If not passed,</span>
<span class="sd">          it defaults to ``True`` if neither :paramref:`.bindparam.value`</span>
<span class="sd">          or :paramref:`.bindparam.callable` were passed.  If either of these</span>
<span class="sd">          parameters are present, then :paramref:`.bindparam.required`</span>
<span class="sd">          defaults to ``False``.</span>

<span class="sd">          .. versionchanged:: 0.8 If the ``required`` flag is not specified,</span>
<span class="sd">             it will be set automatically to ``True`` or ``False`` depending</span>
<span class="sd">             on whether or not the ``value`` or ``callable`` parameters</span>
<span class="sd">             were specified.</span>

<span class="sd">        :param quote:</span>
<span class="sd">          True if this parameter name requires quoting and is not</span>
<span class="sd">          currently known as a SQLAlchemy reserved word; this currently</span>
<span class="sd">          only applies to the Oracle backend, where bound names must</span>
<span class="sd">          sometimes be quoted.</span>

<span class="sd">        :param isoutparam:</span>
<span class="sd">          if True, the parameter should be treated like a stored procedure</span>
<span class="sd">          &quot;OUT&quot; parameter.  This applies to backends such as Oracle which</span>
<span class="sd">          support OUT parameters.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`coretutorial_bind_param`</span>

<span class="sd">            :ref:`coretutorial_insert_expressions`</span>

<span class="sd">            :func:`.outparam`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ColumnClause</span><span class="p">):</span>
            <span class="n">type_</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">type</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">key</span>
        <span class="k">if</span> <span class="n">required</span> <span class="ow">is</span> <span class="n">NO_ARG</span><span class="p">:</span>
            <span class="n">required</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="ow">is</span> <span class="n">NO_ARG</span> <span class="ow">and</span> <span class="n">callable_</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">NO_ARG</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">quote</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">quoted_name</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">quote</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">_anonymous_label</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%%</span><span class="s1">(</span><span class="si">%d</span><span class="s1"> </span><span class="si">%s</span><span class="s1">)s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">key</span>
                                                        <span class="ow">or</span> <span class="s1">&#39;param&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">or</span> <span class="n">_anonymous_label</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%%</span><span class="s1">(</span><span class="si">%d</span><span class="s1"> param)s&#39;</span>
                                               <span class="o">%</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># identifying key that won&#39;t change across</span>
        <span class="c1"># clones, used to identify the bind&#39;s logical</span>
        <span class="c1"># identity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_identifying_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span>

        <span class="c1"># key that was passed in the first place, used to</span>
        <span class="c1"># generate new keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_key</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">or</span> <span class="s1">&#39;param&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="n">unique</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callable</span> <span class="o">=</span> <span class="n">callable_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isoutparam</span> <span class="o">=</span> <span class="n">isoutparam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">required</span> <span class="o">=</span> <span class="n">required</span>
        <span class="k">if</span> <span class="n">type_</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_compared_to_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> \
                    <span class="n">_compared_to_type</span><span class="o">.</span><span class="n">coerce_compared_value</span><span class="p">(</span>
                        <span class="n">_compared_to_operator</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">_type_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                                                   <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">type_</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_</span>

    <span class="k">def</span> <span class="nf">_with_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of this :class:`.BindParameter` with the given value</span>
<span class="sd">        set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cloned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">callable</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">required</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">cloned</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span><span class="p">:</span>
            <span class="n">cloned</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">_type_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                                                 <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cloned</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">effective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the value of this bound parameter,</span>
<span class="sd">        taking into account if the ``callable`` parameter</span>
<span class="sd">        was set.</span>

<span class="sd">        The ``callable`` value will be evaluated</span>
<span class="sd">        and returned if present, else ``value``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">callable</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">callable</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">ClauseElement</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">_anonymous_label</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%%</span><span class="s1">(</span><span class="si">%d</span><span class="s1"> </span><span class="si">%s</span><span class="s1">)s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">_orig_key</span>
                                                     <span class="ow">or</span> <span class="s1">&#39;param&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">_convert_to_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">_anonymous_label</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">%%</span><span class="s1">(</span><span class="si">%d</span><span class="s1"> </span><span class="si">%s</span><span class="s1">)s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_key</span> <span class="ow">or</span> <span class="s1">&#39;param&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare this :class:`BindParameter` to the given</span>
<span class="sd">        clause.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BindParameter</span><span class="p">)</span> \
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">_compare_type_affinity</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> \
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;execute a deferred value for serialization purposes.&quot;&quot;&quot;</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">callable</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callable</span><span class="p">()</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;callable&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;BindParameter(</span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">, type_=</span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TypeClause</span><span class="p">(</span><span class="n">ClauseElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Handle a type keyword in a SQL statement.</span>

<span class="sd">    Used by the ``Case`` statement.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;typeclause&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>


<span class="k">class</span> <span class="nc">TextClause</span><span class="p">(</span><span class="n">Executable</span><span class="p">,</span> <span class="n">ClauseElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a literal SQL text fragment.</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from sqlalchemy import text</span>

<span class="sd">        t = text(&quot;SELECT * FROM users&quot;)</span>
<span class="sd">        result = connection.execute(t)</span>


<span class="sd">    The :class:`.Text` construct is produced using the :func:`.text`</span>
<span class="sd">    function; see that function for full documentation.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.text`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;textclause&#39;</span>

    <span class="n">_bind_params_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;(?&lt;![:\w\x5c]):(\w+)(?!:)&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>
    <span class="n">_execution_options</span> <span class="o">=</span> \
        <span class="n">Executable</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="p">{</span><span class="s1">&#39;autocommit&#39;</span><span class="p">:</span> <span class="n">PARSE_AUTOCOMMIT</span><span class="p">})</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_select_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">_hide_froms</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># help in those cases where text() is</span>
    <span class="c1"># interpreted in a column expression situation</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">_label</span> <span class="o">=</span> <span class="n">_resolve_label</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">_allow_label_resolve</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">text</span><span class="p">,</span>
            <span class="n">bind</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span> <span class="o">=</span> <span class="n">bind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">BindParameter</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="s1">&#39;:</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># scan the string and search for bind parameter names, add them</span>
        <span class="c1"># to the list of bindparams</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bind_params_regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bindparams</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">typemap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">autocommit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a new :class:`.TextClause` clause, representing</span>
<span class="sd">        a textual SQL string directly.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import text</span>

<span class="sd">            t = text(&quot;SELECT * FROM users&quot;)</span>
<span class="sd">            result = connection.execute(t)</span>

<span class="sd">        The advantages :func:`.text` provides over a plain string are</span>
<span class="sd">        backend-neutral support for bind parameters, per-statement</span>
<span class="sd">        execution options, as well as</span>
<span class="sd">        bind parameter and result-column typing behavior, allowing</span>
<span class="sd">        SQLAlchemy type constructs to play a role when executing</span>
<span class="sd">        a statement that is specified literally.  The construct can also</span>
<span class="sd">        be provided with a ``.c`` collection of column elements, allowing</span>
<span class="sd">        it to be embedded in other SQL expression constructs as a subquery.</span>

<span class="sd">        Bind parameters are specified by name, using the format ``:name``.</span>
<span class="sd">        E.g.::</span>

<span class="sd">            t = text(&quot;SELECT * FROM users WHERE id=:user_id&quot;)</span>
<span class="sd">            result = connection.execute(t, user_id=12)</span>

<span class="sd">        For SQL statements where a colon is required verbatim, as within</span>
<span class="sd">        an inline string, use a backslash to escape::</span>

<span class="sd">            t = text(&quot;SELECT * FROM users WHERE name=&#39;\\:username&#39;&quot;)</span>

<span class="sd">        The :class:`.TextClause` construct includes methods which can</span>
<span class="sd">        provide information about the bound parameters as well as the column</span>
<span class="sd">        values which would be returned from the textual statement, assuming</span>
<span class="sd">        it&#39;s an executable SELECT type of statement.  The</span>
<span class="sd">        :meth:`.TextClause.bindparams` method is used to provide bound</span>
<span class="sd">        parameter detail, and :meth:`.TextClause.columns` method allows</span>
<span class="sd">        specification of return columns including names and types::</span>

<span class="sd">            t = text(&quot;SELECT * FROM users WHERE id=:user_id&quot;).\\</span>
<span class="sd">                    bindparams(user_id=7).\\</span>
<span class="sd">                    columns(id=Integer, name=String)</span>

<span class="sd">            for id, name in connection.execute(t):</span>
<span class="sd">                print(id, name)</span>

<span class="sd">        The :func:`.text` construct is used in cases when</span>
<span class="sd">        a literal string SQL fragment is specified as part of a larger query,</span>
<span class="sd">        such as for the WHERE clause of a SELECT statement::</span>

<span class="sd">            s = select([users.c.id, users.c.name]).where(text(&quot;id=:user_id&quot;))</span>
<span class="sd">            result = connection.execute(s, user_id=12)</span>

<span class="sd">        :func:`.text` is also used for the construction</span>
<span class="sd">        of a full, standalone statement using plain text.</span>
<span class="sd">        As such, SQLAlchemy refers</span>
<span class="sd">        to it as an :class:`.Executable` object, and it supports</span>
<span class="sd">        the :meth:`Executable.execution_options` method.  For example,</span>
<span class="sd">        a :func:`.text` construct that should be subject to &quot;autocommit&quot;</span>
<span class="sd">        can be set explicitly so using the</span>
<span class="sd">        :paramref:`.Connection.execution_options.autocommit` option::</span>

<span class="sd">            t = text(&quot;EXEC my_procedural_thing()&quot;).\\</span>
<span class="sd">                    execution_options(autocommit=True)</span>

<span class="sd">        Note that SQLAlchemy&#39;s usual &quot;autocommit&quot; behavior applies to</span>
<span class="sd">        :func:`.text` constructs implicitly - that is, statements which begin</span>
<span class="sd">        with a phrase such as ``INSERT``, ``UPDATE``, ``DELETE``,</span>
<span class="sd">        or a variety of other phrases specific to certain backends, will</span>
<span class="sd">        be eligible for autocommit if no transaction is in progress.</span>

<span class="sd">        :param text:</span>
<span class="sd">          the text of the SQL statement to be created.  use ``:&lt;param&gt;``</span>
<span class="sd">          to specify bind parameters; they will be compiled to their</span>
<span class="sd">          engine-specific format.</span>

<span class="sd">        :param autocommit:</span>
<span class="sd">          Deprecated.  Use .execution_options(autocommit=&lt;True|False&gt;)</span>
<span class="sd">          to set the autocommit option.</span>

<span class="sd">        :param bind:</span>
<span class="sd">          an optional connection or engine to be used for this text query.</span>

<span class="sd">        :param bindparams:</span>
<span class="sd">          Deprecated.  A list of :func:`.bindparam` instances used to</span>
<span class="sd">          provide information about parameters embedded in the statement.</span>
<span class="sd">          This argument now invokes the :meth:`.TextClause.bindparams`</span>
<span class="sd">          method on the construct before returning it.  E.g.::</span>

<span class="sd">              stmt = text(&quot;SELECT * FROM table WHERE id=:id&quot;,</span>
<span class="sd">                        bindparams=[bindparam(&#39;id&#39;, value=5, type_=Integer)])</span>

<span class="sd">          Is equivalent to::</span>

<span class="sd">              stmt = text(&quot;SELECT * FROM table WHERE id=:id&quot;).\\</span>
<span class="sd">                        bindparams(bindparam(&#39;id&#39;, value=5, type_=Integer))</span>

<span class="sd">          .. deprecated:: 0.9.0 the :meth:`.TextClause.bindparams` method</span>
<span class="sd">             supersedes the ``bindparams`` argument to :func:`.text`.</span>

<span class="sd">        :param typemap:</span>
<span class="sd">          Deprecated.  A dictionary mapping the names of columns</span>
<span class="sd">          represented in the columns clause of a ``SELECT`` statement</span>
<span class="sd">          to type objects,</span>
<span class="sd">          which will be used to perform post-processing on columns within</span>
<span class="sd">          the result set.  This parameter now invokes the</span>
<span class="sd">          :meth:`.TextClause.columns` method, which returns a</span>
<span class="sd">          :class:`.TextAsFrom` construct that gains a ``.c`` collection and</span>
<span class="sd">          can be embedded in other expressions.  E.g.::</span>

<span class="sd">              stmt = text(&quot;SELECT * FROM table&quot;,</span>
<span class="sd">                            typemap={&#39;id&#39;: Integer, &#39;name&#39;: String},</span>
<span class="sd">                        )</span>

<span class="sd">          Is equivalent to::</span>

<span class="sd">              stmt = text(&quot;SELECT * FROM table&quot;).columns(id=Integer,</span>
<span class="sd">                                                         name=String)</span>

<span class="sd">          Or alternatively::</span>

<span class="sd">              from sqlalchemy.sql import column</span>
<span class="sd">              stmt = text(&quot;SELECT * FROM table&quot;).columns(</span>
<span class="sd">                                    column(&#39;id&#39;, Integer),</span>
<span class="sd">                                    column(&#39;name&#39;, String)</span>
<span class="sd">                                )</span>

<span class="sd">          .. deprecated:: 0.9.0 the :meth:`.TextClause.columns` method</span>
<span class="sd">             supersedes the ``typemap`` argument to :func:`.text`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stmt</span> <span class="o">=</span> <span class="n">TextClause</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="n">bind</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bindparams</span><span class="p">:</span>
            <span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">bindparams</span><span class="p">(</span><span class="o">*</span><span class="n">bindparams</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">typemap</span><span class="p">:</span>
            <span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span><span class="o">**</span><span class="n">typemap</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">autocommit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span><span class="s1">&#39;autocommit on text() is deprecated.  &#39;</span>
                                 <span class="s1">&#39;Use .execution_options(autocommit=True)&#39;</span><span class="p">)</span>
            <span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">autocommit</span><span class="o">=</span><span class="n">autocommit</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stmt</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">bindparams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">binds</span><span class="p">,</span> <span class="o">**</span><span class="n">names_to_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Establish the values and/or types of bound parameters within</span>
<span class="sd">        this :class:`.TextClause` construct.</span>

<span class="sd">        Given a text construct such as::</span>

<span class="sd">            from sqlalchemy import text</span>
<span class="sd">            stmt = text(&quot;SELECT id, name FROM user WHERE name=:name &quot;</span>
<span class="sd">                        &quot;AND timestamp=:timestamp&quot;)</span>

<span class="sd">        the :meth:`.TextClause.bindparams` method can be used to establish</span>
<span class="sd">        the initial value of ``:name`` and ``:timestamp``,</span>
<span class="sd">        using simple keyword arguments::</span>

<span class="sd">            stmt = stmt.bindparams(name=&#39;jack&#39;,</span>
<span class="sd">                        timestamp=datetime.datetime(2012, 10, 8, 15, 12, 5))</span>

<span class="sd">        Where above, new :class:`.BindParameter` objects</span>
<span class="sd">        will be generated with the names ``name`` and ``timestamp``, and</span>
<span class="sd">        values of ``jack`` and ``datetime.datetime(2012, 10, 8, 15, 12, 5)``,</span>
<span class="sd">        respectively.  The types will be</span>
<span class="sd">        inferred from the values given, in this case :class:`.String` and</span>
<span class="sd">        :class:`.DateTime`.</span>

<span class="sd">        When specific typing behavior is needed, the positional ``*binds``</span>
<span class="sd">        argument can be used in which to specify :func:`.bindparam` constructs</span>
<span class="sd">        directly.  These constructs must include at least the ``key``</span>
<span class="sd">        argument, then an optional value and type::</span>

<span class="sd">            from sqlalchemy import bindparam</span>
<span class="sd">            stmt = stmt.bindparams(</span>
<span class="sd">                            bindparam(&#39;name&#39;, value=&#39;jack&#39;, type_=String),</span>
<span class="sd">                            bindparam(&#39;timestamp&#39;, type_=DateTime)</span>
<span class="sd">                        )</span>

<span class="sd">        Above, we specified the type of :class:`.DateTime` for the</span>
<span class="sd">        ``timestamp`` bind, and the type of :class:`.String` for the ``name``</span>
<span class="sd">        bind.  In the case of ``name`` we also set the default value of</span>
<span class="sd">        ``&quot;jack&quot;``.</span>

<span class="sd">        Additional bound parameters can be supplied at statement execution</span>
<span class="sd">        time, e.g.::</span>

<span class="sd">            result = connection.execute(stmt,</span>
<span class="sd">                        timestamp=datetime.datetime(2012, 10, 8, 15, 12, 5))</span>

<span class="sd">        The :meth:`.TextClause.bindparams` method can be called repeatedly,</span>
<span class="sd">        where it will re-use existing :class:`.BindParameter` objects to add</span>
<span class="sd">        new information.  For example, we can call</span>
<span class="sd">        :meth:`.TextClause.bindparams` first with typing information, and a</span>
<span class="sd">        second time with value information, and it will be combined::</span>

<span class="sd">            stmt = text(&quot;SELECT id, name FROM user WHERE name=:name &quot;</span>
<span class="sd">                        &quot;AND timestamp=:timestamp&quot;)</span>
<span class="sd">            stmt = stmt.bindparams(</span>
<span class="sd">                bindparam(&#39;name&#39;, type_=String),</span>
<span class="sd">                bindparam(&#39;timestamp&#39;, type_=DateTime)</span>
<span class="sd">            )</span>
<span class="sd">            stmt = stmt.bindparams(</span>
<span class="sd">                name=&#39;jack&#39;,</span>
<span class="sd">                timestamp=datetime.datetime(2012, 10, 8, 15, 12, 5)</span>
<span class="sd">            )</span>


<span class="sd">        .. versionadded:: 0.9.0 The :meth:`.TextClause.bindparams` method</span>
<span class="sd">           supersedes the argument ``bindparams`` passed to</span>
<span class="sd">           :func:`~.expression.text`.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span> <span class="o">=</span> <span class="n">new_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">bind</span> <span class="ow">in</span> <span class="n">binds</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">existing</span> <span class="o">=</span> <span class="n">new_params</span><span class="p">[</span><span class="n">bind</span><span class="o">.</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                    <span class="s2">&quot;This text() construct doesn&#39;t define a &quot;</span>
                    <span class="s2">&quot;bound parameter named </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">bind</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_params</span><span class="p">[</span><span class="n">existing</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">names_to_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">existing</span> <span class="o">=</span> <span class="n">new_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                    <span class="s2">&quot;This text() construct doesn&#39;t define a &quot;</span>
                    <span class="s2">&quot;bound parameter named </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">_with_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@util.dependencies</span><span class="p">(</span><span class="s1">&#39;sqlalchemy.sql.selectable&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectable</span><span class="p">,</span> <span class="o">*</span><span class="n">cols</span><span class="p">,</span> <span class="o">**</span><span class="n">types</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn this :class:`.TextClause` object into a :class:`.TextAsFrom`</span>
<span class="sd">        object that can be embedded into another statement.</span>

<span class="sd">        This function essentially bridges the gap between an entirely</span>
<span class="sd">        textual SELECT statement and the SQL expression language concept</span>
<span class="sd">        of a &quot;selectable&quot;::</span>

<span class="sd">            from sqlalchemy.sql import column, text</span>

<span class="sd">            stmt = text(&quot;SELECT id, name FROM some_table&quot;)</span>
<span class="sd">            stmt = stmt.columns(column(&#39;id&#39;), column(&#39;name&#39;)).alias(&#39;st&#39;)</span>

<span class="sd">            stmt = select([mytable]).\\</span>
<span class="sd">                    select_from(</span>
<span class="sd">                        mytable.join(stmt, mytable.c.name == stmt.c.name)</span>
<span class="sd">                    ).where(stmt.c.id &gt; 5)</span>

<span class="sd">        Above, we used untyped :func:`.column` elements.  These can also have</span>
<span class="sd">        types specified, which will impact how the column behaves in</span>
<span class="sd">        expressions as well as determining result set behavior::</span>

<span class="sd">            stmt = text(&quot;SELECT id, name, timestamp FROM some_table&quot;)</span>
<span class="sd">            stmt = stmt.columns(</span>
<span class="sd">                        column(&#39;id&#39;, Integer),</span>
<span class="sd">                        column(&#39;name&#39;, Unicode),</span>
<span class="sd">                        column(&#39;timestamp&#39;, DateTime)</span>
<span class="sd">                    )</span>

<span class="sd">            for id, name, timestamp in connection.execute(stmt):</span>
<span class="sd">                print(id, name, timestamp)</span>

<span class="sd">        Keyword arguments allow just the names and types of columns to be</span>
<span class="sd">        specified, where the :func:`.column` elements will be generated</span>
<span class="sd">        automatically::</span>

<span class="sd">            stmt = text(&quot;SELECT id, name, timestamp FROM some_table&quot;)</span>
<span class="sd">            stmt = stmt.columns(</span>
<span class="sd">                        id=Integer,</span>
<span class="sd">                        name=Unicode,</span>
<span class="sd">                        timestamp=DateTime</span>
<span class="sd">                    )</span>

<span class="sd">            for id, name, timestamp in connection.execute(stmt):</span>
<span class="sd">                print(id, name, timestamp)</span>

<span class="sd">        The :meth:`.TextClause.columns` method provides a direct</span>
<span class="sd">        route to calling :meth:`.FromClause.alias` as well as</span>
<span class="sd">        :meth:`.SelectBase.cte` against a textual SELECT statement::</span>

<span class="sd">            stmt = stmt.columns(id=Integer, name=String).cte(&#39;st&#39;)</span>

<span class="sd">            stmt = select([sometable]).where(sometable.c.id == stmt.c.id)</span>

<span class="sd">        .. versionadded:: 0.9.0 :func:`.text` can now be converted into a</span>
<span class="sd">           fully featured &quot;selectable&quot; construct using the</span>
<span class="sd">           :meth:`.TextClause.columns` method.  This method supersedes the</span>
<span class="sd">           ``typemap`` argument to :func:`.text`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">input_cols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">ColumnClause</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">key</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">key</span> <span class="ow">in</span> <span class="n">types</span>
            <span class="k">else</span> <span class="n">col</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span>
        <span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">ColumnClause</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">type_</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">type_</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">selectable</span><span class="o">.</span><span class="n">TextAsFrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_cols</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">comparator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">comparator_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">against</span> <span class="ow">is</span> <span class="n">operators</span><span class="o">.</span><span class="n">in_op</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Grouping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">b</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">clone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TextClause</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span>


<span class="k">class</span> <span class="nc">Null</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the NULL keyword in a SQL statement.</span>

<span class="sd">    :class:`.Null` is accessed as a constant via the</span>
<span class="sd">    :func:`.null` function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;null&#39;</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_instance</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a constant :class:`.Null` construct.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Null</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Null</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">False_</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the ``false`` keyword, or equivalent, in a SQL statement.</span>

<span class="sd">    :class:`.False_` is accessed as a constant via the</span>
<span class="sd">    :func:`.false` function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;false&#39;</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">True_</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_instance</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`.False_` construct.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            &gt;&gt;&gt; from sqlalchemy import false</span>
<span class="sd">            &gt;&gt;&gt; print select([t.c.x]).where(false())</span>
<span class="sd">            SELECT x FROM t WHERE false</span>

<span class="sd">        A backend which does not support true/false constants will render as</span>
<span class="sd">        an expression against 1 or 0::</span>

<span class="sd">            &gt;&gt;&gt; print select([t.c.x]).where(false())</span>
<span class="sd">            SELECT x FROM t WHERE 0 = 1</span>

<span class="sd">        The :func:`.true` and :func:`.false` constants also feature</span>
<span class="sd">        &quot;short circuit&quot; operation within an :func:`.and_` or :func:`.or_`</span>
<span class="sd">        conjunction::</span>

<span class="sd">            &gt;&gt;&gt; print select([t.c.x]).where(or_(t.c.x &gt; 5, true()))</span>
<span class="sd">            SELECT x FROM t WHERE true</span>

<span class="sd">            &gt;&gt;&gt; print select([t.c.x]).where(and_(t.c.x &gt; 5, false()))</span>
<span class="sd">            SELECT x FROM t WHERE false</span>

<span class="sd">        .. versionchanged:: 0.9 :func:`.true` and :func:`.false` feature</span>
<span class="sd">           better integrated behavior within conjunctions and on dialects</span>
<span class="sd">           that don&#39;t support true/false constants.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.true`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">False_</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">False_</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">True_</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the ``true`` keyword, or equivalent, in a SQL statement.</span>

<span class="sd">    :class:`.True_` is accessed as a constant via the</span>
<span class="sd">    :func:`.true` function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;true&#39;</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">False_</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_ifnone</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_instance</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_instance</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a constant :class:`.True_` construct.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            &gt;&gt;&gt; from sqlalchemy import true</span>
<span class="sd">            &gt;&gt;&gt; print select([t.c.x]).where(true())</span>
<span class="sd">            SELECT x FROM t WHERE true</span>

<span class="sd">        A backend which does not support true/false constants will render as</span>
<span class="sd">        an expression against 1 or 0::</span>

<span class="sd">            &gt;&gt;&gt; print select([t.c.x]).where(true())</span>
<span class="sd">            SELECT x FROM t WHERE 1 = 1</span>

<span class="sd">        The :func:`.true` and :func:`.false` constants also feature</span>
<span class="sd">        &quot;short circuit&quot; operation within an :func:`.and_` or :func:`.or_`</span>
<span class="sd">        conjunction::</span>

<span class="sd">            &gt;&gt;&gt; print select([t.c.x]).where(or_(t.c.x &gt; 5, true()))</span>
<span class="sd">            SELECT x FROM t WHERE true</span>

<span class="sd">            &gt;&gt;&gt; print select([t.c.x]).where(and_(t.c.x &gt; 5, false()))</span>
<span class="sd">            SELECT x FROM t WHERE false</span>

<span class="sd">        .. versionchanged:: 0.9 :func:`.true` and :func:`.false` feature</span>
<span class="sd">           better integrated behavior within conjunctions and on dialects</span>
<span class="sd">           that don&#39;t support true/false constants.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.false`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">True_</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">True_</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ClauseList</span><span class="p">(</span><span class="n">ClauseElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Describe a list of clauses, separated by an operator.</span>

<span class="sd">    By default, is comma-separated, such as a column listing.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;clauselist&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;operator&#39;</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">comma_op</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;group&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_contents</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;group_contents&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">text_converter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
            <span class="s1">&#39;_literal_as_text&#39;</span><span class="p">,</span>
            <span class="n">_expression_literal_as_text</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_contents</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">text_converter</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="n">clauses</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">text_converter</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="n">clauses</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_select_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clause</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_contents</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_literal_as_text</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span><span class="o">.</span>
                                <span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_literal_as_text</span><span class="p">(</span><span class="n">clause</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span> <span class="o">=</span> <span class="p">[</span><span class="n">clone</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_from_objects</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="ow">and</span> <span class="n">operators</span><span class="o">.</span><span class="n">is_precedent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">against</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Grouping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare this :class:`.ClauseList` to the given :class:`.ClauseList`,</span>
<span class="sd">        including a comparison of all the clause items.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ClauseList</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ClauseList</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">clauses</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">operator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>


<span class="k">class</span> <span class="nc">BooleanClauseList</span><span class="p">(</span><span class="n">ClauseList</span><span class="p">,</span> <span class="n">ColumnElement</span><span class="p">):</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;clauselist&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;BooleanClauseList has a private constructor&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_construct</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">continue_on</span><span class="p">,</span> <span class="n">skip_on</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">convert_clauses</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">clauses</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">_expression_literal_as_text</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span>
            <span class="n">util</span><span class="o">.</span><span class="n">coerce_generator_arg</span><span class="p">(</span><span class="n">clauses</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="n">clauses</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">continue_on</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">skip_on</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">clause</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">_asbool</span><span class="p">)</span>

            <span class="n">convert_clauses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">convert_clauses</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">convert_clauses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">_asbool</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">convert_clauses</span> <span class="ow">and</span> <span class="n">clauses</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">clauses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">_asbool</span><span class="p">)</span>

        <span class="n">convert_clauses</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">convert_clauses</span><span class="p">]</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span> <span class="o">=</span> <span class="n">convert_clauses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_contents</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">and_</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a conjunction of expressions joined by ``AND``.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import and_</span>

<span class="sd">            stmt = select([users_table]).where(</span>
<span class="sd">                            and_(</span>
<span class="sd">                                users_table.c.name == &#39;wendy&#39;,</span>
<span class="sd">                                users_table.c.enrolled == True</span>
<span class="sd">                            )</span>
<span class="sd">                        )</span>

<span class="sd">        The :func:`.and_` conjunction is also available using the</span>
<span class="sd">        Python ``&amp;`` operator (though note that compound expressions</span>
<span class="sd">        need to be parenthesized in order to function with Python</span>
<span class="sd">        operator precedence behavior)::</span>

<span class="sd">            stmt = select([users_table]).where(</span>
<span class="sd">                            (users_table.c.name == &#39;wendy&#39;) &amp;</span>
<span class="sd">                            (users_table.c.enrolled == True)</span>
<span class="sd">                        )</span>

<span class="sd">        The :func:`.and_` operation is also implicit in some cases;</span>
<span class="sd">        the :meth:`.Select.where` method for example can be invoked multiple</span>
<span class="sd">        times against a statement, which will have the effect of each</span>
<span class="sd">        clause being combined using :func:`.and_`::</span>

<span class="sd">            stmt = select([users_table]).\\</span>
<span class="sd">                        where(users_table.c.name == &#39;wendy&#39;).\\</span>
<span class="sd">                        where(users_table.c.enrolled == True)</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.or_`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_construct</span><span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span> <span class="n">True_</span><span class="p">,</span> <span class="n">False_</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">or_</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a conjunction of expressions joined by ``OR``.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import or_</span>

<span class="sd">            stmt = select([users_table]).where(</span>
<span class="sd">                            or_(</span>
<span class="sd">                                users_table.c.name == &#39;wendy&#39;,</span>
<span class="sd">                                users_table.c.name == &#39;jack&#39;</span>
<span class="sd">                            )</span>
<span class="sd">                        )</span>

<span class="sd">        The :func:`.or_` conjunction is also available using the</span>
<span class="sd">        Python ``|`` operator (though note that compound expressions</span>
<span class="sd">        need to be parenthesized in order to function with Python</span>
<span class="sd">        operator precedence behavior)::</span>

<span class="sd">            stmt = select([users_table]).where(</span>
<span class="sd">                            (users_table.c.name == &#39;wendy&#39;) |</span>
<span class="sd">                            (users_table.c.name == &#39;jack&#39;)</span>
<span class="sd">                        )</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.and_`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_construct</span><span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">False_</span><span class="p">,</span> <span class="n">True_</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_select_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BooleanClauseList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">against</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ClauseList</span><span class="o">.</span><span class="n">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="n">and_</span> <span class="o">=</span> <span class="n">BooleanClauseList</span><span class="o">.</span><span class="n">and_</span>
<span class="n">or_</span> <span class="o">=</span> <span class="n">BooleanClauseList</span><span class="o">.</span><span class="n">or_</span>


<span class="k">class</span> <span class="nc">Tuple</span><span class="p">(</span><span class="n">ClauseList</span><span class="p">,</span> <span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a SQL tuple.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`.Tuple`.</span>

<span class="sd">        Main usage is to produce a composite IN construct::</span>

<span class="sd">            from sqlalchemy import tuple_</span>

<span class="sd">            tuple_(table.c.col1, table.c.col2).in_(</span>
<span class="sd">                [(1, 2), (5, 12), (10, 19)]</span>
<span class="sd">            )</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The composite IN construct is not supported by all backends,</span>
<span class="sd">            and is currently known to work on Postgresql and MySQL,</span>
<span class="sd">            but not SQLite.   Unsupported backends will raise</span>
<span class="sd">            a subclass of :class:`~sqlalchemy.exc.DBAPIError` when such</span>
<span class="sd">            an expression is invoked.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">clauses</span> <span class="o">=</span> <span class="p">[</span><span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clauses</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type_tuple</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">clauses</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;type_&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                           <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_tuple</span> <span class="k">else</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Tuple</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">clauses</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_select_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
            <span class="n">BindParameter</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">_compared_to_operator</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span>
                          <span class="n">_compared_to_type</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">type_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_tuple</span><span class="p">)</span>
        <span class="p">])</span><span class="o">.</span><span class="n">self_group</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Case</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a ``CASE`` expression.</span>

<span class="sd">    :class:`.Case` is produced using the :func:`.case` factory function,</span>
<span class="sd">    as in::</span>

<span class="sd">        from sqlalchemy import case</span>

<span class="sd">        stmt = select([users_table]).\\</span>
<span class="sd">                    where(</span>
<span class="sd">                        case(</span>
<span class="sd">                            [</span>
<span class="sd">                                (users_table.c.name == &#39;wendy&#39;, &#39;W&#39;),</span>
<span class="sd">                                (users_table.c.name == &#39;jack&#39;, &#39;J&#39;)</span>
<span class="sd">                            ],</span>
<span class="sd">                            else_=&#39;E&#39;</span>
<span class="sd">                        )</span>
<span class="sd">                    )</span>

<span class="sd">    Details on :class:`.Case` usage is at :func:`.case`.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.case`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;case&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">whens</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">else_</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a ``CASE`` expression.</span>

<span class="sd">        The ``CASE`` construct in SQL is a conditional object that</span>
<span class="sd">        acts somewhat analogously to an &quot;if/then&quot; construct in other</span>
<span class="sd">        languages.  It returns an instance of :class:`.Case`.</span>

<span class="sd">        :func:`.case` in its usual form is passed a list of &quot;when&quot;</span>
<span class="sd">        constructs, that is, a list of conditions and results as tuples::</span>

<span class="sd">            from sqlalchemy import case</span>

<span class="sd">            stmt = select([users_table]).\\</span>
<span class="sd">                        where(</span>
<span class="sd">                            case(</span>
<span class="sd">                                [</span>
<span class="sd">                                    (users_table.c.name == &#39;wendy&#39;, &#39;W&#39;),</span>
<span class="sd">                                    (users_table.c.name == &#39;jack&#39;, &#39;J&#39;)</span>
<span class="sd">                                ],</span>
<span class="sd">                                else_=&#39;E&#39;</span>
<span class="sd">                            )</span>
<span class="sd">                        )</span>

<span class="sd">        The above statement will produce SQL resembling::</span>

<span class="sd">            SELECT id, name FROM user</span>
<span class="sd">            WHERE CASE</span>
<span class="sd">                WHEN (name = :name_1) THEN :param_1</span>
<span class="sd">                WHEN (name = :name_2) THEN :param_2</span>
<span class="sd">                ELSE :param_3</span>
<span class="sd">            END</span>

<span class="sd">        When simple equality expressions of several values against a single</span>
<span class="sd">        parent column are needed, :func:`.case` also has a &quot;shorthand&quot; format</span>
<span class="sd">        used via the</span>
<span class="sd">        :paramref:`.case.value` parameter, which is passed a column</span>
<span class="sd">        expression to be compared.  In this form, the :paramref:`.case.whens`</span>
<span class="sd">        parameter is passed as a dictionary containing expressions to be</span>
<span class="sd">        compared against keyed to result expressions.  The statement below is</span>
<span class="sd">        equivalent to the preceding statement::</span>

<span class="sd">            stmt = select([users_table]).\\</span>
<span class="sd">                        where(</span>
<span class="sd">                            case(</span>
<span class="sd">                                {&quot;wendy&quot;: &quot;W&quot;, &quot;jack&quot;: &quot;J&quot;},</span>
<span class="sd">                                value=users_table.c.name,</span>
<span class="sd">                                else_=&#39;E&#39;</span>
<span class="sd">                            )</span>
<span class="sd">                        )</span>

<span class="sd">        The values which are accepted as result values in</span>
<span class="sd">        :paramref:`.case.whens` as well as with :paramref:`.case.else_` are</span>
<span class="sd">        coerced from Python literals into :func:`.bindparam` constructs.</span>
<span class="sd">        SQL expressions, e.g. :class:`.ColumnElement` constructs, are accepted</span>
<span class="sd">        as well.  To coerce a literal string expression into a constant</span>
<span class="sd">        expression rendered inline, use the :func:`.literal_column` construct,</span>
<span class="sd">        as in::</span>

<span class="sd">            from sqlalchemy import case, literal_column</span>

<span class="sd">            case(</span>
<span class="sd">                [</span>
<span class="sd">                    (</span>
<span class="sd">                        orderline.c.qty &gt; 100,</span>
<span class="sd">                        literal_column(&quot;&#39;greaterthan100&#39;&quot;)</span>
<span class="sd">                    ),</span>
<span class="sd">                    (</span>
<span class="sd">                        orderline.c.qty &gt; 10,</span>
<span class="sd">                        literal_column(&quot;&#39;greaterthan10&#39;&quot;)</span>
<span class="sd">                    )</span>
<span class="sd">                ],</span>
<span class="sd">                else_=literal_column(&quot;&#39;lessthan10&#39;&quot;)</span>
<span class="sd">            )</span>

<span class="sd">        The above will render the given constants without using bound</span>
<span class="sd">        parameters for the result values (but still for the comparison</span>
<span class="sd">        values), as in::</span>

<span class="sd">            CASE</span>
<span class="sd">                WHEN (orderline.qty &gt; :qty_1) THEN &#39;greaterthan100&#39;</span>
<span class="sd">                WHEN (orderline.qty &gt; :qty_2) THEN &#39;greaterthan10&#39;</span>
<span class="sd">                ELSE &#39;lessthan10&#39;</span>
<span class="sd">            END</span>

<span class="sd">        :param whens: The criteria to be compared against,</span>
<span class="sd">         :paramref:`.case.whens` accepts two different forms, based on</span>
<span class="sd">         whether or not :paramref:`.case.value` is used.</span>

<span class="sd">         In the first form, it accepts a list of 2-tuples; each 2-tuple</span>
<span class="sd">         consists of ``(&lt;sql expression&gt;, &lt;value&gt;)``, where the SQL</span>
<span class="sd">         expression is a boolean expression and &quot;value&quot; is a resulting value,</span>
<span class="sd">         e.g.::</span>

<span class="sd">            case([</span>
<span class="sd">                (users_table.c.name == &#39;wendy&#39;, &#39;W&#39;),</span>
<span class="sd">                (users_table.c.name == &#39;jack&#39;, &#39;J&#39;)</span>
<span class="sd">            ])</span>

<span class="sd">         In the second form, it accepts a Python dictionary of comparison</span>
<span class="sd">         values mapped to a resulting value; this form requires</span>
<span class="sd">         :paramref:`.case.value` to be present, and values will be compared</span>
<span class="sd">         using the ``==`` operator, e.g.::</span>

<span class="sd">            case(</span>
<span class="sd">                {&quot;wendy&quot;: &quot;W&quot;, &quot;jack&quot;: &quot;J&quot;},</span>
<span class="sd">                value=users_table.c.name</span>
<span class="sd">            )</span>

<span class="sd">        :param value: An optional SQL expression which will be used as a</span>
<span class="sd">          fixed &quot;comparison point&quot; for candidate values within a dictionary</span>
<span class="sd">          passed to :paramref:`.case.whens`.</span>

<span class="sd">        :param else\_: An optional SQL expression which will be the evaluated</span>
<span class="sd">          result of the ``CASE`` construct if all expressions within</span>
<span class="sd">          :paramref:`.case.whens` evaluate to false.  When omitted, most</span>
<span class="sd">          databases will produce a result of NULL if none of the &quot;when&quot;</span>
<span class="sd">          expressions evaluate to true.</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">whens</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">dictlike_iteritems</span><span class="p">(</span><span class="n">whens</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">whenlist</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">(),</span>
                 <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="n">whens</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">whenlist</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">_no_literals</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">(),</span>
                 <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="n">whens</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">whenlist</span><span class="p">:</span>
            <span class="n">type_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">whenlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whens</span> <span class="o">=</span> <span class="n">whenlist</span>
        <span class="k">if</span> <span class="n">else_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">else_</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">else_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">else_</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whens</span> <span class="o">=</span> <span class="p">[(</span><span class="n">clone</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">),</span> <span class="n">clone</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">))</span>
                      <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">whens</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">else_</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">else_</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">whens</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">x</span>
            <span class="k">yield</span> <span class="n">y</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_from_objects</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">get_children</span><span class="p">()]))</span>


<span class="k">def</span> <span class="nf">literal_column</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Produce a :class:`.ColumnClause` object that has the</span>
<span class="sd">    :paramref:`.column.is_literal` flag set to True.</span>

<span class="sd">    :func:`.literal_column` is similar to :func:`.column`, except that</span>
<span class="sd">    it is more often used as a &quot;standalone&quot; column expression that renders</span>
<span class="sd">    exactly as stated; while :func:`.column` stores a string name that</span>
<span class="sd">    will be assumed to be part of a table and may be quoted as such,</span>
<span class="sd">    :func:`.literal_column` can be that, or any other arbitrary column-oriented</span>
<span class="sd">    expression.</span>

<span class="sd">    :param text: the text of the expression; can be any SQL expression.</span>
<span class="sd">      Quoting rules will not be applied. To specify a column-name expression</span>
<span class="sd">      which should be subject to quoting rules, use the :func:`column`</span>
<span class="sd">      function.</span>

<span class="sd">    :param type\_: an optional :class:`~sqlalchemy.types.TypeEngine`</span>
<span class="sd">      object which will</span>
<span class="sd">      provide result-set translation and additional expression semantics for</span>
<span class="sd">      this column. If left as None the type will be NullType.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.column`</span>

<span class="sd">        :func:`.text`</span>

<span class="sd">        :ref:`sqlexpression_literal_column`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ColumnClause</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span> <span class="n">is_literal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Cast</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a ``CAST`` expression.</span>

<span class="sd">    :class:`.Cast` is produced using the :func:`.cast` factory function,</span>
<span class="sd">    as in::</span>

<span class="sd">        from sqlalchemy import cast, Numeric</span>

<span class="sd">        stmt = select([</span>
<span class="sd">                    cast(product_table.c.unit_price, Numeric(10, 4))</span>
<span class="sd">                ])</span>

<span class="sd">    Details on :class:`.Cast` usage is at :func:`.cast`.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.cast`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;cast&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">type_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a ``CAST`` expression.</span>

<span class="sd">        :func:`.cast` returns an instance of :class:`.Cast`.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import cast, Numeric</span>

<span class="sd">            stmt = select([</span>
<span class="sd">                        cast(product_table.c.unit_price, Numeric(10, 4))</span>
<span class="sd">                    ])</span>

<span class="sd">        The above statement will produce SQL resembling::</span>

<span class="sd">            SELECT CAST(unit_price AS NUMERIC(10, 4)) FROM product</span>

<span class="sd">        The :func:`.cast` function performs two distinct functions when</span>
<span class="sd">        used.  The first is that it renders the ``CAST`` expression within</span>
<span class="sd">        the resulting SQL string.  The second is that it associates the given</span>
<span class="sd">        type (e.g. :class:`.TypeEngine` class or instance) with the column</span>
<span class="sd">        expression on the Python side, which means the expression will take</span>
<span class="sd">        on the expression operator behavior associated with that type,</span>
<span class="sd">        as well as the bound-value handling and result-row-handling behavior</span>
<span class="sd">        of the type.</span>

<span class="sd">        .. versionchanged:: 0.9.0 :func:`.cast` now applies the given type</span>
<span class="sd">           to the expression such that it takes effect on the bound-value,</span>
<span class="sd">           e.g. the Python-to-database direction, in addition to the</span>
<span class="sd">           result handling, e.g. database-to-Python, direction.</span>

<span class="sd">        An alternative to :func:`.cast` is the :func:`.type_coerce` function.</span>
<span class="sd">        This function performs the second task of associating an expression</span>
<span class="sd">        with a specific type, but does not render the ``CAST`` expression</span>
<span class="sd">        in SQL.</span>

<span class="sd">        :param expression: A SQL expression, such as a :class:`.ColumnElement`</span>
<span class="sd">         expression or a Python string which will be coerced into a bound</span>
<span class="sd">         literal value.</span>

<span class="sd">        :param type_: A :class:`.TypeEngine` class or instance indicating</span>
<span class="sd">         the type to which the ``CAST`` should apply.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.type_coerce` - Python-side type coercion without emitting</span>
<span class="sd">            CAST.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">to_instance</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clause</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeclause</span> <span class="o">=</span> <span class="n">TypeClause</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clause</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeclause</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typeclause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clause</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeclause</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clause</span><span class="o">.</span><span class="n">_from_objects</span>


<span class="k">class</span> <span class="nc">Extract</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a SQL EXTRACT clause, ``extract(field FROM expr)``.&quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;extract&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`.Extract` construct.</span>

<span class="sd">        This is typically available as :func:`.extract`</span>
<span class="sd">        as well as ``func.extract`` from the</span>
<span class="sd">        :data:`.func` namespace.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">INTEGERTYPE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_from_objects</span>


<span class="k">class</span> <span class="nc">_label_reference</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrap a column expression as it appears in a &#39;reference&#39; context.</span>

<span class="sd">    This expression is any that inclues an _order_by_label_element,</span>
<span class="sd">    which is a Label, or a DESC / ASC construct wrapping a Label.</span>

<span class="sd">    The production of _label_reference() should occur when an expression</span>
<span class="sd">    is added to this context; this includes the ORDER BY or GROUP BY of a</span>
<span class="sd">    SELECT statement, as well as a few other places, such as the ORDER BY</span>
<span class="sd">    within an OVER clause.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;label_reference&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">()</span>


<span class="k">class</span> <span class="nc">_textual_label_reference</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;textual_label_reference&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">_text_clause</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TextClause</span><span class="o">.</span><span class="n">_create_text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">UnaryExpression</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define a &#39;unary&#39; expression.</span>

<span class="sd">    A unary expression has a single column expression</span>
<span class="sd">    and an operator.  The operator can be placed on the left</span>
<span class="sd">    (where it is called the &#39;operator&#39;) or right (where it is called the</span>
<span class="sd">    &#39;modifier&#39;) of the column expression.</span>

<span class="sd">    :class:`.UnaryExpression` is the basis for several unary operators</span>
<span class="sd">    including those used by :func:`.desc`, :func:`.asc`, :func:`.distinct`,</span>
<span class="sd">    :func:`.nullsfirst` and :func:`.nullslast`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;unary&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">modifier</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">type_</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">negate</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wraps_column_expression</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modifier</span> <span class="o">=</span> <span class="n">modifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span>
            <span class="n">against</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">modifier</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">to_instance</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negate</span> <span class="o">=</span> <span class="n">negate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wraps_column_expression</span> <span class="o">=</span> <span class="n">wraps_column_expression</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_nullsfirst</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce the ``NULLS FIRST`` modifier for an ``ORDER BY`` expression.</span>

<span class="sd">        :func:`.nullsfirst` is intended to modify the expression produced</span>
<span class="sd">        by :func:`.asc` or :func:`.desc`, and indicates how NULL values</span>
<span class="sd">        should be handled when they are encountered during ordering::</span>


<span class="sd">            from sqlalchemy import desc, nullsfirst</span>

<span class="sd">            stmt = select([users_table]).\\</span>
<span class="sd">                        order_by(nullsfirst(desc(users_table.c.name)))</span>

<span class="sd">        The SQL expression from the above would resemble::</span>

<span class="sd">            SELECT id, name FROM user ORDER BY name DESC NULLS FIRST</span>

<span class="sd">        Like :func:`.asc` and :func:`.desc`, :func:`.nullsfirst` is typically</span>
<span class="sd">        invoked from the column expression itself using</span>
<span class="sd">        :meth:`.ColumnElement.nullsfirst`, rather than as its standalone</span>
<span class="sd">        function version, as in::</span>

<span class="sd">            stmt = (select([users_table]).</span>
<span class="sd">                    order_by(users_table.c.name.desc().nullsfirst())</span>
<span class="sd">                    )</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.asc`</span>

<span class="sd">            :func:`.desc`</span>

<span class="sd">            :func:`.nullslast`</span>

<span class="sd">            :meth:`.Select.order_by`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
            <span class="n">_literal_as_label_reference</span><span class="p">(</span><span class="n">column</span><span class="p">),</span>
            <span class="n">modifier</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">nullsfirst_op</span><span class="p">,</span>
            <span class="n">wraps_column_expression</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_nullslast</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce the ``NULLS LAST`` modifier for an ``ORDER BY`` expression.</span>

<span class="sd">        :func:`.nullslast` is intended to modify the expression produced</span>
<span class="sd">        by :func:`.asc` or :func:`.desc`, and indicates how NULL values</span>
<span class="sd">        should be handled when they are encountered during ordering::</span>


<span class="sd">            from sqlalchemy import desc, nullslast</span>

<span class="sd">            stmt = select([users_table]).\\</span>
<span class="sd">                        order_by(nullslast(desc(users_table.c.name)))</span>

<span class="sd">        The SQL expression from the above would resemble::</span>

<span class="sd">            SELECT id, name FROM user ORDER BY name DESC NULLS LAST</span>

<span class="sd">        Like :func:`.asc` and :func:`.desc`, :func:`.nullslast` is typically</span>
<span class="sd">        invoked from the column expression itself using</span>
<span class="sd">        :meth:`.ColumnElement.nullslast`, rather than as its standalone</span>
<span class="sd">        function version, as in::</span>

<span class="sd">            stmt = select([users_table]).\\</span>
<span class="sd">                        order_by(users_table.c.name.desc().nullslast())</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.asc`</span>

<span class="sd">            :func:`.desc`</span>

<span class="sd">            :func:`.nullsfirst`</span>

<span class="sd">            :meth:`.Select.order_by`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
            <span class="n">_literal_as_label_reference</span><span class="p">(</span><span class="n">column</span><span class="p">),</span>
            <span class="n">modifier</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">nullslast_op</span><span class="p">,</span>
            <span class="n">wraps_column_expression</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_desc</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a descending ``ORDER BY`` clause element.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            from sqlalchemy import desc</span>

<span class="sd">            stmt = select([users_table]).order_by(desc(users_table.c.name))</span>

<span class="sd">        will produce SQL as::</span>

<span class="sd">            SELECT id, name FROM user ORDER BY name DESC</span>

<span class="sd">        The :func:`.desc` function is a standalone version of the</span>
<span class="sd">        :meth:`.ColumnElement.desc` method available on all SQL expressions,</span>
<span class="sd">        e.g.::</span>


<span class="sd">            stmt = select([users_table]).order_by(users_table.c.name.desc())</span>

<span class="sd">        :param column: A :class:`.ColumnElement` (e.g. scalar SQL expression)</span>
<span class="sd">         with which to apply the :func:`.desc` operation.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.asc`</span>

<span class="sd">            :func:`.nullsfirst`</span>

<span class="sd">            :func:`.nullslast`</span>

<span class="sd">            :meth:`.Select.order_by`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
            <span class="n">_literal_as_label_reference</span><span class="p">(</span><span class="n">column</span><span class="p">),</span>
            <span class="n">modifier</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">desc_op</span><span class="p">,</span>
            <span class="n">wraps_column_expression</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_asc</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce an ascending ``ORDER BY`` clause element.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            from sqlalchemy import asc</span>
<span class="sd">            stmt = select([users_table]).order_by(asc(users_table.c.name))</span>

<span class="sd">        will produce SQL as::</span>

<span class="sd">            SELECT id, name FROM user ORDER BY name ASC</span>

<span class="sd">        The :func:`.asc` function is a standalone version of the</span>
<span class="sd">        :meth:`.ColumnElement.asc` method available on all SQL expressions,</span>
<span class="sd">        e.g.::</span>


<span class="sd">            stmt = select([users_table]).order_by(users_table.c.name.asc())</span>

<span class="sd">        :param column: A :class:`.ColumnElement` (e.g. scalar SQL expression)</span>
<span class="sd">         with which to apply the :func:`.asc` operation.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.desc`</span>

<span class="sd">            :func:`.nullsfirst`</span>

<span class="sd">            :func:`.nullslast`</span>

<span class="sd">            :meth:`.Select.order_by`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
            <span class="n">_literal_as_label_reference</span><span class="p">(</span><span class="n">column</span><span class="p">),</span>
            <span class="n">modifier</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">asc_op</span><span class="p">,</span>
            <span class="n">wraps_column_expression</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_distinct</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce an column-expression-level unary ``DISTINCT`` clause.</span>

<span class="sd">        This applies the ``DISTINCT`` keyword to an individual column</span>
<span class="sd">        expression, and is typically contained within an aggregate function,</span>
<span class="sd">        as in::</span>

<span class="sd">            from sqlalchemy import distinct, func</span>
<span class="sd">            stmt = select([func.count(distinct(users_table.c.name))])</span>

<span class="sd">        The above would produce an expression resembling::</span>

<span class="sd">            SELECT COUNT(DISTINCT name) FROM user</span>

<span class="sd">        The :func:`.distinct` function is also available as a column-level</span>
<span class="sd">        method, e.g. :meth:`.ColumnElement.distinct`, as in::</span>

<span class="sd">            stmt = select([func.count(users_table.c.name.distinct())])</span>

<span class="sd">        The :func:`.distinct` operator is different from the</span>
<span class="sd">        :meth:`.Select.distinct` method of :class:`.Select`,</span>
<span class="sd">        which produces a ``SELECT`` statement</span>
<span class="sd">        with ``DISTINCT`` applied to the result set as a whole,</span>
<span class="sd">        e.g. a ``SELECT DISTINCT`` expression.  See that method for further</span>
<span class="sd">        information.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.ColumnElement.distinct`</span>

<span class="sd">            :meth:`.Select.distinct`</span>

<span class="sd">            :data:`.func`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">distinct_op</span><span class="p">,</span>
            <span class="n">type_</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">wraps_column_expression</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_order_by_label_element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">modifier</span> <span class="ow">in</span> <span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">desc_op</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">asc_op</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_order_by_label_element</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_from_objects</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare this :class:`UnaryExpression` against the given</span>
<span class="sd">        :class:`.ClauseElement`.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">UnaryExpression</span><span class="p">)</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">operator</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modifier</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">modifier</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">negate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span>
                <span class="n">operator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">negate</span><span class="p">,</span>
                <span class="n">negate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span>
                <span class="n">modifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modifier</span><span class="p">,</span>
                <span class="n">type_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="n">wraps_column_expression</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wraps_column_expression</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ClauseElement</span><span class="o">.</span><span class="n">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="ow">and</span> <span class="n">operators</span><span class="o">.</span><span class="n">is_precedent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">against</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Grouping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">AsBoolean</span><span class="p">(</span><span class="n">UnaryExpression</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">negate</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negate</span> <span class="o">=</span> <span class="n">negate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modifier</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wraps_column_expression</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_negate</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">BinaryExpression</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent an expression that is ``LEFT &lt;operator&gt; RIGHT``.</span>

<span class="sd">    A :class:`.BinaryExpression` is generated automatically</span>
<span class="sd">    whenever two column expressions are used in a Python binary expression::</span>

<span class="sd">        &gt;&gt;&gt; from sqlalchemy.sql import column</span>
<span class="sd">        &gt;&gt;&gt; column(&#39;a&#39;) + column(&#39;b&#39;)</span>
<span class="sd">        &lt;sqlalchemy.sql.expression.BinaryExpression object at 0x101029dd0&gt;</span>
<span class="sd">        &gt;&gt;&gt; print column(&#39;a&#39;) + column(&#39;b&#39;)</span>
<span class="sd">        a + b</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;binary&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">negate</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">modifiers</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c1"># allow compatibility with libraries that</span>
        <span class="c1"># refer to BinaryExpression directly and pass strings</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="n">operators</span><span class="o">.</span><span class="n">custom_op</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">to_instance</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negate</span> <span class="o">=</span> <span class="n">negate</span>

        <span class="k">if</span> <span class="n">modifiers</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modifiers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modifiers</span> <span class="o">=</span> <span class="n">modifiers</span>

    <span class="k">def</span> <span class="nf">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Boolean value of this clause is not defined&quot;</span><span class="p">)</span>

    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="n">__bool__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_comparison</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">operators</span><span class="o">.</span><span class="n">is_comparison</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">_from_objects</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">_from_objects</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare this :class:`BinaryExpression` against the</span>
<span class="sd">        given :class:`BinaryExpression`.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BinaryExpression</span><span class="p">)</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">operator</span> <span class="ow">and</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span>
                    <span class="n">operators</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">operators</span><span class="o">.</span><span class="n">is_precedent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">against</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Grouping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">negate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BinaryExpression</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">negate</span><span class="p">,</span>
                <span class="n">negate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span>
                <span class="n">type_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="n">modifiers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modifiers</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BinaryExpression</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_negate</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Grouping</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a grouping within a column expression&quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;grouping&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_key_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;_label&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">anon_label</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_from_objects</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;element&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;element&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Grouping</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Over</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent an OVER clause.</span>

<span class="sd">    This is a special operator against a so-called</span>
<span class="sd">    &quot;window&quot; function, as well as any aggregate function,</span>
<span class="sd">    which produces results relative to the result set</span>
<span class="sd">    itself.  It&#39;s supported only by certain database</span>
<span class="sd">    backends.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;over&#39;</span>

    <span class="n">order_by</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">partition_by</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">partition_by</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce an :class:`.Over` object against a function.</span>

<span class="sd">        Used against aggregate or so-called &quot;window&quot; functions,</span>
<span class="sd">        for database backends that support window functions.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import over</span>
<span class="sd">            over(func.row_number(), order_by=&#39;x&#39;)</span>

<span class="sd">        Would produce &quot;ROW_NUMBER() OVER(ORDER BY x)&quot;.</span>

<span class="sd">        :param func: a :class:`.FunctionElement` construct, typically</span>
<span class="sd">         generated by :data:`~.expression.func`.</span>
<span class="sd">        :param partition_by: a column element or string, or a list</span>
<span class="sd">         of such, that will be used as the PARTITION BY clause</span>
<span class="sd">         of the OVER construct.</span>
<span class="sd">        :param order_by: a column element or string, or a list</span>
<span class="sd">         of such, that will be used as the ORDER BY clause</span>
<span class="sd">         of the OVER construct.</span>

<span class="sd">        This function is also available from the :data:`~.expression.func`</span>
<span class="sd">        construct itself via the :meth:`.FunctionElement.over` method.</span>

<span class="sd">        .. versionadded:: 0.7</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="k">if</span> <span class="n">order_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">ClauseList</span><span class="p">(</span>
                <span class="o">*</span><span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">order_by</span><span class="p">),</span>
                <span class="n">_literal_as_text</span><span class="o">=</span><span class="n">_literal_as_label_reference</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">partition_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partition_by</span> <span class="o">=</span> <span class="n">ClauseList</span><span class="p">(</span>
                <span class="o">*</span><span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">partition_by</span><span class="p">),</span>
                <span class="n">_literal_as_text</span><span class="o">=</span><span class="n">_literal_as_label_reference</span><span class="p">)</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">type</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_by</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partition_by</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partition_by</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_by</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_from_objects</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_by</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span><span class="p">)</span>
              <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>
        <span class="p">))</span>


<span class="k">class</span> <span class="nc">FunctionFilter</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a function FILTER clause.</span>

<span class="sd">    This is a special operator against aggregate and window functions,</span>
<span class="sd">    which controls which rows are passed to it.</span>
<span class="sd">    It&#39;s supported only by certain database backends.</span>

<span class="sd">    Invocation of :class:`.FunctionFilter` is via</span>
<span class="sd">    :meth:`.FunctionElement.filter`::</span>

<span class="sd">        func.count(1).filter(True)</span>

<span class="sd">    .. versionadded:: 1.0.0</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`.FunctionElement.filter`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;funcfilter&#39;</span>

    <span class="n">criterion</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">criterion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a :class:`.FunctionFilter` object against a function.</span>

<span class="sd">        Used against aggregate and window functions,</span>
<span class="sd">        for database backends that support the &quot;FILTER&quot; clause.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import funcfilter</span>
<span class="sd">            funcfilter(func.count(1), MyClass.name == &#39;some name&#39;)</span>

<span class="sd">        Would produce &quot;COUNT(1) FILTER (WHERE myclass.name = &#39;some name&#39;)&quot;.</span>

<span class="sd">        This function is also available from the :data:`~.expression.func`</span>
<span class="sd">        construct itself via the :meth:`.FunctionElement.filter` method.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.FunctionElement.filter`</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">criterion</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">criterion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce an additional FILTER against the function.</span>

<span class="sd">        This method adds additional criteria to the initial criteria</span>
<span class="sd">        set up by :meth:`.FunctionElement.filter`.</span>

<span class="sd">        Multiple criteria are joined together at SQL render time</span>
<span class="sd">        via ``AND``.</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">criterion</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">criterion</span><span class="p">):</span>
            <span class="n">criterion</span> <span class="o">=</span> <span class="n">_expression_literal_as_text</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">&amp;</span> <span class="n">criterion</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">=</span> <span class="n">criterion</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">over</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partition_by</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce an OVER clause against this filtered function.</span>

<span class="sd">        Used against aggregate or so-called &quot;window&quot; functions,</span>
<span class="sd">        for database backends that support window functions.</span>

<span class="sd">        The expression::</span>

<span class="sd">            func.rank().filter(MyClass.y &gt; 5).over(order_by=&#39;x&#39;)</span>

<span class="sd">        is shorthand for::</span>

<span class="sd">            from sqlalchemy import over, funcfilter</span>
<span class="sd">            over(funcfilter(func.rank(), MyClass.y &gt; 5), order_by=&#39;x&#39;)</span>

<span class="sd">        See :func:`~.expression.over` for a full description.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Over</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partition_by</span><span class="o">=</span><span class="n">partition_by</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="n">order_by</span><span class="p">)</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">type</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">criterion</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_from_objects</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span><span class="p">)</span>
              <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>
        <span class="p">))</span>


<span class="k">class</span> <span class="nc">Label</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a column label (AS).</span>

<span class="sd">    Represent a label, as typically applied to any column-level</span>
<span class="sd">    element using the ``AS`` sql keyword.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;label&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`Label` object for the</span>
<span class="sd">        given :class:`.ColumnElement`.</span>

<span class="sd">        A label changes the name of an element in the columns clause of a</span>
<span class="sd">        ``SELECT`` statement, typically via the ``AS`` SQL keyword.</span>

<span class="sd">        This functionality is more conveniently available via the</span>
<span class="sd">        :meth:`.ColumnElement.label` method on :class:`.ColumnElement`.</span>

<span class="sd">        :param name: label name</span>

<span class="sd">        :param obj: a :class:`.ColumnElement`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Label</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_label</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">_label</span>

        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Label</span><span class="p">):</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">element</span>

        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">_anonymous_label</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">%%</span><span class="s1">(</span><span class="si">%d</span><span class="s1"> </span><span class="si">%s</span><span class="s1">)s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;anon&#39;</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_element</span> <span class="o">=</span> <span class="n">element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="n">type_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proxies</span> <span class="o">=</span> <span class="p">[</span><span class="n">element</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span><span class="p">)</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">_allow_label_resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_allow_label_resolve</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_order_by_label_element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">to_instance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">as_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">sub_element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">against</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sub_element</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                         <span class="n">sub_element</span><span class="p">,</span>
                         <span class="n">type_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">primary_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">primary_key</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">foreign_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">foreign_keys</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="n">anonymize_labels</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_element</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;element&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_allow_label_resolve&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">anonymize_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_label</span> <span class="o">=</span> <span class="n">_anonymous_label</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">%%</span><span class="s1">(</span><span class="si">%d</span><span class="s1"> </span><span class="si">%s</span><span class="s1">)s&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;anon&#39;</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_from_objects</span>

    <span class="k">def</span> <span class="nf">_make_proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_make_proxy</span><span class="p">(</span><span class="n">selectable</span><span class="p">,</span>
                                     <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">e</span><span class="o">.</span><span class="n">_proxies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span>
        <span class="k">return</span> <span class="n">e</span>


<span class="k">class</span> <span class="nc">ColumnClause</span><span class="p">(</span><span class="n">Immutable</span><span class="p">,</span> <span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a column expression from any textual string.</span>

<span class="sd">    The :class:`.ColumnClause`, a lightweight analogue to the</span>
<span class="sd">    :class:`.Column` class, is typically invoked using the</span>
<span class="sd">    :func:`.column` function, as in::</span>

<span class="sd">        from sqlalchemy import column</span>

<span class="sd">        id, name = column(&quot;id&quot;), column(&quot;name&quot;)</span>
<span class="sd">        stmt = select([id, name]).select_from(&quot;user&quot;)</span>

<span class="sd">    The above statement would produce SQL like::</span>

<span class="sd">        SELECT id, name FROM user</span>

<span class="sd">    :class:`.ColumnClause` is the immediate superclass of the schema-specific</span>
<span class="sd">    :class:`.Column` object.  While the :class:`.Column` class has all the</span>
<span class="sd">    same capabilities as :class:`.ColumnClause`, the :class:`.ColumnClause`</span>
<span class="sd">    class is usable by itself in those cases where behavioral requirements</span>
<span class="sd">    are limited to simple SQL expression generation.  The object has none of</span>
<span class="sd">    the associations with schema-level metadata or with execution-time</span>
<span class="sd">    behavior that :class:`.Column` does, so in that sense is a &quot;lightweight&quot;</span>
<span class="sd">    version of :class:`.Column`.</span>

<span class="sd">    Full details on :class:`.ColumnClause` usage is at :func:`.column`.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.column`</span>

<span class="sd">        :class:`.Column`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;column&#39;</span>

    <span class="n">onupdate</span> <span class="o">=</span> <span class="n">default</span> <span class="o">=</span> <span class="n">server_default</span> <span class="o">=</span> <span class="n">server_onupdate</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">_memoized_property</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">group_expirable_memoized_property</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">is_literal</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">_selectable</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a :class:`.ColumnClause` object.</span>

<span class="sd">        The :class:`.ColumnClause` is a lightweight analogue to the</span>
<span class="sd">        :class:`.Column` class.  The :func:`.column` function can</span>
<span class="sd">        be invoked with just a name alone, as in::</span>

<span class="sd">            from sqlalchemy import column</span>

<span class="sd">            id, name = column(&quot;id&quot;), column(&quot;name&quot;)</span>
<span class="sd">            stmt = select([id, name]).select_from(&quot;user&quot;)</span>

<span class="sd">        The above statement would produce SQL like::</span>

<span class="sd">            SELECT id, name FROM user</span>

<span class="sd">        Once constructed, :func:`.column` may be used like any other SQL</span>
<span class="sd">        expression element such as within :func:`.select` constructs::</span>

<span class="sd">            from sqlalchemy.sql import column</span>

<span class="sd">            id, name = column(&quot;id&quot;), column(&quot;name&quot;)</span>
<span class="sd">            stmt = select([id, name]).select_from(&quot;user&quot;)</span>

<span class="sd">        The text handled by :func:`.column` is assumed to be handled</span>
<span class="sd">        like the name of a database column; if the string contains mixed case,</span>
<span class="sd">        special characters, or matches a known reserved word on the target</span>
<span class="sd">        backend, the column expression will render using the quoting</span>
<span class="sd">        behavior determined by the backend.  To produce a textual SQL</span>
<span class="sd">        expression that is rendered exactly without any quoting,</span>
<span class="sd">        use :func:`.literal_column` instead, or pass ``True`` as the</span>
<span class="sd">        value of :paramref:`.column.is_literal`.   Additionally, full SQL</span>
<span class="sd">        statements are best handled using the :func:`.text` construct.</span>

<span class="sd">        :func:`.column` can be used in a table-like</span>
<span class="sd">        fashion by combining it with the :func:`.table` function</span>
<span class="sd">        (which is the lightweight analogue to :class:`.Table`) to produce</span>
<span class="sd">        a working table construct with minimal boilerplate::</span>

<span class="sd">            from sqlalchemy import table, column, select</span>

<span class="sd">            user = table(&quot;user&quot;,</span>
<span class="sd">                    column(&quot;id&quot;),</span>
<span class="sd">                    column(&quot;name&quot;),</span>
<span class="sd">                    column(&quot;description&quot;),</span>
<span class="sd">            )</span>

<span class="sd">            stmt = select([user.c.description]).where(user.c.name == &#39;wendy&#39;)</span>

<span class="sd">        A :func:`.column` / :func:`.table` construct like that illustrated</span>
<span class="sd">        above can be created in an</span>
<span class="sd">        ad-hoc fashion and is not associated with any</span>
<span class="sd">        :class:`.schema.MetaData`, DDL, or events, unlike its</span>
<span class="sd">        :class:`.Table` counterpart.</span>

<span class="sd">        .. versionchanged:: 1.0.0 :func:`.expression.column` can now</span>
<span class="sd">           be imported from the plain ``sqlalchemy`` namespace like any</span>
<span class="sd">           other SQL element.</span>

<span class="sd">        :param text: the text of the element.</span>

<span class="sd">        :param type: :class:`.types.TypeEngine` object which can associate</span>
<span class="sd">          this :class:`.ColumnClause` with a type.</span>

<span class="sd">        :param is_literal: if True, the :class:`.ColumnClause` is assumed to</span>
<span class="sd">          be an exact expression that will be delivered to the output with no</span>
<span class="sd">          quoting rules applied regardless of case sensitive settings. the</span>
<span class="sd">          :func:`.literal_column()` function essentially invokes</span>
<span class="sd">          :func:`.column` while passing ``is_literal=True``.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :class:`.Column`</span>

<span class="sd">            :func:`.literal_column`</span>

<span class="sd">            :func:`.table`</span>

<span class="sd">            :func:`.text`</span>

<span class="sd">            :ref:`sqlexpression_literal_column`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">text</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">_selectable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">to_instance</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_literal</span> <span class="o">=</span> <span class="n">is_literal</span>

    <span class="k">def</span> <span class="nf">_compare_name_for_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_literal</span> <span class="ow">or</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">_textual</span> <span class="ow">or</span> \
                <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;proxy_set&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ColumnClause</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">is_literal</span> <span class="ow">or</span>
                     <span class="n">other</span><span class="o">.</span><span class="n">table</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span>
                     <span class="n">other</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">_textual</span><span class="p">)</span>
                <span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;_label&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">proxy_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proxy_set</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_set_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memoized_property</span><span class="o">.</span><span class="n">expire_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span>
    <span class="n">table</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_table</span><span class="p">,</span> <span class="n">_set_table</span><span class="p">)</span>

    <span class="nd">@_memoized_property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">util</span><span class="o">.</span><span class="n">py3k</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="s1">&#39;backslashreplace&#39;</span><span class="p">)</span>

    <span class="nd">@_memoized_property</span>
    <span class="k">def</span> <span class="nf">_key_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span>

    <span class="nd">@_memoized_property</span>
    <span class="k">def</span> <span class="nf">_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@_memoized_property</span>
    <span class="k">def</span> <span class="nf">_render_label_in_columns_clause</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_gen_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_literal</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">named_with_column</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;schema&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> \
                    <span class="n">t</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">name</span>

            <span class="c1"># propagate name quoting rules for labels.</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;quote&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">quoted_name</span><span class="p">):</span>
                    <span class="n">label</span><span class="o">.</span><span class="n">quote</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">quote</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="n">quoted_name</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">name</span><span class="o">.</span><span class="n">quote</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;quote&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># can&#39;t get this situation to occur, so let&#39;s</span>
                <span class="c1"># assert false on it for now</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">quoted_name</span><span class="p">)</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">quoted_name</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">quote</span><span class="p">)</span>

            <span class="c1"># ensure the label name doesn&#39;t conflict with that</span>
            <span class="c1"># of an existing column</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
                <span class="n">_label</span> <span class="o">=</span> <span class="n">label</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">_label</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
                    <span class="n">_label</span> <span class="o">=</span> <span class="n">label</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
                    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">_label</span>

            <span class="k">return</span> <span class="n">_as_truncated</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BindParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span>
                             <span class="n">_compared_to_operator</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span>
                             <span class="n">_compared_to_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                             <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">attach</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                    <span class="n">name_is_truncatable</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="c1"># propagate the &quot;is_literal&quot; flag only if we are keeping our name,</span>
        <span class="c1"># otherwise its considered to be a label</span>
        <span class="n">is_literal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_literal</span> <span class="ow">and</span> <span class="p">(</span><span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
            <span class="n">_as_truncated</span><span class="p">(</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span>
            <span class="n">name_is_truncatable</span> <span class="k">else</span>
            <span class="p">(</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
            <span class="n">type_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
            <span class="n">_selectable</span><span class="o">=</span><span class="n">selectable</span><span class="p">,</span>
            <span class="n">is_literal</span><span class="o">=</span><span class="n">is_literal</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span>
        <span class="n">c</span><span class="o">.</span><span class="n">_proxies</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">selectable</span><span class="o">.</span><span class="n">_is_clone_of</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">_is_clone_of</span> <span class="o">=</span> \
                <span class="n">selectable</span><span class="o">.</span><span class="n">_is_clone_of</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">attach</span><span class="p">:</span>
            <span class="n">selectable</span><span class="o">.</span><span class="n">_columns</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">return</span> <span class="n">c</span>


<span class="k">class</span> <span class="nc">_IdentifiedClause</span><span class="p">(</span><span class="n">Executable</span><span class="p">,</span> <span class="n">ClauseElement</span><span class="p">):</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;identified&#39;</span>
    <span class="n">_execution_options</span> <span class="o">=</span> \
        <span class="n">Executable</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">({</span><span class="s1">&#39;autocommit&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ident</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ident</span> <span class="o">=</span> <span class="n">ident</span>


<span class="k">class</span> <span class="nc">SavepointClause</span><span class="p">(</span><span class="n">_IdentifiedClause</span><span class="p">):</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;savepoint&#39;</span>


<span class="k">class</span> <span class="nc">RollbackToSavepointClause</span><span class="p">(</span><span class="n">_IdentifiedClause</span><span class="p">):</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;rollback_to_savepoint&#39;</span>


<span class="k">class</span> <span class="nc">ReleaseSavepointClause</span><span class="p">(</span><span class="n">_IdentifiedClause</span><span class="p">):</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s1">&#39;release_savepoint&#39;</span>


<span class="k">class</span> <span class="nc">quoted_name</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">MemoizedSlots</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a SQL identifier combined with quoting preferences.</span>

<span class="sd">    :class:`.quoted_name` is a Python unicode/str subclass which</span>
<span class="sd">    represents a particular identifier name along with a</span>
<span class="sd">    ``quote`` flag.  This ``quote`` flag, when set to</span>
<span class="sd">    ``True`` or ``False``, overrides automatic quoting behavior</span>
<span class="sd">    for this identifier in order to either unconditionally quote</span>
<span class="sd">    or to not quote the name.  If left at its default of ``None``,</span>
<span class="sd">    quoting behavior is applied to the identifier on a per-backend basis</span>
<span class="sd">    based on an examination of the token itself.</span>

<span class="sd">    A :class:`.quoted_name` object with ``quote=True`` is also</span>
<span class="sd">    prevented from being modified in the case of a so-called</span>
<span class="sd">    &quot;name normalize&quot; option.  Certain database backends, such as</span>
<span class="sd">    Oracle, Firebird, and DB2 &quot;normalize&quot; case-insensitive names</span>
<span class="sd">    as uppercase.  The SQLAlchemy dialects for these backends</span>
<span class="sd">    convert from SQLAlchemy&#39;s lower-case-means-insensitive convention</span>
<span class="sd">    to the upper-case-means-insensitive conventions of those backends.</span>
<span class="sd">    The ``quote=True`` flag here will prevent this conversion from occurring</span>
<span class="sd">    to support an identifier that&#39;s quoted as all lower case against</span>
<span class="sd">    such a backend.</span>

<span class="sd">    The :class:`.quoted_name` object is normally created automatically</span>
<span class="sd">    when specifying the name for key schema constructs such as</span>
<span class="sd">    :class:`.Table`, :class:`.Column`, and others.  The class can also be</span>
<span class="sd">    passed explicitly as the name to any function that receives a name which</span>
<span class="sd">    can be quoted.  Such as to use the :meth:`.Engine.has_table` method with</span>
<span class="sd">    an unconditionally quoted name::</span>

<span class="sd">        from sqlaclchemy import create_engine</span>
<span class="sd">        from sqlalchemy.sql.elements import quoted_name</span>

<span class="sd">        engine = create_engine(&quot;oracle+cx_oracle://some_dsn&quot;)</span>
<span class="sd">        engine.has_table(quoted_name(&quot;some_table&quot;, True))</span>

<span class="sd">    The above logic will run the &quot;has table&quot; logic against the Oracle backend,</span>
<span class="sd">    passing the name exactly as ``&quot;some_table&quot;`` without converting to</span>
<span class="sd">    upper case.</span>

<span class="sd">    .. versionadded:: 0.9.0</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="s1">&#39;quote&#39;</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">quote</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="c1"># experimental - don&#39;t bother with quoted_name</span>
        <span class="c1"># if quote flag is None.  doesn&#39;t seem to make any dent</span>
        <span class="c1"># in performance however</span>
        <span class="c1"># elif not sprcls and quote is None:</span>
        <span class="c1">#   return value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">quote</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">value</span><span class="o">.</span><span class="n">quote</span> <span class="o">==</span> <span class="n">quote</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">quoted_name</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quote</span> <span class="o">=</span> <span class="n">quote</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">quoted_name</span><span class="p">,</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_memoized_method_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_memoized_method_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">backslashed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="s1">&#39;backslashreplace&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">util</span><span class="o">.</span><span class="n">py2k</span><span class="p">:</span>
            <span class="n">backslashed</span> <span class="o">=</span> <span class="n">backslashed</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">backslashed</span>


<span class="k">class</span> <span class="nc">_truncated_label</span><span class="p">(</span><span class="n">quoted_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A unicode subclass used to identify symbolic &quot;</span>
<span class="sd">    &quot;names that may require truncation.&quot;&quot;&quot;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">quote</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">quote</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;quote&quot;</span><span class="p">,</span> <span class="n">quote</span><span class="p">)</span>
        <span class="c1"># return super(_truncated_label, cls).__new__(cls, value, quote, True)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">_truncated_label</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">quote</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">conv</span><span class="p">(</span><span class="n">_truncated_label</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mark a string indicating that a name has already been converted</span>
<span class="sd">    by a naming convention.</span>

<span class="sd">    This is a string subclass that indicates a name that should not be</span>
<span class="sd">    subject to any further naming conventions.</span>

<span class="sd">    E.g. when we create a :class:`.Constraint` using a naming convention</span>
<span class="sd">    as follows::</span>

<span class="sd">        m = MetaData(naming_convention={</span>
<span class="sd">            &quot;ck&quot;: &quot;ck_%(table_name)s_%(constraint_name)s&quot;</span>
<span class="sd">        })</span>
<span class="sd">        t = Table(&#39;t&#39;, m, Column(&#39;x&#39;, Integer),</span>
<span class="sd">                        CheckConstraint(&#39;x &gt; 5&#39;, name=&#39;x5&#39;))</span>

<span class="sd">    The name of the above constraint will be rendered as ``&quot;ck_t_x5&quot;``.</span>
<span class="sd">    That is, the existing name ``x5`` is used in the naming convention as the</span>
<span class="sd">    ``constraint_name`` token.</span>

<span class="sd">    In some situations, such as in migration scripts, we may be rendering</span>
<span class="sd">    the above :class:`.CheckConstraint` with a name that&#39;s already been</span>
<span class="sd">    converted.  In order to make sure the name isn&#39;t double-modified, the</span>
<span class="sd">    new name is applied using the :func:`.schema.conv` marker.  We can</span>
<span class="sd">    use this explicitly as follows::</span>


<span class="sd">        m = MetaData(naming_convention={</span>
<span class="sd">            &quot;ck&quot;: &quot;ck_%(table_name)s_%(constraint_name)s&quot;</span>
<span class="sd">        })</span>
<span class="sd">        t = Table(&#39;t&#39;, m, Column(&#39;x&#39;, Integer),</span>
<span class="sd">                        CheckConstraint(&#39;x &gt; 5&#39;, name=conv(&#39;ck_t_x5&#39;)))</span>

<span class="sd">    Where above, the :func:`.schema.conv` marker indicates that the constraint</span>
<span class="sd">    name here is final, and the name will render as ``&quot;ck_t_x5&quot;`` and not</span>
<span class="sd">    ``&quot;ck_t_ck_t_x5&quot;``</span>

<span class="sd">    .. versionadded:: 0.9.4</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :ref:`constraint_naming_conventions`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">()</span>


<span class="k">class</span> <span class="nc">_defer_name</span><span class="p">(</span><span class="n">_truncated_label</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;mark a name as &#39;deferred&#39; for the purposes of automated name</span>
<span class="sd">    generation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_NONE_NAME</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">conv</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">_defer_name</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">)</span>


<span class="k">class</span> <span class="nc">_defer_none_name</span><span class="p">(</span><span class="n">_defer_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;indicate a &#39;deferred&#39; name that was ultimately the value None.&quot;&quot;&quot;</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">()</span>

<span class="n">_NONE_NAME</span> <span class="o">=</span> <span class="n">_defer_none_name</span><span class="p">(</span><span class="s2">&quot;_unnamed_&quot;</span><span class="p">)</span>

<span class="c1"># for backwards compatibility in case</span>
<span class="c1"># someone is re-implementing the</span>
<span class="c1"># _truncated_identifier() sequence in a custom</span>
<span class="c1"># compiler</span>
<span class="n">_generated_label</span> <span class="o">=</span> <span class="n">_truncated_label</span>


<span class="k">class</span> <span class="nc">_anonymous_label</span><span class="p">(</span><span class="n">_truncated_label</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A unicode subclass used to identify anonymously</span>
<span class="sd">    generated names.&quot;&quot;&quot;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_anonymous_label</span><span class="p">(</span>
            <span class="n">quoted_name</span><span class="p">(</span>
                <span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">quote</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_anonymous_label</span><span class="p">(</span>
            <span class="n">quoted_name</span><span class="p">(</span>
                <span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="bp">self</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">quote</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># preserve quoting only if necessary</span>
            <span class="k">return</span> <span class="n">quoted_name</span><span class="p">(</span><span class="bp">self</span> <span class="o">%</span> <span class="n">map_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># else skip the constructor call</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">%</span> <span class="n">map_</span>


<span class="k">def</span> <span class="nf">_as_truncated</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;coerce the given value to :class:`._truncated_label`.</span>

<span class="sd">    Existing :class:`._truncated_label` and</span>
<span class="sd">    :class:`._anonymous_label` objects are passed</span>
<span class="sd">    unchanged.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_truncated_label</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_truncated_label</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_string_or_unprintable</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;unprintable element </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">element</span>


<span class="k">def</span> <span class="nf">_expand_cloned</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;expand the given set of ClauseElements to be the set of all &#39;cloned&#39;</span>
<span class="sd">    predecessors.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_cloned_set</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_select_iterables</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;expand tables into individual columns in the</span>
<span class="sd">    given list of column expressions.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_select_iterable</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_cloned_intersection</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;return the intersection of sets a and b, counting</span>
<span class="sd">    any overlap between &#39;cloned&#39; predecessors.</span>

<span class="sd">    The returned set is in terms of the entities present within &#39;a&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_overlap</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_expand_cloned</span><span class="p">(</span><span class="n">a</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">_expand_cloned</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">a</span>
               <span class="k">if</span> <span class="n">all_overlap</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">_cloned_set</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_cloned_difference</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">all_overlap</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_expand_cloned</span><span class="p">(</span><span class="n">a</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">_expand_cloned</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">a</span>
               <span class="k">if</span> <span class="ow">not</span> <span class="n">all_overlap</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">_cloned_set</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_labeled</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">element</span>


<span class="k">def</span> <span class="nf">_is_column</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;True if ``col`` is an instance of :class:`.ColumnElement`.&quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">ColumnElement</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_find_columns</span><span class="p">(</span><span class="n">clause</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;locate Column objects within the given expression.&quot;&quot;&quot;</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">column_set</span><span class="p">()</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{</span><span class="s1">&#39;column&#39;</span><span class="p">:</span> <span class="n">cols</span><span class="o">.</span><span class="n">add</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">cols</span>


<span class="c1"># there is some inconsistency here between the usage of</span>
<span class="c1"># inspect() vs. checking for Visitable and __clause_element__.</span>
<span class="c1"># Ideally all functions here would derive from inspect(),</span>
<span class="c1"># however the inspect() versions add significant callcount</span>
<span class="c1"># overhead for critical functions like _interpret_as_column_or_from().</span>
<span class="c1"># Generally, the column-based functions are more performance critical</span>
<span class="c1"># and are fine just checking for __clause_element__().  It is only</span>
<span class="c1"># _interpret_as_from() where we&#39;d like to be able to receive ORM entities</span>
<span class="c1"># that have no defined namespace, hence inspect() is needed there.</span>


<span class="k">def</span> <span class="nf">_column_as_key</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__clause_element__&#39;</span><span class="p">):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">key</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">_clause_element_as_expr</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__clause_element__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">element</span>


<span class="k">def</span> <span class="nf">_literal_as_label_reference</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_textual_label_reference</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__clause_element__&#39;</span><span class="p">):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">_literal_as_text</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_literal_and_labels_as_label_reference</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_textual_label_reference</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__clause_element__&#39;</span><span class="p">):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">ColumnElement</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="n">element</span><span class="o">.</span><span class="n">_order_by_label_element</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_label_reference</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_literal_as_text</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_expression_literal_as_text</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_literal_as_text</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_literal_as_text</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Visitable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__clause_element__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">warn</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">warn_limited</span><span class="p">(</span>
                <span class="s2">&quot;Textual SQL expression </span><span class="si">%(expr)r</span><span class="s2"> should be &quot;</span>
                <span class="s2">&quot;explicitly declared as text(</span><span class="si">%(expr)r</span><span class="s2">)&quot;</span><span class="p">,</span>
                <span class="p">{</span><span class="s2">&quot;expr&quot;</span><span class="p">:</span> <span class="n">util</span><span class="o">.</span><span class="n">ellipses_string</span><span class="p">(</span><span class="n">element</span><span class="p">)})</span>

        <span class="k">return</span> <span class="n">TextClause</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">NoneType</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">_const_expr</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
            <span class="s2">&quot;SQL expression object or string expected, got object of type </span><span class="si">%r</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;instead&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">_no_literals</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__clause_element__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Visitable</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span><span class="s2">&quot;Ambiguous literal: </span><span class="si">%r</span><span class="s2">.  Use the &#39;text()&#39; &quot;</span>
                                <span class="s2">&quot;function to indicate a SQL expression &quot;</span>
                                <span class="s2">&quot;literal, or &#39;literal()&#39; to indicate a &quot;</span>
                                <span class="s2">&quot;bound value.&quot;</span> <span class="o">%</span> <span class="n">element</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">element</span>


<span class="k">def</span> <span class="nf">_is_literal</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Visitable</span><span class="p">)</span> <span class="ow">and</span> \
        <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__clause_element__&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_only_column_elements_or_none</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">element</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_only_column_elements</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_only_column_elements</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__clause_element__&#39;</span><span class="p">):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">ColumnElement</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
            <span class="s2">&quot;Column-based expression object expected for argument &quot;</span>
            <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;; got: &#39;</span><span class="si">%s</span><span class="s2">&#39;, type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">element</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">element</span>


<span class="k">def</span> <span class="nf">_literal_as_binds</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__clause_element__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Visitable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">element</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Null</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BindParameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">element</span>

<span class="n">_guess_straight_column</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;^\w\S*$&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_interpret_as_column_or_from</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Visitable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__clause_element__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>

    <span class="n">insp</span> <span class="o">=</span> <span class="n">inspection</span><span class="o">.</span><span class="n">inspect</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">raiseerr</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">insp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">NoneType</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">_const_expr</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">insp</span><span class="p">,</span> <span class="s2">&quot;selectable&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">insp</span><span class="o">.</span><span class="n">selectable</span>

    <span class="c1"># be forgiving as this is an extremely common</span>
    <span class="c1"># and known expression</span>
    <span class="k">if</span> <span class="n">element</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
        <span class="n">guess_is_literal</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">ColumnClause</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">element</span><span class="p">),</span> <span class="n">is_literal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">element</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="c1"># give into temptation, as this fact we are guessing about</span>
        <span class="c1"># is not one we&#39;ve previously ever needed our users tell us;</span>
        <span class="c1"># but let them know we are not happy about it</span>
        <span class="n">guess_is_literal</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">_guess_straight_column</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="n">util</span><span class="o">.</span><span class="n">warn_limited</span><span class="p">(</span>
            <span class="s2">&quot;Textual column expression </span><span class="si">%(column)r</span><span class="s2"> should be &quot;</span>
            <span class="s2">&quot;explicitly declared with text(</span><span class="si">%(column)r</span><span class="s2">), &quot;</span>
            <span class="s2">&quot;or use </span><span class="si">%(literal_column)s</span><span class="s2">(</span><span class="si">%(column)r</span><span class="s2">) &quot;</span>
            <span class="s2">&quot;for more specificity&quot;</span><span class="p">,</span>
            <span class="p">{</span>
                <span class="s2">&quot;column&quot;</span><span class="p">:</span> <span class="n">util</span><span class="o">.</span><span class="n">ellipses_string</span><span class="p">(</span><span class="n">element</span><span class="p">),</span>
                <span class="s2">&quot;literal_column&quot;</span><span class="p">:</span> <span class="s2">&quot;literal_column&quot;</span>
                <span class="k">if</span> <span class="n">guess_is_literal</span> <span class="k">else</span> <span class="s2">&quot;column&quot;</span>
            <span class="p">})</span>
    <span class="k">return</span> <span class="n">ColumnClause</span><span class="p">(</span>
        <span class="n">element</span><span class="p">,</span>
        <span class="n">is_literal</span><span class="o">=</span><span class="n">guess_is_literal</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_const_expr</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">(</span><span class="n">Null</span><span class="p">,</span> <span class="n">False_</span><span class="p">,</span> <span class="n">True_</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">element</span>
    <span class="k">elif</span> <span class="n">element</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Null</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">element</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">False_</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">element</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">True_</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
            <span class="s2">&quot;Expected None, False, or True&quot;</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">_type_from_args</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">_isnull</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span>


<span class="k">def</span> <span class="nf">_corresponding_column_or_error</span><span class="p">(</span><span class="n">fromclause</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span>
                                   <span class="n">require_embedded</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">fromclause</span><span class="o">.</span><span class="n">corresponding_column</span><span class="p">(</span><span class="n">column</span><span class="p">,</span>
                                        <span class="n">require_embedded</span><span class="o">=</span><span class="n">require_embedded</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
            <span class="s2">&quot;Given column &#39;</span><span class="si">%s</span><span class="s2">&#39;, attached to table &#39;</span><span class="si">%s</span><span class="s2">&#39;, &quot;</span>
            <span class="s2">&quot;failed to locate a corresponding column from table &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span>
            <span class="o">%</span>
            <span class="p">(</span><span class="n">column</span><span class="p">,</span>
             <span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s1">&#39;table&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
             <span class="n">fromclause</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span>


<span class="k">class</span> <span class="nc">AnnotatedColumnElement</span><span class="p">(</span><span class="n">Annotated</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">Annotated</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">ColumnElement</span><span class="o">.</span><span class="n">comparator</span><span class="o">.</span><span class="n">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;table&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_with_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">AnnotatedColumnElement</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_with_annotations</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ColumnElement</span><span class="o">.</span><span class="n">comparator</span><span class="o">.</span><span class="n">_reset</span><span class="p">(</span><span class="n">clone</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clone</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;pull &#39;name&#39; from parent, if not present&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Annotated__element</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;pull &#39;table&#39; from parent, if not present&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Annotated__element</span><span class="o">.</span><span class="n">table</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;pull &#39;key&#39; from parent, if not present&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Annotated__element</span><span class="o">.</span><span class="n">key</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Annotated__element</span><span class="o">.</span><span class="n">info</span>

    <span class="nd">@util.memoized_property</span>
    <span class="k">def</span> <span class="nf">anon_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Annotated__element</span><span class="o">.</span><span class="n">anon_label</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Luca Venturini, Shabhonam Caim.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>