import os
import sys
import glob
import itertools
import yaml
from Mikado.utilities import path_join
import Mikado.configuration.configurator
import subprocess
import gzip
from snakemake import logger as snake_logger
import pkg_resources
import Mikado

prod_conda = pkg_resources.resource_filename("Mikado.daijin", os.path.join("envs", "prodigal.yaml"))


swissprot = "uniprot_sprot_plants.fasta.gz"
swissprot_noat = "uniprot_sprot_plants.not_at.fasta"

DBs=[swissprot]
zipDBs=["{0}.gz".format(db) for db in DBs]

configname = "configuration.yaml"
if not os.path.exists(configname):
    command = "mikado configure --use-transdecoder --seed 1149199520 --use-blast --list list.txt --reference chr5.fas.gz --mode permissive --daijin -t 3 \
        --subloci-out mikado.subloci.gff3 --scoring plant.yaml --junctions junctions.bed -bt {swiss} -bc 1 {configname}".format(configname=configname, swiss=swissprot)
    snake_logger.info("Creating the configuration file")
    snake_logger.info(command)
    subprocess.call(command, shell=True)

try:
    config = Mikado.configuration.configurator.to_json(configname)
except:
    os.remove(configname)
    raise

configfile: "configuration.yaml"

rule complete:
    input: "compare.stats", "compare_subloci.stats", "compare_input.stats", "check.ok",
         "check_metrics.ok", "daijin_test/mikado.yaml", "g11.ok"
    output: touch("finished.ok")


rule uncompress_genome:
  input: "chr5.fas.gz"
  output: "chr5.fas"
  shell: "gunzip -dc {input} > {output}"

rule daijin_configure:
    input:
      prots=swissprot,
      genome=rules.uncompress_genome.output
    output: "daijin.yaml"
    shell: "daijin configure -as stringtie cufflinks scallop -lal gmap --scheduler local -al \
star hisat gsnap --sample-sheet samples.txt -o daijin.yaml -g {input.genome} -od daijin_test \
 --prot-db {input.prots} --scoring plant.yaml"


rule daijin_assemble:
    input:
        conf=rules.daijin_configure.output
    output:
        conf="daijin_test/mikado.yaml"
    threads: 4
    message: "daijin assemble --nolock --use-conda --threads 2 --cores 4 --jobs 2 daijin.yaml"
    shell: "daijin assemble --nolock --use-conda --threads 2 --cores 4 --jobs 2 daijin.yaml"

rule test_json:
    input: db=swissprot, config=configname
    output: touch("{}.ok".format(configname))
    message: "Checking the configuration"
    run:
        try:
            __= Mikado.configuration.configurator.to_json(configname)
        except:
            os.remove(configname)
            raise
        # subprocess.call("gunzip -c chr5.fas.gz > chr5.fas", shell=True)
        # shell("touch {output}")

rule daijin:
    input: "class.gtf", "cufflinks.gtf", "stringtie.gtf", "trinity.gff3", "mikado.bed", rules.test_json.output, swissprot
    output:
        loci=os.path.join("Daijin", "5-mikado", "pick", "permissive", "mikado-permissive.loci.gff3"),
        sub=os.path.join("Daijin", "5-mikado", "pick", "permissive", "mikado.subloci.gff3"),
	    submetrics=os.path.join("Daijin", "5-mikado", "pick", "permissive", "mikado.subloci.metrics.tsv"),
        db=os.path.join("Daijin", "5-mikado", "mikado.db"),
        # mono=os.path.join("Daijin", "5-mikado", "pick", "permissive", "mikado.monoloci.gff3"),
        prep=os.path.join("Daijin", "5-mikado", "mikado_prepared.gtf"),
        prep_fasta=os.path.join("Daijin", "5-mikado", "mikado_prepared.fasta"),
	    prep_fai=os.path.join("Daijin", "5-mikado", "mikado_prepared.fasta.fai"),
        perm_stats=os.path.join("Daijin", "5-mikado", "pick", "permissive", "mikado-permissive.loci.stats"),
        stats=os.path.join("Daijin", "5-mikado", "pick", "comparison.stats"),
        marker=os.path.join("Daijin", "5-mikado", "all.done")
    message: "daijin mikado --use-conda --jobs 2 --cores 4 --threads 2 -nd --nolock configuration.yaml"
    shell: "daijin mikado --use-conda --jobs 2 --cores 4 --threads 2 -nd --nolock configuration.yaml"

rule index_reference:
    input: reference="reference.gff3"
    output: "reference.gff3.midx"
    log: "index.log"
    message: """mikado compare -r {input[reference]} --index --log {log}"""
    shell: """mikado compare -r {input[reference]} --index --log {log}"""

rule compare:
    input: reference="reference.gff3", prediction=rules.daijin.output.loci, midx=rules.index_reference.output
    output: "compare.stats", "compare.tmap", "compare.refmap"
    log: "compare.log"
    message: """mikado compare -r {input[reference]} -p {input[prediction]} -o compare -l {log}"""
    shell: """mikado compare -r {input[reference]} -p {input[prediction]} -o compare -l {log}"""
    
rule compare_input:
    input: reference="reference.gff3", prediction=rules.daijin.output.prep, midx=rules.index_reference.output
    output: "compare_input.stats", "compare_input.tmap", "compare_input.refmap"
    log: "compare_input.log"
    message: """mikado compare -r {input[reference]} -p {input[prediction]} -o compare_input -l {log}"""
    shell: """mikado compare -r {input[reference]} -p {input[prediction]} -o compare_input -l {log}"""

rule compare_subloci:
    input: reference="reference.gff3", prediction=rules.daijin.output.sub, midx=rules.index_reference.output
    output: "compare_subloci.stats", "compare_subloci.tmap", "compare_subloci.refmap"
    log: "compare_subloci.log"
    message: """mikado compare -r {input[reference]} -p {input[prediction]} -o compare_subloci -l {log}"""
    shell: """mikado compare -r {input[reference]} -p {input[prediction]} -o compare_subloci -l {log}"""

rule check_logs:
    input:
      pick_out=rules.daijin.output.loci,
      compare_out=rules.compare.output,
      compare_input_out=rules.compare_input.output,
      compare_subloci_out=rules.compare_subloci.output
    output: touch("check.ok")
    run:
      for inp_file in ["Daijin/5-mikado/pick/permissive/mikado-permissive.pick.log",
                       "Daijin/5-mikado/mikado_prepare.log",
                       "Daijin/5-mikado/mikado_serialise.log",
                       "compare.log",
		       "compare_subloci.log", "compare_input.log"]:
         inp_handle = open(inp_file, "rt")
   	 for line in inp_handle:
      	   if "Error" in inp_handle:
      	     raise ValueError(inp_file)
      touch(output[0])

rule check_pick:
    input:
      metrics="Daijin/5-mikado/pick/permissive/mikado.subloci.metrics.tsv",
      fai="Daijin/5-mikado/mikado_prepared.fasta.fai"
    output: "check_metrics.ok"
    run:
      fai = len([_ for _ in open(input["fai"])])
      import pandas as pd
      metrics = pd.read_csv(input["metrics"], delimiter="\t")
      found_split = metrics[metrics.columns[0]].str.contains(".split").any()
      no_dups = (metrics[metrics.columns[0]].drop_duplicates().shape[0] == metrics.shape[0])
      total = metrics[metrics.columns[0]].str.replace("\.split[0-9]*", "", regex=True).drop_duplicates().shape[0]
      found_excluded = metrics[metrics.columns[2]].str.contains("excluded").any()
      if not found_excluded or not found_split or total != fai or not no_dups:
        raise ValueError("Something went wrong with Mikado pick, please check")
      open(output[0], "wt")


rule test_g11_prodigal:
    input:
      transcripts=rules.daijin.output.prep_fasta
    output: os.path.join("Daijin", "5-mikado", "prodigal", "transcripts.g11.gff3")
    threads: 1
    log: os.path.join("daijin_logs", "prodigal.g11.log")
    conda: prod_conda
    shell: "prodigal -g 11 -i {input.transcripts} -o {output} -f gff 2> {log} > {log}"


rule test_g11_serialise:
    input:
      db=rules.daijin.output.db,
      prodi=rules.test_g11_prodigal.output
    output: os.path.join("Daijin", "5-mikado", "mikado.g11.db")
    threads: 2
    log: os.path.join("Daijin", "5-mikado", "mikado_serialise.g11.log")
    shell: "mikado serialise --xml=Daijin/5-mikado/blast/xmls \
    --blast_targets=Daijin/5-mikado/blast/index/blastdb-proteins.fa --start-method=spawn \
    --transcripts=Daijin/5-mikado/mikado_prepared.fasta --genome_fai=Daijin/5-mikado/chr5.fas.gz.fai \
    --json-conf=configuration.yaml --force --orfs={input.prodi} \
    -od Daijin/5-mikado --procs=2 -l {log} {output}"

rule test_g11_pick:
    input:
      db=rules.test_g11_serialise.output
    output:
      loci=os.path.join("Daijin", "5-mikado", "pick", "g11_permissive", "mikado-permissive.loci.gff3"),
      subloci=os.path.join("Daijin", "5-mikado", "pick", "g11_permissive", "mikado-permissive.subloci.gff3")
    params:
      loci="mikado-permissive.loci.gff3",
      subloci="mikado-permissive.subloci.gff3",
      outdir=os.path.join("Daijin", "5-mikado", "pick", "g11_permissive")
    threads: 2
    log: os.path.join("Daijin", "5-mikado", "pick", "g11_permissive", "mikado-permissive.pick.log")
    shell: "mikado pick --source Mikado_permissive --mode=permissive --procs=2 \
    --start-method=spawn --json-conf=configuration.yaml -od {params.outdir} \
    -l {log} --loci-out {params.loci} --subloci-out {params.subloci} \
    -lv INFO -db {input.db} Daijin/5-mikado/mikado_prepared.gtf"


rule test_g11_gffread:
    input:
      subloci=rules.test_g11_pick.output.subloci,
      genome=rules.uncompress_genome.output
    output:
      subpep=os.path.join("Daijin", "5-mikado", "pick", "g11_permissive", "mikado-permissive.subloci.pep.fasta")
    conda: "gffread.yaml"
    shell: "gffread -g {input.genome} -y {output.subpep} {input.subloci}"


rule check_g11:
    input:
      subpep=rules.test_g11_gffread.output.subpep
    output: touch("g11.ok")
    run:
        with open(input.subpep) as subpep:
            for line in subpep:
                if line[0] != ">" and "*" in line:
                    print(line)
                    raise ValueError(line)
        touch(output)

rule clean:
    run:
        import shutil
        for filename in itertools.chain(glob.glob("*.ok"), glob.glob("uniprot*.fasta.p*"),
                                    glob.glob("daijin_*.stats"),
                                    glob.glob("*midx"), glob.glob("*fai"),
                                    glob.glob("uniprot*fasta"), glob.glob("*loci*"),
				                    ["daijin.yaml", "Daijin", "daijin_logs", "daijin_test"],
                                    ["mikado_prepared.gtf", "mikado_prepared.fasta", "mikado.prodigal.gff3"],
                                    glob.glob("compare*"), glob.glob(config["db_settings"]["db"]),
                                    glob.glob("*.log"), glob.glob("*xml"), ["chr5.fas"],
				                    glob.glob("*.ok"),
                                    ["configuration.yaml"]):
            if os.path.exists(filename) and filename not in (".", ".."):
                shutil.rmtree(filename) if os.path.isdir(filename) else os.remove(filename)

rule clean_crumbs:
    run:
        for filename in itertools.chain(["finished.ok"], glob.glob("mikado*loci*"),
                                        glob.glob("compare*")):
            if os.path.exists(filename):
                os.remove(filename)
