import os
import sys
import glob
import itertools
import yaml
from Mikado.utilities import path_join
import Mikado.configuration.configurator
import subprocess
import gzip
from snakemake import logger as snake_logger

swissprot = "uniprot_sprot_plants.fasta"
swissprot_noat = "uniprot_sprot_plants.not_at.fasta"

DBs=[swissprot]
zipDBs=["{0}.gz".format(db) for db in DBs]

configname = "configuration.yaml"
if not os.path.exists(configname):
    command = "mikado configure --list list.txt --reference chr5.fas.gz --mode permissive --daijin -t 3 \
        --subloci-out mikado.subloci.gff3 --scoring plant.yaml --junctions junctions.bed -bt {swiss} -bc 1 {configname}".format(configname=configname, swiss=swissprot)
    snake_logger.info("Creating the configuration file")
    snake_logger.info(command)
    subprocess.call(command, shell=True)

try:
    config = Mikado.configuration.configurator.to_json(configname)
except:
    os.remove(configname)
    raise

configfile: "configuration.yaml"

rule complete:
    input: "compare.stats", "compare_subloci.stats", "compare_input.stats", "check.ok", "check_metrics.ok"
    output: touch("finished.ok")

rule test_json:
    input: db=zipDBs, config=configname
    output: touch("{}.ok".format(configname))
    message: "Checking the configuration"
    run:
        try:
            __= Mikado.configuration.configurator.to_json(configname)
        except:
            os.remove(configname)
            raise
        # subprocess.call("gunzip -c chr5.fas.gz > chr5.fas", shell=True)
        # shell("touch {output}")

rule uncompress_blast:
    input: "{0}.gz".format(swissprot)
    output: swissprot
    message: "gzip -dc {input} > {output}"
    shell:
      "gzip -dc {input} > {output}"

rule daijin:
    input: "class.gtf", "cufflinks.gtf", "stringtie.gtf", "trinity.gff3", "mikado.bed", rules.test_json.output, rules.uncompress_blast.output
    output:
        loci=os.path.join("Daijin", "5-mikado", "pick", "permissive", "mikado-permissive.loci.gff3"),
        sub=os.path.join("Daijin", "5-mikado", "pick", "permissive", "mikado.subloci.gff3"),
	submetrics=os.path.join("Daijin", "5-mikado", "pick", "permissive", "mikado.subloci.metrics.tsv"),
        # mono=os.path.join("Daijin", "5-mikado", "pick", "permissive", "mikado.monoloci.gff3"),
        prep=os.path.join("Daijin", "5-mikado", "mikado_prepared.gtf"),
	prep_fai=os.path.join("Daijin", "5-mikado", "mikado_prepared.fasta.fai")
    message: "daijin mikado --jobs 1 --cores 2 --threads 2 -nd --nolock configuration.yaml"
    shell: "daijin mikado --jobs 1 --cores 2 --threads 2 -nd --nolock configuration.yaml"

rule index_reference:
    input: reference="reference.gff3"
    output: "reference.gff3.midx"
    log: "index.log"
    message: """mikado compare -r {input[reference]} --index --log {log}"""
    shell: """mikado compare -r {input[reference]} --index --log {log}"""

rule compare:
    input: reference="reference.gff3", prediction=rules.daijin.output.loci, midx=rules.index_reference.output
    output: "compare.stats", "compare.tmap", "compare.refmap"
    log: "compare.log"
    message: """mikado compare -r {input[reference]} -p {input[prediction]} -o compare -l {log}"""
    shell: """mikado compare -r {input[reference]} -p {input[prediction]} -o compare -l {log}"""
    
rule compare_input:
    input: reference="reference.gff3", prediction=rules.daijin.output.prep, midx=rules.index_reference.output
    output: "compare_input.stats", "compare_input.tmap", "compare_input.refmap"
    log: "compare_input.log"
    message: """mikado compare -r {input[reference]} -p {input[prediction]} -o compare_input -l {log}"""
    shell: """mikado compare -r {input[reference]} -p {input[prediction]} -o compare_input -l {log}"""

rule compare_subloci:
    input: reference="reference.gff3", prediction=rules.daijin.output.sub, midx=rules.index_reference.output
    output: "compare_subloci.stats", "compare_subloci.tmap", "compare_subloci.refmap"
    log: "compare_subloci.log"
    message: """mikado compare -r {input[reference]} -p {input[prediction]} -o compare_subloci -l {log}"""
    shell: """mikado compare -r {input[reference]} -p {input[prediction]} -o compare_subloci -l {log}"""

rule check_logs:
    input:
      pick_out=rules.daijin.output.loci,
      compare_out=rules.compare.output,
      compare_input_out=rules.compare_input.output,
      compare_subloci_out=rules.compare_subloci.output
    output: touch("check.ok")
    run:
      for inp_file in ["Daijin/5-mikado/pick/permissive/mikado-permissive.pick.err",
                       "Daijin/5-mikado/serialise.log",
                       "Daijin/5-mikado/prepare.log",
                       "Daijin/5-mikado/mikado_serialise.err",
                       "compare.log",
		       "compare_subloci.log", "compare_input.log"]:
         inp_handle = open(inp_file, "rt")
   	 for line in inp_handle:
      	   if "Error" in inp_handle:
      	     raise ValueError(inp_file)
      touch(output[0])

rule check_pick:
    input:
      metrics="Daijin/5-mikado/pick/permissive/mikado.subloci.metrics.tsv",
      fai="Daijin/5-mikado/mikado_prepared.fasta.fai"
    output: "check_metrics.ok"
    run:
      fai = len([_ for _ in open(input["fai"])])
      import pandas as pd
      metrics = pd.read_csv(input["metrics"], delimiter="\t")
      found_split = metrics[metrics.columns[0]].str.contains(".split").any()
      no_dups = (metrics[metrics.columns[0]].drop_duplicates().shape[0] == metrics.shape[0])
      total = metrics[metrics.columns[0]].str.replace("\.split[0-9]*", "", regex=True).drop_duplicates().shape[0]
      found_excluded = metrics[metrics.columns[2]].str.contains("excluded").any()
      if not found_excluded or not found_split or total != fai or not no_dups:
        raise ValueError("Something went wrong with Mikado pick, please check")
      open(output[0], "wt")

rule clean:
    run:
        import shutil
        for filename in itertools.chain(glob.glob("*.ok"), glob.glob("uniprot*.fasta.p*"),
                                    glob.glob("*midx"), glob.glob("*fai"),
				    "Daijin",
                                    glob.glob("uniprot*fasta"), glob.glob("*loci*"),
                                    ["mikado_prepared.gtf", "mikado_prepared.fasta", "mikado.prodigal.gff3"],
                                    glob.glob("compare*"), glob.glob(config["db_settings"]["db"]),
                                    glob.glob("*.log"), glob.glob("*xml"), ["chr5.fas"],
				    glob.glob("*.ok"),
                                    ["configuration.yaml"]):
            if os.path.exists(filename):
                shutil.rmtree(filename) if os.path.isdir(filename) else os.remove(filename)

rule clean_crumbs:
    run:
        for filename in itertools.chain(["finished.ok"], glob.glob("mikado*loci*"),
                                        glob.glob("compare*")):
            if os.path.exists(filename):
                os.remove(filename)
